<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TIBCO.EMS</name>
    </assembly>
    <members>
        <member name="T:TIBCO.EMS.BytesMessage">
            <summary>A BytesMessage object is used to send a message containing a 
            stream of uninterpreted bytes. It inherits from the Message interface and 
            adds a bytes message body. The receiver of the message supplies the 
            interpretation of the bytes. </summary>
            <remarks>
            <para>
            This message type is for client encoding of existing message formats. 
            If possible, one of the other self-defining message types should be used instead. 
            </para>
            <para> The primitive types can be written explicitly using methods for each type. 
            They may also be written generically as objects. For instance, 
            a call to BytesMessage.writeInt(6) is equivalent to 
            BytesMessage.writeObject((object)6). Both forms are provided, 
            because the explicit form is convenient for static programming, and the object form is 
            needed when types are not known at compile time. 
            </para>
            <para>
            When the message is first created, and when clearBody is called, the body of 
            the message is in write-only mode. After the first call to reset has been made, 
            the message body is in read-only mode. After a message has been sent, 
            the client that sent it can retain and modify it without affecting the message 
            that has been sent. The same message object can be sent multiple times. 
            When a message has been received, the provider has called reset so that the 
            message body is in read-only mode for the client. 
            </para>
            <para> If clearBody is called on a message in read-only mode, the message body is 
            cleared and the message is in write-only mode. 
            </para>
            <para> If a client attempts to read a message in write-only mode, 
            a MessageNotReadableException is thrown. 
            </para>
            <para> If a client attempts to write a message in read-only mode, 
            a MessageNotWriteableException is thrown. 
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.#ctor">
            <summary>Construct an empty bytes message. </summary>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.#ctor(TIBCO.EMS.Session)">
            <summary>Construct an empty bytes message for a session. </summary>
            <param name="session">The session of the message. </param>
        </member>
        <member name="P:TIBCO.EMS.BytesMessage.BodyLength">
            <summary> Gets the number of bytes of the message body when the 
            message is in read-only mode. The value returned can be used to
            allocate a byte array. The value returned is the entire length of 
            the message body, regardless of where the pointer for reading the 
            message is currently located
            </summary>
            <returns> number of bytes in the message </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.Clone">
            <summary>Create a copy of the BytesMessage object. </summary>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadBoolean">
            <summary> Reads a boolean from the bytes message stream. </summary>
            <remarks>Reads one byte from the byte stream of a BytesMessage and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the boolean value read </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadByte">
            <summary> Reads a byte from the bytes message stream. </summary>
            <remarks>Reads one byte from the byte stream of a BytesMessage and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the byte value read </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadUnsignedByte">
            <summary> Reads a unsigned byte from the bytes message stream. </summary>
            <remarks>Reads one byte from the byte stream of a BytesMessage and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the unsigned byte value read </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadShort">
            <summary> Reads a short from the bytes message stream. </summary>
            <remarks>Reads two bytes from the byte stream of a BytesMessage and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the short value read </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadUnsignedShort">
            <summary> Reads a unsigned short from the bytes message stream. </summary>
            <remarks>Reads two bytes from the byte stream of a BytesMessage and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the unsigned short value read </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadChar">
            <summary> Reads a char from the bytes message stream. </summary>
            <remarks>Reads two bytes from the byte stream of a BytesMessage and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the char value read </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadInt">
            <summary> Reads a int from the bytes message stream. </summary>
            <remarks>Reads four bytes from the byte stream of a BytesMessage and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the int value read </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadLong">
            <summary> Reads a long from the bytes message stream. </summary>
            <remarks>Reads eight bytes from the byte stream of a BytesMessage and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the long value read </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadFloat">
            <summary> Reads a float from the bytes message stream. </summary>
            <remarks>Reads four bytes from the byte stream of a BytesMessage and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the float value read </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadDouble">
            <summary> Reads a double from the bytes message stream. </summary>
            <remarks>Reads eight bytes from the byte stream of a BytesMessage and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the double value read </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadUTF">
            <summary> Reads a UTF string from the bytes message stream. </summary>
            <remarks>Reads a UTF-8 string. Since the length of the string cannot 
            be determined in advance, the method stores the actual length of the string.
            </remarks>
            <returns>the utf string value read </returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadBytes(System.Byte[])">
            <summary> Reads a byte array from the bytes message stream. </summary>
            <remarks>This method reads bytes from the stream into the byte array and advances the 
            read position.</remarks>
            <returns>The actual number of bytes read. When the call cannot read even one byte, 
            it returns -1.</returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ReadBytes(System.Byte[],System.Int32)">
            <summary> Reads a byte array from the bytes message stream. </summary>
            <remarks>This method reads bytes from the stream into the byte array and advances the 
            read position. This method attempts to read 
            length bytes; otherwise it attempts to read value.length bytes.</remarks>
            <returns>The actual number of bytes read. When the method cannot read even one byte, 
            it returns -1.</returns>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteBoolean(System.Boolean)">
            <summary> Writes a boolean to the bytes message stream as a
            1-byte value. The value true is written as the value (byte)1;
            the value false is written as the value (byte)0. 
            </summary>
            <remarks>Writes one byte of data to the stream and advances the write position 
            so that the next write call appends to the new end of the stream.</remarks>
            <param name="value"> the boolean value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteByte(System.Byte)">
            <summary> Writes a byte to the bytes message stream as a 1-byte value. </summary>
            <remarks>Writes one byte of data to the stream and advances the write position 
            so that the next write call appends to the new end of the stream.</remarks>
            <param name="value">the byte value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteShort(System.Int16)">
            <summary>Writes a short to the bytes message stream as two bytes,
            high byte first. </summary>
            <remarks>Writes two bytes of data to the stream and advances the write position 
            so that the next write call appends to the new end of the stream.</remarks>
            <param name="value">the short to be written </param>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteChar(System.Char)">
            <summary>Writes a char to the bytes message stream </summary>
            <remarks>Writes two bytes of data to the stream and advances the write position 
            so that the next write call appends to the new end of the stream.</remarks>
            <param name="value">the char value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteInt(System.Int32)">
            <summary>Writes a int to the bytes message stream </summary>
            <remarks>Writes four bytes of data to the stream and advances the write position 
            so that the next write call appends to the new end of the stream.</remarks>
            <param name="value">the int value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteLong(System.Int64)">
            <summary>Writes a long to the bytes message stream </summary>
            <remarks>Writes eight bytes of data to the stream and advances the write position 
            so that the next write call appends to the new end of the stream.</remarks>
            <param name="value">the long value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteFloat(System.Single)">
            <summary>Writes a float to the bytes message stream </summary>
            <remarks>Writes four bytes of data to the stream and advances the write position 
            so that the next write call appends to the new end of the stream.</remarks>
            <param name="value">the float value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteDouble(System.Double)">
            <summary>Writes a double to the bytes message stream </summary>
            <remarks>Writes eight bytes of data to the stream and advances the write position 
            so that the next write call appends to the new end of the stream.</remarks>
            <param name="value">the double value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteUTF(System.String)">
            <summary>Writes a utf string to the bytes message stream </summary>
            <remarks>Writes variable-length encoded UTF-8 data to the stream and advances the write position 
            so that the next write call appends to the new end of the stream.</remarks>
            <param name="value">the utf string value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteBytes(System.Byte[])">
            <summary>Writes a byte array to the bytes message stream </summary>
            <remarks>Each call writes bytes from the byte array into the stream, 
            and advances the write position.</remarks>
            <param name="value">the byte array value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Writes a portion of the byte array to the bytes message stream </summary>
            <param name="value">Write bytes from this byte array to the message.</param>
            <param name="offset">Begin with the byte at this offset within the byte array.</param>
            <param name="length">Write this number of bytes from the byte array.</param>
            <remarks>The offset and length arguments must conform to these restrictions:
            <list type="bullet">
            <item><description>offset must be in the range [0, value.length-1]</description></item>
            <item><description>length must be in the range [0, value.length]</description></item>
            <item><description>offset+length must be in the range [0, value.length]</description></item>
            </list>
            That is, these two arguments must specify a span of bytes within the value argument. 
            Otherwise the call throws a System.IndexOutOfRangeException (and does not write any bytes).
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.WriteObject(System.Object)">
            <summary> Writes an object to the bytes message stream. </summary>
            <remarks>
            <para>
            Converts an object to a primitive value (if possible), and writes that value 
            to the byte stream.
            </para> <para>
            This method works only for the objectified primitive object types 
            (Integer, Double, Long ...), String objects, and byte arrays
            </para>
            </remarks>
            <param name="value">the object to be written </param>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.Reset">
            <summary> Puts the message body in read-only mode and 
            repositions the stream of bytes to the beginning. </summary>
            <remarks>Reset prepares a message body for reading, as if the message 
            were newly received. This is in contrast to Message.ClearBody, which clears 
            a message body in preparation for writing, as if it were newly created.</remarks>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ClearBody">
            <summary> Clears out the message body. Clearing a message's body does 
            not clear its header values or property entries. 
            </summary>
            <remarks>
            <para> If this message body was read-only, calling this method leaves
            the message body in the same state as an empty body in a newly created
            message. 
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.BytesMessage.ToString">
            <summary> returns a string representation of the map message </summary>
            <returns> a string representation of the map message </returns>
        </member>
        <member name="T:TIBCO.EMS.CFImpl">
            <summary>Internal connection factory implementation </summary>
        </member>
        <member name="M:TIBCO.EMS.CFImpl.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Constructor for deserialization. It will only
            work for version number >= 3 the earlist version of
            .NET client implementation.</summary>
        </member>
        <member name="M:TIBCO.EMS.CFImpl.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Implement ISerializable interface for controlled
            serialization </summary>
        </member>
        <member name="M:TIBCO.EMS.CFImpl.Clone">
            <summary>  </summary>
        </member>
        <member name="P:TIBCO.EMS.CFImpl.Url">
            <summary> return the url of this connection </summary>
        </member>
        <member name="P:TIBCO.EMS.CFImpl.ClientID">
            Returns client ID assigned to this connection factory 
            or null if client ID not set. 
        </member>
        <member name="P:TIBCO.EMS.CFImpl.Metric">
            Returns load balanced metric used by this connection factory. Note
            that the value of this metric is ignored if the factory is not a
            load balancing factory.
            <summary> Get or set the load balancing metric used by the connection
            factory </summary>
            <remarks>
            Valid metrics are:
            <list type="bullet">
            <item>FactoryLoadBalanceMetric.None: not load balanced</item>
            <item>FactoryLoadBalanceMetric.Connections: number of connections on server</item>
            <item>FactoryLoadBalanceMetric.ByteRate: total byte rate (input and output) on server</item>
            </list>
            If the factory is not a load balancing factory then the value returned
            will be FactoryLoadBalanceMetric.None. If the factory is a load
            balancing factory but no metric has been set explicitly then the
            metric returned will be the default metric  
            (FactoryLoadBalanceMetric.Connections) will be returned.
            </remarks>
            <exception cref="T:TIBCO.EMS.EMSException">If the value of metric to set is invalid</exception>
        </member>
        <member name="P:TIBCO.EMS.CFImpl.Properties">
            Returns properties assigned to this connection factory or null 
            if no properties were set. 
        </member>
        <member name="M:TIBCO.EMS.CFImpl.ToString">
            Returns String representation of this factory 
        </member>
        <member name="T:TIBCO.EMS.EMSExceptionEventArgs">
            <summary>Present a connection problem as a .NET event. </summary>
            <remarks>
            <see cref="T:TIBCO.EMS.EMSExceptionHandler"/> delegates receive this object as an argument.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.EMSExceptionEventArgs.#ctor(TIBCO.EMS.EMSException)">
            <summary> Construct a new EMSExceptionEventArgs</summary>
            <param name="emse">The EMSException which raised the event </param>
        </member>
        <member name="P:TIBCO.EMS.EMSExceptionEventArgs.Exception">
            <summary> Get the EMSException that caused the event </summary>
        </member>
        <member name="T:TIBCO.EMS.EMSExceptionHandler">
            <summary> Delegate declaration for exception handler </summary>
            <remarks>
            <para>Asynchronously detect problems with connections.
            </para>
            <para>When a program uses a connection to send messages, the send calls can detect 
            problems with the connection, and notify the client program by throwing exceptions. 
            However, when a program uses a connection only to receive messages, the client cannot 
            catch such exceptions.
            </para>
            <para>This delegate provides an alternate pathway for alerting a client program of connection 
            problems. The program implements this delegate, and registers it with the connection. 
            When the client library detects a connection problem, it raises an event. This delegate 
            processes the event, which contains an exception that details the problem.
            </para>
            <para>EMSExceptionHandler detects this type of problem in a .NET programming idiom. In 
            contrast, IExceptionListener mimics the way in which JMS provides similar functionality 
            in a Java programming idiom. Programmers may select either idiom - but not both (which would 
            cause duplicate exception processing, with undefined behavior).
            </para>
            
            <para><b>Exception Event Handler Example:</b></para>
            <code>
            ...
            connection.ExceptionHandler += new EMSExceptionHandler(handleEx);
            ...
            private void handleEx(object sender, EMSExceptionEventArgs arg)
            {
               EMSException e = arg.Exception;
               Console.WriteLine("Exception: " + e.Message);
            }
            ...
            </code>
            </remarks>
            <param name="sender">The source of the event, the <see cref="T:TIBCO.EMS.Connection"/> object in this case.</param>
            <param name="args">The event argument, <see cref="T:TIBCO.EMS.EMSExceptionEventArgs"/>, that 
            contains the exception object.</param>
        </member>
        <member name="T:TIBCO.EMS.Connection">
            <summary> A Connection object is a client's active connection to TIBCO EMS Server.
            </summary>
            <remarks ref="true()">
            <para> Connections support concurrent use. 
            </para>
            <para>A connection serves several purposes: 
            <list type="bullet">
            <item>It encapsulates an open connection with a TIBCO EMS Server. 
            It typically represents an open TCP/IP socket between a client 
            and the TIBCO EMS Server. </item>
            <item> Its creation is where client authentication takes place. </item>
            <item> It can specify a unique client identifier. </item>
            <item> It provides a <see cref="T:TIBCO.EMS.ConnectionMetaData">ConnectionMetaData</see> object. </item>
            <item> It supports an optional <see cref="P:TIBCO.EMS.Connection.ExceptionListener">ExceptionListener</see> 
            object. </item>
            </list>
            </para>
            <para> Because the creation of a connection involves setting up 
            authentication and communication, a connection is a relatively 
            heavyweight object. Most clients will do all their messaging with 
            a single connection. Other more advanced applications may use 
            several connections. 
            </para>
            <para>A client typically creates a connection, one or more sessions,
            and a number of message producers and consumers. When a connection 
            is created, it is in stopped mode. That means that no messages are being delivered. 
            </para>
            <para> It is typical to leave the connection in stopped mode until setup
            is complete and all message consumers have been created. 
            At that point, the client calls the connection's 
            <see cref="M:TIBCO.EMS.Connection.Start">Start</see> method, 
            and messages begin arriving at the connection's consumers. 
            (Outbound messages flow even before calling Start.)
            This setup convention minimizes any client confusion that may result 
            from asynchronous message delivery while the client is still in the 
            process of setting itself up. 
            </para>
            <para> A connection can be started immediately and the setup can be 
            done afterwards. Clients that do this must be prepared to handle 
            asynchronous message delivery while they are still in the process of setting up. 
            </para>
            <para> A message producer can send messages while a connection is stopped </para>
            
            <para><b>Asynchronous Exceptions</b></para>
            <para>
            When a program uses a connection to send messages, the send calls can detect problems 
            with the connection, and notify the client program (synchronously) by throwing exceptions.</para>
            <para>However, when a program uses a connection only to receive messages, the client 
            cannot catch such exceptions. Instead, programs can handle such exceptions asynchronously 
            in one of two idioms. Programmers may select either idiom - but not both (which would cause 
            duplicate exception processing, with undefined behavior).</para>
            <list type="bullet">
            <item><see cref="E:TIBCO.EMS.Connection.ExceptionHandler"/> events detect this type of problem in a .NET programming idiom.</item>
            <item>In contrast, the <see cref="P:TIBCO.EMS.Connection.ExceptionListener"/>  
            property mimics the way in which JMS provides similar functionality in a Java programming idiom.</item>
            </list>
            <b>Note: </b>
            The EMS .NET API does not support the optional methods createConnectionConsumer 
            and createDurableConnectionConsumer.
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Connection._userName">
            <summary> user name, we cache this </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._password">
            <summary> password </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._properties">
            <summary> properties </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._connid">
            <summary> connection id </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._clientID">
            <summary>
            client id, can not be changed after set
            or after connection is used in any way
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._exceptionListener">
            <summary> exception listener to call when connection with jmsd breaks </summary>
        </member>
        <member name="E:TIBCO.EMS.Connection._handleException">
            <summary> Exception event handler of type <see cref="T:TIBCO.EMS.EMSExceptionHandler"/>
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._started">
            <summary> true if connection is started, false if stopped </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._closed">
            <summary> true if connection has been closed </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._closing">
            <summary> true if connection is closing </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._clear">
            <summary>
            set to false after connection started or any sessions created,
            this is used to monitor clientID change (not legal after
            connection has been effectively used).
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._secure">
            <summary> true if server runs with security enabled </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._link">
            <summary> our link to the server </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._lock">
            <summary> connections support concurrent use </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._sessions">
            <summary> all sessions hashed by session id </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._dups_ok_sessions">
            <summary> dups_ok sessions </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._subscriptions">
            <summary>
            this is a list of subscriptions by destination id, each
            has a Vector of associated consumers
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._consumers">
            <summary> this is a map of all consumers </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._requestTimeout">
            <summary> default timeout of any request to jmsd </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._requestPriority">
            <summary>
            priority of request messages, not used so far, may be used if we switch
            to batching.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._isAdmin">
            <summary> true if admin connection </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._connect_attempt_count">
            <summary> connect and reconnect attempts parameters </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._hostName">
            <summary>
            host name and ip address, they are same for the same machine
            so they are static here, if one connection has got them the others
            can reuse...
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._connections">
            <summary> hash of all connections </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._DUPS_OK_INTERVAL">
            <summary> DUPS_OK management </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._dupsNotifier">
            <summary> DUPS_OK management </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._dot">
            <summary> DUPS_OK management </summary>
        </member>
        <member name="F:TIBCO.EMS.Connection._haveDups">
            <summary> DUPS_OK management </summary>
        </member>
        <member name="P:TIBCO.EMS.Connection.Urls">
            <summary>
            Get the urls for connection
            </summary>
        </member>
        <member name="P:TIBCO.EMS.Connection.UrlCount">
            <summary>
            Get number of connection urls.
            </summary>
        </member>
        <member name="P:TIBCO.EMS.Connection.ServerVersionMajor">
            <summary>
            Get server version major number
            </summary>
        </member>
        <member name="P:TIBCO.EMS.Connection.ServerVersionMinor">
            <summary>
            Get server version minor number
            </summary>
        </member>
        <member name="P:TIBCO.EMS.Connection.ServerVersion">
            <summary>
            Get server version number
            </summary>
        </member>
        <member name="P:TIBCO.EMS.Connection.RequestTimeout">
            <summary>
            Get timeout for request
            </summary>
        </member>
        <member name="P:TIBCO.EMS.Connection.RequestPriority">
            <summary>
            Get priority for request
            </summary>
        </member>
        <member name="P:TIBCO.EMS.Connection.IsClosed">
            <summary>
            Return true if connection is closed; otherwise false.
            </summary>
        </member>
        <member name="P:TIBCO.EMS.Connection.IsSecure">
            <summary>
            Return true if the connection communicates with a secure protocol; otherwise false.
            <remarks>
            This method has been deprecated.
            </remarks>
            </summary>
        </member>
        <member name="P:TIBCO.EMS.Connection.ConnID">
            <summary>
            Get the connection id.
            </summary>
        </member>
        <member name="P:TIBCO.EMS.Connection.ProtocolVersion">
            <summary>
            Get the implemented protocol version.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.Connection.DOT">
            <summary>
            DOT -- Dups Ok Thread
            This thread does things every _DUPS_OK_INTERVAL (250)
            milliseconds but only until it sees that it didn't have
            anything to handle twice in a row. Then it goes into wait
            until some dups_ok session wakes it up.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.Connection.#ctor(TIBCO.EMS.CFImpl,System.String,System.String,System.String,System.String,System.Collections.Hashtable)">
             <summary>Construct a connection instance with information </summary>
             <param name="factory">The connection factory instance, of type
             <c>ConnectionFactory</c>, <c>TopicConnectionFactory</c> or
             <c>QueueConnectionFactory</c>
             </param>
             <param name="urlString">The url of the server to connect to </param>
             <param name="clientID">The id of the client </param>
             <param name="userName">The user name of the client </param>
             <param name="password">The user password of the client </param>
             <param name="properties">The hashtable of properties for the client. </param>
            
        </member>
        <member name="P:TIBCO.EMS.Connection.ClientID">
            <summary> Gets and Set the Client Id </summary>
            <remarks>
            <para>This property holds the unique client ID of the connection.
            </para>
            <para>Client IDs partition the namespace of durable subscribers (see 
            <see cref="M:TIBCO.EMS.Session.CreateDurableSubscriber(TIBCO.EMS.Topic,System.String)">Session.CreateDurableSubscriber</see>).
            </para>
            <para>Administrators can configure 
            <see cref="T:TIBCO.EMS.ConnectionFactory">ConnectionFactory</see> objects to assign 
            client IDs to new connections. Alternatively, administrators can allow 
            client programs to assign their own IDs. If the factory does not assign 
            an ID, the program may dynamically set this property by calling the 
            <see cref="M:TIBCO.EMS.ConnectionFactory.SetClientID(System.String)">setClientID</see> method. 
            However, it is illegal to overwrite an existing client ID value, and or to set this property 
            after using the connection in any way (for example, after creating a 
            session, or starting the connection); attempting to set this property 
            in these situations results in IllegalStateException.
            </para>
            </remarks>
            <returns> the unique client identifier </returns>
            <exception cref="T:TIBCO.EMS.IllegalStateException">Attempt to overwrite existing ClientID 
             or to set the ClientID after using the connection. </exception>
        </member>
        <member name="P:TIBCO.EMS.Connection.ActiveURL">
            <summary> Get URL of the server this connection is currently connected 
            to</summary>
            <remarks>This property holds the URL of the server at the other endpoint 
            of the connection. When the connection interacts with several servers in a 
            fault-tolerant arrangement, this property indicates the current active server.</remarks>
        </member>
        <member name="P:TIBCO.EMS.Connection.MetaData">
            <summary> Gets the metadata for this connection. </summary>
            <returns> the connection metadata </returns>
        </member>
        <member name="E:TIBCO.EMS.Connection.ExceptionHandler">
            <summary> The exception event handler</summary>
            <remarks> 
            <para>The client library raises an event if it detects a problem with the 
            connection. The program implements a handler delegate to processes it asynchronously 
            and registers the delegate here.</para>
            
            Delegate declaration for exception handler is as follows: 
            <code>
            public delegate void EMSExceptionHandler(object sender, EMSExceptionEventArgs args); <br/>
            sender: The source of the event, the connection in this case. <br/>
            args: The event argument, <see cref="T:TIBCO.EMS.EMSExceptionEventArgs"/> <br/> 
            </code>
            <example>Example of using the exception event handler:
            <code>
            ...
            connection.ExceptionHandler += new EMSExceptionHandler(handleEx);
            ...
            private void handleEx(object sender, EMSExceptionEventArgs arg)
            {
               EMSException e = arg.Exception;
               Console.WriteLine("Exception: " + e.Message);
            }
            ...
            </code> 
            </example>
            <b>Note: </b>
            Use either ExceptionHandler or <see cref="P:TIBCO.EMS.Connection.ExceptionListener"/>
            to handle exceptions, but <b>not</b> both.  Setting up both will cause
            the exception to be handled more than once which can result in undefined
            behavior
            </remarks>
            <exception cref="T:TIBCO.EMS.IllegalStateException">If the connection is closed</exception>
        </member>
        <member name="P:TIBCO.EMS.Connection.ExceptionListener">
            <summary> Get and set the exception event listener</summary>
            <remarks ref="true()">
            <para>
            This is an alternate pathway for alerting a client program of connection problems. 
            The program implements the exception listener interface, and registers an exception 
            listener object by setting this property. When the client library detects a 
            connection problem, it calls the listener's onException method with an exception 
            argument that details the problem.
            </para>
            <b>Note: </b>
            Use either <see cref="E:TIBCO.EMS.Connection.ExceptionHandler"/> or ExceptionListener
            to handle exceptions, but <b>not</b> both.  Setting up both will cause
            the exception to be handled more than once which can result in undefined
            behavior.
            </remarks>
            <exception cref="T:TIBCO.EMS.IllegalStateException">If the connection is closed</exception>
        </member>
        <member name="M:TIBCO.EMS.Connection.CreateSession(System.Boolean,System.Int32)">
            <summary> Creates a Session object. </summary>
            <remarks ref="true()">
            The new session uses the connection for all server communications.
            </remarks>
            <param name="transacted">Indicates whether the session is transacted.
            <para>When true, the new session has transaction semantics.</para>
            <para>When false, it has non-transaction semantics.</para>
            </param>
            <param name="acknowledgeMode"><para>Indicates whether and how the consumer 
            is to acknowledge received messages. </para>
            <para>This version of CreateSession accepts an integer value associated with
            the acknowledge mode described by a <see cref="T:TIBCO.EMS.Session">Session</see> member
            and should only be used for backward compatibility.</para>
            <para>This parameter is ignored if the session is transacted. </para>
            </param>
            <returns>A newly created session. </returns>
        </member>
        <member name="M:TIBCO.EMS.Connection.CreateSession(System.Boolean,TIBCO.EMS.SessionMode)">
            <summary> Creates a Session object. </summary>
            <remarks ref="true()">
            The new session uses the connection for all server communications.
            </remarks>
            <param name="transacted">Indicates whether the session is transacted.
            <para>When true, the new session has transaction semantics.</para>
            <para>When false, it has non-transaction semantics.</para>
            </param>
            <param name="acknowledgeMode"><para>Indicates whether and how the consumer  
            is to acknowledge received messages. </para>
            <para>Legal values are listed under <see cref="T:TIBCO.EMS.SessionMode"> SessionMode</see>.
            </para>
            <para>This parameter is ignored if the session is transacted. </para>
            </param>
            <returns>A newly created session. </returns>
        </member>
        <member name="M:TIBCO.EMS.Connection.Start">
            <summary> Starts (or restarts) a connection's delivery of incoming messages.
            </summary>
            <remarks ref="true()">
            <para>When a connection is created, it is stopped. It does not deliver inbound messages 
            until the program calls this method to explicitly start it.
            </para>
            <para>If the connection has already been started and is not stopped, this call has no effect.
            </para>
            <para>Outbound messages flow even before calling Start.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Connection.Stop">
            <summary> Temporarily stops a connection's delivery of incoming messages. 
            </summary>
            <remarks ref="true()">
            <para>
            This call temporarily stops the connection from delivering inbound messages. 
            A program can restart delivery by calling <see cref="M:TIBCO.EMS.Connection.Start"/>.
            </para>
            <para>When a connection is created, it is stopped. It does not deliver inbound 
            messages until the program calls this method to explicitly start it.
            </para>
            <para>If the connection is already stopped, this call has no effect.
            </para>
            <para><b>Effect</b></para>
            <para>When this call returns, the connection has stopped delivery to all consumers 
            associated with the connection:
            </para>
            <list type="bullet">
            <item>Messages do not arrive to trigger asynchronous message handler events, nor message listeners.</item>
            <item>Synchronous receive methods block. If their timeout intervals expire, they return null. </item>
            </list>
            <para><b>Blocking</b></para>
            <para>If any message listener or receive call associated with the connection is processing 
            a message when the program calls this method, all facilities of the connection and 
            its sessions remain available to those listeners until they return. In the meantime, 
            this method blocks until that processing completes - that is, until all message listeners 
            and receive calls have returned.
            </para>
            <para>However, the stopped connection prevents the client program from processing any new messages.
            </para>
            <para><b>Sending</b></para>
            <para>A stopped connection can still send outbound messages.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Connection.Close">
            <summary> Closes the connection and reclaims resources. </summary>
            <remarks ref="true()">
            <para>Closing the connection causes all temporary destinations to be deleted; you need not 
            separately close the sessions, producers, and consumers associated with the connection.
            </para>
            <para>Closing a connection deletes all temporary destinations associated with the connection.
            </para>
            <para><b>Blocking</b></para>
            <para>If any message listener or receive call associated with the connection is processing 
            a message when the program calls this method, all facilities of the connection and 
            its sessions remain available to those listeners until they return. In the meantime, 
            this method blocks until that processing completes - that is, until all message listeners 
            and receive calls have returned.
            </para>
            <para><b>Acknowledge</b></para>
            <para>Closing a connection does not force acknowledgment in client-acknowledged sessions. 
            When the program still has a message that it received from a connection that has 
            since closed, its Message.Acknowledge method throws IllegalStateException.
            </para>
            <para><b>Transactions</b></para>
            <para>Closing a connection rolls back all open transactions in all sessions associated 
            with the connection. When an external transaction manager coordinates transactions, 
            it determines the final disposition of its open transactions.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Connection.ToString">
            <summary> A String representation of the conneciton object </summary>
            <returns> The String representation </returns>
        </member>
        <member name="M:TIBCO.EMS.Connection.IsDisconnected">
            <summary> Test whether a connection is permanently disconnected from the server.
            </summary>
            <remarks ref="true()">
            <para>When a connection is disconnected or is being disconnected from the server, 
            return true. Otherwise, return false.
            </para>
            </remarks>
        </member>
        <member name="T:TIBCO.EMS.ConnectionFactory">
            <summary>Administered object for creating server connections.</summary>
            <remarks ref="true()">
            <para>Connection factories are administered objects. They support concurrent use.
            </para>
            <para>Administrators define connection factories in a repository. Each connection 
            factory has administrative parameters that guide the creation of server connections. 
            Usage follows either of two models:
            </para>
            <para><b>EMS Server</b></para>
            <para>You can use the EMS server as a name service provider - one tibemsd process 
            provides both the name repository and the message service. Administrators 
            define factories in the name repository. Client programs create connection 
            factory objects with the URL of the repository, and call the <see cref="M:TIBCO.EMS.ConnectionFactory.CreateConnection"/>
            method. This method automatically accesses the corresponding factory in the 
            repository, and uses it to create a connection to the message service.
            </para>
            <para><b>Separate JNDI Repository</b></para>
            <para>Administrators define factories in a JNDI repository. Client programs call 
            <see cref="M:TIBCO.EMS.LookupContext.Lookup(System.String)">LookupContext.Lookup</see> to retrieve 
            factories and use them to create connections to the server.
            </para>
            <para><b>Administered Objects</b></para>
            <para>Administered objects let administrators configure EMS behavior at the 
            enterprise level. Administrators define these objects, and client programs use 
            them. This arrangement relieves program developers and end users of the 
            responsibility for correct configuration.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> ISerializable constructor </summary>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.CreateConnection">
            <summary> Create a connection </summary>
            <remarks ref="true()">
            The connection object presents 
            a default user identity. If the server configuration permits that user, 
            then the call succeeds.
            </remarks>
            <returns> The newly created <see cref="T:TIBCO.EMS.Connection">Connection</see>. 
            </returns>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.CreateConnection(System.String,System.String)">
            <summary> Create a connection object with the given user name and password.</summary>
            <remarks ref="true()"></remarks>
            <param name="userName">The connection object presents this user identity to the
            server. This parameter can be omitted if the server isn't authenticating or authorizing
            users.</param>
            <param name="password">The connection object authenticates the user identity with this
            password. This parameter can be omitted if the server isn't authenticating or
            authorizing users.</param>
            <returns> The newly created <see cref="T:TIBCO.EMS.Connection">Connection</see>. 
            </returns>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.#ctor">
            <summary>Construct an empty ConnectionFactory</summary>
            <remarks ref="true()"> 
            When administrators define factories in the EMS server, these constructors 
            automatically access the corresponding objects in the repository.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.#ctor(System.String)">
            <summary>Construct a ConnectionFactory given server url</summary>
            <remarks ref="true()"> 
            When administrators define factories in the EMS server, these constructors 
            automatically access the corresponding objects in the repository.
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The constructor contacts the EMS server at this URL, to
            access a factory. If connecting a fault-tolerant client, specify two or more
            comma-separated URLs, as described below in Reconnect and Fault Tolerance.</param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.#ctor(System.String,System.String)">
            <summary> Construct a ConnectionFactory given the server url, 
            and client id </summary>
            <remarks ref="true()"> 
            When administrators define factories in the EMS server, these constructors 
            automatically access the corresponding objects in the repository.
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The constructor contacts the EMS server at this URL, to
            access a factory. If connecting a fault-tolerant client, specify two or more
            comma-separated URLs, as described below in Reconnect and Fault Tolerance.</param>
            <param name="clientId">The id of the client.
            <para>A client ID string lets the server associate a client-specific factory 
            with each client program. When present, the server supplies that factory 
            to the client. If a factory does not yet exist for the client, the server 
            creates one, and stores it for future use by that specific client.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.#ctor(System.String,System.String,System.Collections.Hashtable)">
            <summary>Construct a ConnectionFactory given server url, client id 
            and properties</summary>
            <remarks ref="true()">  
            When administrators define factories in the EMS server, these constructors 
            automatically access the corresponding objects in the repository.
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The constructor contacts the EMS server at this URL, to
            access a factory. If connecting a fault-tolerant client, specify two or more
            comma-separated URLs, as described below in Reconnect and Fault Tolerance.</param>
            <param name="clientId">The id of the client.
            <para>A client ID string lets the server associate a client-specific factory 
            with each client program. When present, the server supplies that factory 
            to the client. If a factory does not yet exist for the client, the server 
            creates one, and stores it for future use by that specific client.
            </para>
            </param>
            <param name="properties">The properties of the client such as user 
            name and password.
            <para>When present, these properties govern the behavior of the connection 
            objects that a client-specific factory creates. For a list of properties, 
            see the Connection-Related Fields in the <see cref="T:TIBCO.EMS.Tibems">Tibems</see> members.
            </para></param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.Clone">
            <summary>Overrides the cloning process </summary>
            <returns>An object that is a clone of this <c>ConnectionFactory</c> object</returns>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetServerUrl(System.String)">
            <summary> set the server url.</summary>
            <remarks ref="true()">
            <para>The server URL is of the form:</para>
            <code>protocol://hostName:portNumber</code>
            <para>For example: </para>
            <code>tcp://localhost:7222</code>
            <para>The server URL for a fault-tolerant configuration is a string 
            with multiple URL's that are comma separated. </para>
            <para>For example: </para>
            <code>tcp://localhost:7222,tcp://localhost:7224</code>
            </remarks>
            <param name="serverUrl">The constructor contacts the EMS server at this URL, to
            access a factory. If connecting a fault-tolerant client, specify two or more
            comma-separated URLs, as described below in Reconnect and Fault Tolerance.</param>
            <exception cref="T:TIBCO.EMS.EMSException">Url is already set or some other 
            error. </exception>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetClientID(System.String)">
            <summary> Set the client id </summary>
            <param name="clientID">The client id </param>
            <exception cref="T:TIBCO.EMS.EMSException"> The specified client id already exists</exception>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetMetric(System.Int32)">
            <summary> Set the load balance metric
            </summary>
            <param name="metric"> The load balance metric </param>
            <exception cref="T:TIBCO.EMS.EMSException"> Invalid metric </exception>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetConnAttemptCount(System.Int32)">
            <summary> Set the number of connection attempts</summary>
            <remarks ref="true()"></remarks>
            <param name="attempts"> The number of connection attempts </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetConnAttemptDelay(System.Int32)">
            <summary> Set delay between connection attempts
            </summary>
            <remarks ref="true()"></remarks>
            <param name="delay"> Time (in milliseconds) of the delay between connection attempts. </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetReconnAttemptCount(System.Int32)">
            <summary> Set number of reconnect attempts
            </summary>
            <remarks ref="true()"></remarks>
            <param name="attempts"> The number of connection attempts </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetReconnAttemptDelay(System.Int32)">
            <summary> Set delay between reconnect attempts
            </summary>
            <remarks ref="true()"></remarks>
            <param name="delay"> Time (in milliseconds) of the delay between reconnect attempts </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetUserName(System.String)">
            <summary> Set user name
            </summary>
            <param name="username"> User name </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetUserPassword(System.String)">
            <summary> Set user password
            </summary>
            <param name="password"> User password </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetConnAttemptTimeout(System.Int32)">
            <summary>Set the Connect Attempt timeout for a given connection.</summary>
            <remarks ref="true()"> 
            <para>This timeout is per url and per connect_attempt.
            For example, to specify two connect attempts for a given url, then 
            for each attempt the client will wait for the period specified by the 
            connect attempt timeout for the connection to be established. If no 
            connection is established within that the specified timeframe, the client 
            connection attempt is terminated. </para>
            </remarks>
            <param name="timeout">The timeout, in milliseconds.  The
            minimum value is 100 milliseconds. If a value of less than 100 
            milliseconds is specified, then the minimum value of 100 milliseconds 
            is used. </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetReconnAttemptTimeout(System.Int32)">
            <summary>
            Set the Reconnect Attempt timeout for a given connection.</summary>
            <remarks ref="true()">
            This timeout is per url and per reconnect_attempt. For example, to specify two 
            reconnect attempts for a given url, then for each attempt the client will 
            wait for the period specified by the reconnect attempt timeout for the 
            connection to be established. If no reconnection is established within 
            that the specified timeframe, the reconnection attempt is terminated. 
            </remarks>
            <param name="timeout">The timeout, in milliseconds.  The
            minimum value is 100 milliseconds. If a value of less than 100 
            milliseconds is specified, then the minimum value of 100 milliseconds 
            is used. </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetMulticastEnabled(System.Boolean)">
            <summary>
            Set whether MessageConsumers subscribed to a multicast-enabled topic
            will receive messages over multicast.</summary>
            <remarks ref="true()">
            When enabled, MessageConsumers subscribed to a multicast-enabled topic
            will receive messages over multicast. The default is enabled.
            </remarks>
            <param name="enabled">true to enable multicast, false to disable 
            multicast.</param>
            \deprecated As of release 8.3.
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetMulticastDaemon(System.String)">
            <summary>
            Set the port on which the client will connect to the multicast
            daemon.</summary>
            <remarks ref="true()">
            A connection to the multicast daemon is required when multicast is
            enabled and a MessageConsumer is subscribed to a multicast-enabled
            topic. Setting the port with this method will override the default
            port supplied by the server.
            </remarks>
            <param name="port">the port on which the client will connect to the
            multicast daemon.</param>
            \deprecated As of release 8.3.
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetSSLTrace(System.Boolean)">
            <summary> Enable or disable tracing on the client side.</summary>
            <remarks>Tracing will show information during the SSL handshake 
            and on messages received and sent by the SSL link.</remarks>
            <param name="trace"> Flag to indicate whether tracing should be
            enabled for all connection created via this connection factory.
            <list type="bullet">
            <item>When true, tracing is enabled.</item>
            <item>When false, (the default) tracing is disabled.</item>
            </list>
            </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetSSLAuthOnly(System.Boolean)">
            <summary> Enable or disable encryption/decryption of the message data over 
            the SSL connection  </summary>
            <remarks ref="true()">
            For the client and server to require an SSL connection only to perform 
            authentication, the ssl_auth_only parameter needs to be set on the server 
            and AUTH_ONLY needs to be set by the client. Setting these flags on both 
            the server and client side indicates that the SSL connection is only used 
            to only perform authentication. Once authentication is complete, the client 
            switches to a regular TCP connection to communicate with the server.
            </remarks>
            <param name="authOnly"> Flag to indicate whether the connection
            should only authenticate. 
            <list type="bullet">
            <item>When true, only the authentication to connect is performed and data 
            sent over the connection is not encrypted or decrypted.</item>
            <item> When false (the default), authentication to is performed and data 
            sent over the connection is encrypted and decrypted.</item>
            </list>
            </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetTargetHostName(System.String)">
            <summary> Set the name of the target EMS server.</summary>
            <remarks>
            This is a required parameter for all .NET SSL connections.
            Because System.Net.Security.SslStream requires a targetHost, 
            this value is required and cannot be NULL.
            </remarks>
            <param name="targetHostName"> The name of the server as defined in the
            server's certificate. Usually the server's HostName is specified as the
            CN in the server's certificate.
            </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetCertificateStoreType(TIBCO.EMS.EMSSSLStoreType,System.Object)">
            <summary> Set the certificate store type and info. </summary>
            <param name="type">The type of certificate store. Can be either 
            EMSSSL_STORE_TYPE_SYSTEM or EMSSSL_STORE_TYPE_FILE.  See
            <see cref="T:TIBCO.EMS.EMSSSLStoreType">EMSSSLStoreType</see> for details. </param>
            <param name="storeInfo">If the store type is EMSSSL_STORE_TYPE_SYSTEM, 
            then storeInfo must be an EMSSSLSystemStoreInfo object. If the store 
            type is EMSSSL_STORE_TYPE_FILE, then storeInfo must be an 
            <see cref="T:TIBCO.EMS.EMSSSLFileStoreInfo">EMSSSLFileStoreInfo</see> 
            object.</param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.GetCertificateStore">
            <summary> Get the certificate store info object associated with this 
            connection factory.
            </summary>
            <remarks> can be null or of type EMSSSLFileStoreInfo or 
            EMSSSLSystemStoreInfo. 
            NOTE: SSL Connection factory objects that are
            looked up in JNDI have a certificate store info already created.
            This allows a user to get access to the certificate store object
            and set properties not present in the JNDI object. e.g. ssl password.
            </remarks>
            <example>
            <code>
              EMSSSLFileStoreInfo info = (EMSSSLFileStoreInfo)cf.GetCertificateStore();
              String _password        = "password";
              info.SetSSLPassword(_password.ToCharArray());
            </code>
            </example>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetHostNameVerifier(TIBCO.EMS.EMSSSLHostNameVerifier)">
            <summary> Set the custom host name verifier. Set to null to 
            remove custom host name verifier.
            </summary>
            <param name="verifier">Host name verifier. Set to null to remove custom 
            host name verifier. See <see cref="T:TIBCO.EMS.EMSSSLHostNameVerifier">EMSSSLHostNameVerifier</see> 
            for details.
            </param>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetClientTracer(System.IO.StreamWriter)">
            <summary> Set client tracer to given output stream. </summary>
            <remarks>Client tracing prints loaded certificates and information 
            about the SSL handshake errors and results.
            </remarks>
            <param name="tracer">The output stream to send the tracing information. 
            Specify null as parameter to disable client tracing. </param>
            
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetSSLProxy(System.String,System.Int32)">
            <summary>
            Set the connection factory's parameters for connecting through an SSL
            proxy.
            </summary>
            <remarks>
            An SSL proxy lets an EMS application create an SSL connection to an EMS
            server, even though a firewall separates the application from the server.
            The proxy usually runs within the firewall's DMZ. A connection factory
            contacts the SSL proxy, requesting an SSL connection to the server. The
            proxy authenticates the application program, and mediates the initial
            SSL negotiation between application and server. After the SSL connection
            is established, the application and server use it to communicate
            directly with one another.
            </remarks>
            <param name="host"> The connection factory establishes SSL communication
            through a web proxy at this host. Supply a simple hostname, a 
            fully qualified hostname with domain name, or an IP address 
            (dot notation). 
            </param>
            <param name="port"> The connection factory establishes SSL communication
            through a web proxy on this port. </param>
            <exception cref="T:TIBCO.EMS.EMSException"> if the proxy host is null or empty,
            the port is zero or the protocol of the connection factory's URL is
            not SSL.
            </exception>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.SetSSLProxyAuth(System.String,System.String)">
            <summary>
            Set a connection factory's username and password for connecting through
            an SSL proxy.
            </summary>
            <remarks>
            <para>When a connection factory establishes an EMS server connection through 
            an SSL proxy host, the proxy might first require authentication before
            facilitating a connection. When required, use this call to set that
            authentication data on the connection factory. 
            </para>
            <b>Note: </b>
            This proxy authentication data is distinct from the server authentication data 
            and from the SSL private key encryption password.
            </remarks>
            <param name="username"> The connection factory authenticates itself 
            to the SSL proxy using this username. </param>
            <param name="password"> The connection factory authenticates itself 
            to the SSL proxy using this password. </param>
            <exception cref="T:TIBCO.EMS.EMSException"> if the protocol of the connection 
            factory's URL is not SSL.
            </exception>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.GetSSLProxyHost">
            <summary>
            Get the SSL proxy host from this connection factory.
            </summary>
            <returns>return the host</returns>
            <exception cref="T:TIBCO.EMS.EMSException"> if the protocol of the connection 
            factory's URL is not SSL.</exception>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.GetSSLProxyPort">
            <summary>
            Get the SSL proxy port from this connection factory.
            </summary>
            <returns> the port. </returns>
            <exception cref="T:TIBCO.EMS.EMSException"> if the protocol of the connection 
            factory's URL is not SSL.
            </exception>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.GetSSLProxyUser">
            <summary>
            Get the SSL proxy username from a connection factory.
            </summary>
            <returns> the username. </returns>
            <exception cref="T:TIBCO.EMS.EMSException"> if the protocol of the connection 
            factory's URL is not SSL.
            </exception>
        </member>
        <member name="M:TIBCO.EMS.ConnectionFactory.GetSSLProxyPassword">
            <summary>
            Get the SSL proxy password from a connection factory.
            </summary>
            <returns> the password. </returns>
            <exception cref="T:TIBCO.EMS.EMSException"> if the protocol of the connection 
            factory's URL is not SSL.
            </exception>
        </member>
        <member name="T:TIBCO.EMS.ConnectionMetaData">
            <summary>A ConnectionMetaData object provides information describing the Connection object.</summary>
            <remarks>Programs can retrieve this object from a connection; see 
            <see cref="P:TIBCO.EMS.Connection.MetaData">MetaData</see>.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.ConnectionMetaData.#cctor">
            <summary>static initialization of the class </summary>
        </member>
        <member name="P:TIBCO.EMS.ConnectionMetaData.Version">
            <summary> Gets version number of the JMS specification supported by the provider.</summary>
            <remarks ref="true()"></remarks>
            <returns> Version number of the JMS specification </returns>
        </member>
        <member name="P:TIBCO.EMS.ConnectionMetaData.MajorVersion">
            <summary> Gets the major version number of the JMS specification supported 
            by the provider. </summary>
            <remarks ref="true()"></remarks>
            <returns> The major version number of the JMS specification </returns>
        </member>
        <member name="P:TIBCO.EMS.ConnectionMetaData.MinorVersion">
            <summary> Gets the minor version number of the JMS specification supported 
            by the provider. </summary>
            <remarks ref="true()"></remarks>
            <returns> The minor version number of the JMS specification </returns>
        </member>
        <member name="P:TIBCO.EMS.ConnectionMetaData.ProviderName">
            <summary> Gets the provider name </summary>
            <remarks ref="true()"></remarks>
            <returns> Vendor name of the provoder. </returns>
        </member>
        <member name="P:TIBCO.EMS.ConnectionMetaData.ProviderVersion">
            <summary> Gets the provider version number</summary>
            <remarks ref="true()"></remarks>
            <returns> The version number of the provider (EMS). </returns>
        </member>
        <member name="P:TIBCO.EMS.ConnectionMetaData.ProviderMajorVersion">
            <summary> Gets the provider major version number</summary>
            <returns> The major version number of the provider (EMS). </returns>
        </member>
        <member name="P:TIBCO.EMS.ConnectionMetaData.ProviderMinorVersion">
            <summary> Gets the provider minor version number</summary>
            <remarks ref="true()"></remarks>
            <returns> The minor version number of the provider (EMS). </returns>
        </member>
        <member name="P:TIBCO.EMS.ConnectionMetaData.JMSXPropertyNames">
            <summary> Gets the JMX property names </summary>
            <remarks ref="true()">
            <para>Enumerates the JMX message properties.</para>
            </remarks>
            <returns> the JMX property names </returns>
        </member>
        <member name="T:TIBCO.EMS.Destination">
            <summary>A Destination object encapsulates a TIBCO EMS specific address.</summary>
            <remarks ref="true()">
            <para>
            Administrators define destinations in the server. Client programs access them 
            using methods of LookupContext.</para>
            <para>The Destination class defines the root behavior of all destinations.
            Programs do not create instances of this class; instead, they 
            create instances of its subclasses.</para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Destination.#ctor">
            <summary>Construct a empty desination </summary>
        </member>
        <member name="M:TIBCO.EMS.Destination.#ctor(System.String)">
             <summary>Construct a destination given its address </summary>
             <param name="address">The queue or topic name as address </param>
        </member>
        <member name="M:TIBCO.EMS.Destination.#ctor(System.String,System.String)">
            <summary> internal constructor </summary>
        </member>
        <member name="M:TIBCO.EMS.Destination.Clone">
            <summary>Creates a copy of the Destination object. </summary>
        </member>
        <member name="P:TIBCO.EMS.Destination.Address">
            <summary>Gets the name of the destination </summary>
            <value>Topic or queue name </value>
        </member>
        <member name="M:TIBCO.EMS.Destination.ToString">
            <summary> Returns a string representation of the destination. </summary>
            <returns> A string representation of the destination. </returns>
        </member>
        <member name="M:TIBCO.EMS.Destination.Equals(System.Object)">
            <summary> Compare with another object for equality. </summary>
            <remarks> The current instance is said to be equals to another
            object when the latter is also a <c>Destination</c> instance and
            both have the same address. </remarks>
            <param name="obj">The object to compare with </param>
            <returns>true if the object passed is also of type <c>Destination</c> and
            has the same address as the current instance, false otherwise.
            </returns>
        </member>
        <member name="M:TIBCO.EMS.Destination.GetHashCode">
            <summary>
            Returns a hashcode representing the current object
            </summary>
            <returns>A hashcode based on <c>Destination</c>'s address.
            </returns>
        </member>
        <member name="T:TIBCO.EMS.DPQMember">
            <summary>Internal use.  </summary>
        </member>
        <member name="T:TIBCO.EMS.EMSDTCConnection">
            <summary> A Connection object is a client's active connection to TIBCO 
            EMS Server. A EMSDTCConnection should be used when the client intends 
            to participate in a MSDTC transaction (i.e. System.Transactions.Transaction)
            </summary>
            <remarks ref="true()">
            <para> Connections support concurrent use. 
            </para>
            <para>A connection serves several purposes: 
            <list type="bullet">
            <item>It encapsulates an open connection with a TIBCO EMS Server. 
            It typically represents an open TCP/IP socket between a client 
            and the TIBCO EMS Server. </item>
            <item> Its creation is where client authentication takes place. </item>
            <item> It can specify a unique client identifier. </item>
            <item> It provides a <see cref="T:TIBCO.EMS.ConnectionMetaData">ConnectionMetaData</see> object. </item>
            <item> It supports an optional <see cref="P:TIBCO.EMS.Connection.ExceptionListener">ExceptionListener</see> 
            object. </item>
            </list>
            </para>
            <para> Because the creation of a connection involves setting up 
            authentication and communication, a connection is a relatively 
            heavyweight object. Most clients will do all their messaging with 
            a single connection. Other more advanced applications may use 
            several connections. 
            </para>
            <para>A client typically creates a connection, one or more sessions,
            and a number of message producers and consumers. When a connection 
            is created, it is in stopped mode. That means that no messages are
            being delivered. 
            </para>
            <para> It is typical to leave the connection in stopped mode until setup
            is complete and all message consumers have been created. 
            At that point, the client calls the connection's 
            <see cref="M:TIBCO.EMS.Connection.Start">Start</see> method, 
            and messages begin arriving at the connection's consumers. 
            (Outbound messages flow even before calling Start.)
            This setup convention minimizes any client confusion that may result 
            from asynchronous message delivery while the client is still in the 
            process of setting itself up. 
            </para>
            <para> A connection can be started immediately and the setup can be 
            done afterwards. Clients that do this must be prepared to handle 
            asynchronous message delivery while they are still in the process 
            of setting up. 
            </para>
            <para> A message producer can send messages while a connection 
            is stopped </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.EMSDTCConnection.CreateEMSDTCSession">
            <summary>
            Returns an EMSMSDTCSession. Only EMSDTCSession's will be allowed to 
            participate in MSDTC distributed transactions.
            </summary>
            <returns> An EMSDTCSession </returns>
            <remarks>
            <para>
            The presence of an ambient transaction will cause the session to be
            automatically enlisted with Microsoft DTC when the session's
            producer produces or consumer consumes the first message 
            within a transaction scope.
            </para>
            <para>
            Before producing or consuming messages (from producers/consumers
            created off this EMSDTCSession) one has to make sure that
            there is already an ambient transaction started.
            Please see System.Transactions.TransactionScope or 
            System.Transactions.CommittableTransaction on how to start a 
            an ambient transaction.
            </para>
              <code>
                Example:
                EMSDTCConnectionFactory fc = new EMSDTCConnectionFactory("tcp://localhost:7222");
                fc.ClientId                = "test-clientId";
                EMSDTConnection dtcConn    = fc.CreateEMSDTCConnection();
                EMSDTCSession   dtcSess    = dtcConn.CreateEMSDTCSession();
               </code>
            </remarks>
        </member>
        <member name="T:TIBCO.EMS.EMSDTCConnectionFactory">
             <summary>
             Connection factory class for creating EMSDTCConnections and subsequently
             EMSMSDTCSessions for participating in MSDTC distributed transactions.
             </summary>
             <remarks>
             <para>
             
             An EMSDTCConnectionFactory differs from the regular ConnectionFactory
             in that it supports the creation of EMSDTCConnections. EMSDTCConnections
             can then be used to create EMSDTCSessions and only producers/consumers
             created on the EMSDTCSessions are allowed to participate in 
             MSDTC Transactions.
             Regular Connections, Sessions and producers/consumers created off these
             regular sessions cannot participate in MSDTC Transactions.
            
             </para>
             </remarks>
        </member>
        <member name="M:TIBCO.EMS.EMSDTCConnectionFactory.CreateEMSDTCConnection">
            <summary> Create a EMSDTCconnection </summary>
            <remarks>
            The connection object presents a default user identity. 
            If the server configuration permits that user, then the call succeeds.
            <para>
            <b>Note: </b>Before creating an EMSDTCConnection, the clientId has to be set
            for the connection factory or else an exception is thrown to indicate
            the absence of clientId.
            </para>
            </remarks>
            <returns> The newly created <see cref="T:TIBCO.EMS.EMSDTCConnection">EMSDTCConnection</see>. 
            </returns>
            <exception cref="T:TIBCO.EMS.EMSException"> If the cilentID is null or some other
            internal error</exception>
        </member>
        <member name="M:TIBCO.EMS.EMSDTCConnectionFactory.CreateEMSDTCConnection(System.String,System.String)">
            <summary> Create a EMSDTCConnection </summary>
            <remarks ref="true()">
            The connection object presents 
            a default user identity. If the server configuration permits that user, 
            then the call succeeds.
            <para>
            <b>Note: </b>Before creating an EMSDTCConnection, the clientId has to be set
            for the connection factory or else an exception is thrown to indicate
            the absence of clientId.
            </para>
            </remarks>
            <returns> The newly created <see cref="T:TIBCO.EMS.EMSDTCConnection">EMSDTCConnection</see>. 
            </returns>
            <exception cref="T:TIBCO.EMS.EMSException"> If the cilentID is null or some other
            internal error</exception>
        </member>
        <member name="M:TIBCO.EMS.EMSDTCConnectionFactory.#ctor">
            <summary>Construct an empty EMSDTCConnectionFactory</summary>
            <remarks ref="true()"> 
            When administrators define factories in the EMS server, these constructors 
            automatically access the corresponding objects in the repository.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.EMSDTCConnectionFactory.#ctor(System.String)">
            <summary>Construct a EMSDTCConnectionFactory given server url</summary>
            <remarks ref="true()"> 
            When administrators define factories in the EMS server, these constructors 
            automatically access the corresponding objects in the repository.
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The constructor contacts the EMS server at this URL, to
            access a factory. If connecting a fault-tolerant client, specify two or more
            comma-separated URLs, as described below in Reconnect and Fault Tolerance.</param>
        </member>
        <member name="M:TIBCO.EMS.EMSDTCConnectionFactory.#ctor(System.String,System.String)">
            <summary> Construct a EMSDTCConnectionFactory given the server url, 
            and client id </summary>
            <remarks ref="true()"> 
            When administrators define factories in the EMS server, these constructors 
            automatically access the corresponding objects in the repository.
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The constructor contacts the EMS server at this URL, to
            access a factory. If connecting a fault-tolerant client, specify two or more
            comma-separated URLs, as described below in Reconnect and Fault Tolerance.</param>
            <param name="clientId">The id of the client.
            <para>A client ID string lets the server associate a client-specific factory 
            with each client program. When present, the server supplies that factory 
            to the client. If a factory does not yet exist for the client, the server 
            creates one, and stores it for future use by that specific client.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.EMSDTCConnectionFactory.#ctor(System.String,System.String,System.Collections.Hashtable)">
            <summary>Construct a EMSDTCConnectionFactory given server url, client id 
            and properties</summary>
            <remarks ref="true()">  
            When administrators define factories in the EMS server, these constructors 
            automatically access the corresponding objects in the repository.
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The constructor contacts the EMS server at this URL, to
            access a factory. If connecting a fault-tolerant client, specify two or more
            comma-separated URLs, as described below in Reconnect and Fault Tolerance.</param>
            <param name="clientId">The id of the client.
            <para>A client ID string lets the server associate a client-specific factory 
            with each client program. When present, the server supplies that factory 
            to the client. If a factory does not yet exist for the client, the server 
            creates one, and stores it for future use by that specific client.
            </para>
            </param>
            <param name="properties">The properties of the client such as user 
            name and password.
            <para>When present, these properties govern the behavior of the connection 
            objects that a client-specific factory creates. For a list of properties, 
            see the Connection-Related Fields in the <see cref="T:TIBCO.EMS.Tibems">Tibems</see> members.
            </para></param>
        </member>
        <member name="M:TIBCO.EMS.EMSDTCConnectionFactory.Clone">
            <summary>Overrides the cloning process </summary>
            <returns>An object that is a clone of this <c>EMSDTCConnectionFactory</c> object</returns>
        </member>
        <member name="T:TIBCO.EMS.EMSDTCResource">
            <summary>  This class implements the EMSDTCResource interface for use with an XASession.
            
            </summary>
        </member>
        <member name="T:TIBCO.EMS.EMSDTCSession">
             <summary>
             The EMSDTCSession class represents a session of the client 
             within the server. Only EMSDTCSession's are allowed to participate
             in MSDTC distributed transactions. 
            
             </summary>
             <remarks>
             EMSDTCSession is a single-threaded context for producing and consuming 
             messages. Typically applications create EMSDTCSessions and then producers 
             and consumers on the EMSDTCSession. Message Producers and consumers that
             are then created within this session can produce and consume as long
             as they are done within an ambient transaction (Created via the
             System.Transactions.TransactionScope or 
             System.Transactions.CommittableTransaction).
             
             <para>
             <para><b>General:</b></para>
             When a message producer publishes its first message as part
             of a distributed transaction (started via the TransactionSope
             of via the CommittableTransaction) or a consumer consumes its first 
             message as part of a distributed transaction. 
             The EMS .NET client library registers an EnlistmentNotification 
             object with MSDTC for this session. When the producer or the consumer is 
             done with its unit of work, it commits the distributed transaction.
             The act of commiting this distributed transaction will then result in 
             Microsoft DTC calling back ino the EnlistmentNotification object
             to complete the transaction. On a successful commit or rollback of the
             distributed transaction, the session is now free to have more work
             done in another transaction.
            
             </para>
            
             <para>
             <para><b>Recovery:</b></para>
             If during the transaction commit process, the resource manager fails
             (i.e after a successful prepare, but before the Microsoft DTC had the
             chance to commit the transaction) then the client will have to close
             the connection and create it again in order for the prepared transactions
             to be completed (that happens internally via a re-enlistment processs 
             and the MSDTC either issuing a commit or a rollback based on other
             participants in the distributed transaction).
             For more information on the re-enlistment process please see the 
             documentation on System.Transactions.TransactionManager.Reenlist.
             </para>
            
            
             <para>
             <para><b>Exceptions:</b></para>
             <para>Following will result in IllegalStateException:</para>
             </para>
             <list type="bullet">
             <item> It's Illegal to NOT have an ambient transaction and produce or 
             consume messages via message producers and message consumers created on 
             an EMSDTCSession</item> 
             <item> It's Illegal to call commit/rollback on an EMSDTCSession </item>
             <item> It's Illegal to have nested transactions that are using
             a session and the session is already part of another ambient transaction. 
             </item>
             <item> It's Illegal to create asynchronous message consumers on 
             EMSDTCSession's. An IllegalStateException is thrown when MessageListener
             is being set.</item>
             </list>
             <para>A typical application produces or consumes messages as part of a
             transaction scope. In the example below, If the producer's 
             EMSDTCSession is not already enlisted for the current ambient transaction, 
             the first publish will result in an automatic enlistment.</para>
            
             <para><b>Example:</b></para>
             <code>
                 EMSDTCConnectionFactory fc = new EMSDTCConnectionFactory("tcp://localhost:7222");
                 fc.ClientID                = "test-clientId";
                 EMSDTConnection dtcConn    = fc.CreateEMSDTCConnection();
                 EMSDTCSession   dtcSess    = dtcConn.CreateEMSDTCSession();
                 Queue           queue      = dtcSess.CreteQueue("queue.sample");
                 MessageProducer prod       = dtcSess.CreateProducer(dest);
            
                 using(TransactionScope scope = new TransactionScope(TransactionScopeOption.RequiresNew))
                 {
                     // publish couple of msgs to a queue on this EMS server.
            
                     TextMessage msg = dtcSess.CreateTextMessage("hello world: 1");
                     prod.Publish(msg);
            
                     TextMessage msg2 = dtcSess.CreateTextMessage("hello world: 2");
                     prod.Publish(msg2);
            
                     // do work on another Resource Manager.
             
                     scope.Complete();
                 }
             </code>
             </remarks>
        </member>
        <member name="M:TIBCO.EMS.EMSDTCSession.GetSession">
            <summary>
            Returns this session, that would allow to create producers and 
            consumers
            </summary>
        </member>
        <member name="M:TIBCO.EMS.EMSDTCSession.Commit">
            <summary>
            Not valid for EMSDTCSession, throws InvalidOperationException
            </summary>
        </member>
        <member name="M:TIBCO.EMS.EMSDTCSession.Rollback">
            <summary>
            Not valid for EMSDTCSession, throws InvalidOperationException
            </summary>
        </member>
        <member name="T:TIBCO.EMS.EMSException">
            <summary>This is base class for TIBCO EMS .NET API related exceptions </summary>
            <remarks>This class corresponds to JMSException in JMS. 
            EMS methods throw instances of this class and its subclasses.</remarks>
        </member>
        <member name="M:TIBCO.EMS.EMSException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the EMSException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.EMSException.#ctor(System.String)">
            <summary> Initializes a new instance of the EMSException
            with the specified reason.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.EMSException.#ctor(System.String,System.Int32)">
            <summary> Initializes a new instance of the EMSException
            with the specified reason and error number
            </summary>
        </member>
        <member name="P:TIBCO.EMS.EMSException.ErrorCode">
            <summary> Gets the error code associated with this exception </summary>
            <remarks>When an exception results from a server error, this property 
            holds the server's error code.</remarks>
            <returns> a string specifying the vendor-specific error code </returns>
        </member>
        <member name="P:TIBCO.EMS.EMSException.LinkedException">
            <summary> Get and Set the exception linked to this one </summary>
            <remarks>When an EMS exception results from a deeper problem, 
            this linked exception details that problem.</remarks>
        </member>
        <member name="T:TIBCO.EMS.SecurityException">
            <summary>The method cannot complete because of a security restriction</summary>
            <remarks>
            This exception is thrown when a TIBCO EMS Server rejects a 
            user name/password submitted by a client. It may also be thrown 
            for any case where a security restriction prevents a method from completing.
            <para>For example, the provider rejects a user or the user's authentication.</para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.SecurityException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the SecurityException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.SecurityException.#ctor(System.String)">
            <summary> Initializes a new instance of the SecurityException
            with the specified reason.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.EMSSSL">
             <summary> SSL specific class that provides methods, defines
             and other miscellaneous constants that are used to set ssl
             parameters that apply across all connections.
             </summary>
             <remarks ref="true()">
             <para>
             Normally a client application obtains SSL setup as a part of the
             <see cref="T:TIBCO.EMS.ConnectionFactory">ConnectionFactory</see>
              definition. ConnectionFactory is usually obtained
             by the client applications via JNDI lookup calls.
             However, in some cases it may be more convenient or required to define
             SSL parameters locally in the client rather than as a result of JNDI lookup
             operation. This may be necessary, for example, due to security considerations
             when JNDI lookup operation can not be performed securely over SSL protocol.
             Also sometimes it may be required or convenient to set ssl parameters
             globally that apply to all the connections. This class enables such
             requirements.
             </para>
             <para>
             A EMS client is communicating with the server via SSL protocol when the server
             URL provided to the ConnectionFactory is specified in the form
             <b>ssl://host:port</b>.
             </para>
             <para>
             When the connection between the client and the server is an SSL connection,
             the server and the client application must set parameters in order for the
             SSL handshake to be successful. The server parameters are set by the administrator.
             Each client application is responsible for setting SSL parameters correctly
             in order to be able to establish SSL connection to the server. 
             </para>
             <para> <b>
             Setting up SSL parameters by the client can be done in one of three ways:
             </b></para>
             <ul>
               <li> All SSL parameters are specified in the ConnectionFactory, that factory
               is obtained by the client via a JNDI lookup call. Notice this does not address
               an issue of making JNDI lookup calls over SSL connection.
               </li>
               <li>SSL parameters are set globally via calls to this class. When a ConnectionFactory
               is using a URL specifying 'ssl' protocol but does not specify any other SSL parameters,
               the SSL parameters set via calls to the methods of this class will be used.
               </li>
               <li> A client application can create a Map of SSL parameters and pass it directly
               into constructor of 
             <see cref="T:TIBCO.EMS.TopicConnectionFactory">TopicConnectionFactory</see> or 
             <see cref="T:TIBCO.EMS.QueueConnectionFactory">QueueConnectionFactory</see>.
               </li>
             </ul>
             
             <para><b>SSL Parameters.</b></para>
             <para>
             A client has to choose the certificate store it is going to
             work with before setting the SSL parameters. EMS .NET client supports
             two different certificate stores and each store has different API
             please see <see cref="T:TIBCO.EMS.EMSSSLFileStoreInfo"/> and 
             <see cref="T:TIBCO.EMS.EMSSSLSystemStoreInfo"/> for more information on the 
             certificate store specific API's.
            
             </para>
             
             <para><b>Cipher Suites.</b></para>
             <para> Since the .NET framework does not allow to specify the 
             ciphers from the client side, The EMS .NET api also does not have
             any provision of specifiying the ciphers. 
             </para>
            
             <para><b>General Setup</b> </para>
             <para>
             When a EMS .NET client establishes an SSL connection to the EMS server, it
             should at the very least specify the <see cref="F:TIBCO.EMS.EMSSSL.TARGET_HOST_NAME"/> parameter, this is
             a required parameter for the SSLStream.
             A client then has to specify one of the certificate store types: 
             <see cref="F:TIBCO.EMS.EMSSSLStoreType.EMSSSL_STORE_TYPE_FILE"/> or 
             <see cref="F:TIBCO.EMS.EMSSSLStoreType.EMSSSL_STORE_TYPE_SYSTEM"/> along with
             the <see cref="F:TIBCO.EMS.EMSSSL.STORE_INFO"/> object. The Store info has all the required information:
             </para>
             <list type="bullet">
             <item>In case of the system store, the store info has information about the
             location of the store, the store name and the certificate name to look 
             for in the store.</item>
             <item>In case of the file store, the store info has information about the
             the client identity, the password for the private key and any optional
             trusted certs.</item>
             </list>
             <para>The client can set the host name verifier callback that will be called
             during the SSL handshake, the client can perform any specific validations
             in the host name verifier callback, returning false from this
             callback will cause the SSL handshake to terminate, return true will
             cause the SSL handshake to proceed.</para>
             <para>
             If the client is interested in authentication only, then it needs 
             call <see cref="M:TIBCO.EMS.EMSSSL.SetAuthOnly(System.Boolean)"/> with a true flag. Normal behavior
             is to perform authentication and then any data that is sent/received
             encrypted/decrypted. Setting auth only to true will on both
             the client and the server will cause the client to perform
             authentication only and switch over to tcp connection for better 
             performance at the expense of data security.
             </para>
             </remarks>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.TRACE">
            <summary>Name of SSL property specifying if client trace is required.
            The value is a Boolean object.
            This name is defined as "TIBCO.EMS.ssl.trace".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.CLIENT_TRACER">
            <summary>Name of SSL property specifying the client tracer object
            The is a valid tracer object
            This name is defined as "TIBCO.EMS.ssl.client_trace".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.AUTH_ONLY">
            <summary>Name of SSL property specifying if SSL is used for authentication only.
            The value is a Boolean object.
            This name is defined as "TIBCO.EMS.ssl.auth_only".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.TRUSTED_CERTIFICATES">
            <summary>Name of SSL property specifying the set of trusted certificates.
            The value is a Vector object, elements of the Vector can be:
            - certificate object,
            - an Integer object specifying the certificate type followed by
            the certificate object.
            An Integer object before the object presenting the certificate data
            may be required when certificate data does not allow automatic
            detection of the encoding format.
            This name is defined as "TIBCO.EMS.ssl.trusted_certs".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.TARGET_HOST_NAME">
            <summary>
            If server certificate has different name then SSL handshake fails.
            The value is a String object.
            This name is defined as "TIBCO.EMS.ssl.target_host_name".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.HOST_NAME_VERIFIER">
            <summary>Name of SSL property specifying the custom host name verifier. Notice when
            this property is specified, the Map of parameters can not be stored in JNDI.
            The value is a EMSSSLHostNameVerifier object.
            This name is defined as "TIBCO.EMS.ssl.hostname_verifier".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.IDENTITY">
            <summary>Name of SSL property specifying the client-side identity. An identity usually
            consists of the certificate, corresponding private key and optionally a
            set of issuer certificates. The value specified by this property can be a
            certificate, a PKCS12 file or a KeyStore object. The last two
            object types normally include all elements of the identity into
            a single storage. In this case only PASSWORD property should be specified
            as the password required to decrypt the content of the specified identity
            data. If this property specifies the certificate file then PRIVATE_KEY
            must be also set and optionally ISSUER_CERTIFICATES.
            This name is defined as "TIBCO.EMS.ssl.identity".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.PASSWORD">
            <summary>Name of SSL property specifying the password for the private key
            or the identity store. This name is defined as "TIBCO.EMS.ssl.password".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.CERT_NAME">
            <summary>Name of the certificate
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.STORE_TYPE">
            <summary> SSL Store type </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.STORE_INFO">
            <summary> SSL Store Info </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.ENCODING_AUTO">
            <summary>Integer defining AUTO format of the certificate or private
            key data.</summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.ENCODING_PEM">
            <summary>Integer defining PEM format of the certificate or private 
            key data.</summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.ENCODING_DER">
            <summary>Integer defining DER format of the certificate or private 
            key data.</summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.ENCODING_BER">
            <summary>Integer defining BER format of the certificate or private 
            key data.</summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.ENCODING_PKCS7">
            <summary>Integer defining PKCS7 format.</summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.ENCODING_PKCS8">
            <summary>Integer defining PKCS8 format of the private key 
            data.</summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.ENCODING_PKCS12">
            <summary>Integer defining PKCS12 format of the client 
            identity data.</summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSL.ENCODING_PFX">
            <summary>Integer defining Pfx format of the client 
            identity data.</summary>
        </member>
        <member name="M:TIBCO.EMS.EMSSSL.Initialize">
            <summary> Initializes SSL environment.</summary>
            <remarks>Normally SSL environment is initialized
            automatically when creating the first SSL connection. If SSL environment
            has been already initialized this method does nothing.
            </remarks>
            <exception cref="T:TIBCO.EMS.SecurityException">If method fails due to some error.</exception>
        </member>
        <member name="M:TIBCO.EMS.EMSSSL.SetAuthOnly(System.Boolean)">
            <summary> Enable or disable <see cref="F:TIBCO.EMS.EMSSSL.AUTH_ONLY"/> on the client side
            for SSL connection.</summary>
            <remarks ref="true()">
            <para>For the client and server to use SSL only during initial connection
            authentication, the <c>ssl_auth_only</c> parameter needs to be set on the 
            server and <see cref="F:TIBCO.EMS.EMSSSL.AUTH_ONLY"/> needs to be set by the client. Setting these 
            flags on both the server and client side indicates that the SSL 
            connection is only used to only perform authentication. Once 
            authentication is complete, the client switches to a regular TCP 
            connection to communicate with the server.
            </para>
            <para>Connections use this setting at the time they are created.
            Changing this setting only affects connections created after
            the change. 
            </para>
            </remarks>
            <param name="b"> If set to <c>true</c>, then connections use SSL only
            for authentication and switch to TCP protocol for all subsequent
            messaging. If <c>false</c> (default), then SSL is used
            for the lifetime of the connection.
            </param>
            <seealso cref="M:TIBCO.EMS.EMSSSL.GetAuthOnly">GetAuthOnly</seealso>
        </member>
        <member name="M:TIBCO.EMS.EMSSSL.GetAuthOnly">
            <summary> Get the value of the <see cref="F:TIBCO.EMS.EMSSSL.AUTH_ONLY"/> flag </summary>
            <returns>True for enabled and false for disabled.</returns>
        </member>
        <member name="M:TIBCO.EMS.EMSSSL.SetClientTracer(System.IO.StreamWriter)">
            <summary> Set client tracer to given output stream.</summary>
            <remarks>Client tracing prints loaded certificates and information 
            about the SSL handshake errors and results.
            </remarks>
            <param name="tracer">The output stream to send the tracing information. 
            Specify null as parameter to disable client tracing. </param>
        </member>
        <member name="M:TIBCO.EMS.EMSSSL.GetClientTracer">
            <summary> Returns the output target for the client tracer or null 
            if client tracing is disabled.</summary>
        </member>
        <member name="M:TIBCO.EMS.EMSSSL.SetTargetHostName(System.String)">
            <summary>Set the target host name.</summary>
            <remarks>
            This is a required parameter for all .NET SSL connections. Because 
            System.Net.Security.SslStream requires a target host, this value is required.
            </remarks>
            <param name="hostname">The name of the server as defined in the 
            server's certificate. Usually the server's HostName is specified 
            as the CN in the server's certificate.  This value must match the 
            name on the server's certificate server name.</param>
        </member>
        <member name="M:TIBCO.EMS.EMSSSL.GetTargetHostName">
            <summary> Returns the name set target host name. </summary>
        </member>
        <member name="M:TIBCO.EMS.EMSSSL.SetHostNameVerifier(TIBCO.EMS.EMSSSLHostNameVerifier)">
            <summary> Set the custom host name verifier.</summary>
            <param name="verifier">Host name verifier. Set to null to remove 
            custom host name verifier. See 
            <see cref="T:TIBCO.EMS.EMSSSLHostNameVerifier">EMSSSLHostNameVerifier</see> 
            for details.
            </param>
        </member>
        <member name="M:TIBCO.EMS.EMSSSL.GetHostNameVerifier">
            <summary> Returns currently set custom host name verifier. </summary>
            <returns>Null if custom host name verifier is not set.</returns>
        </member>
        <member name="M:TIBCO.EMS.EMSSSL.SetCertificateStoreType(TIBCO.EMS.EMSSSLStoreType,System.Object)">
            <summary> Set the store type for all the connection factories
            </summary>
            <param name="storeInfo">If the store type is EMSSSL_STORE_TYPE_SYSTEM, 
            then storeInfo must be an 
            <see cref="T:TIBCO.EMS.EMSSSLSystemStoreInfo">EMSSSLSystemStoreInfo</see> object. 
            If the store type is EMSSSL_STORE_TYPE_FILE, then storeInfo must be an 
            <see cref="T:TIBCO.EMS.EMSSSLFileStoreInfo">EMSSSLFileStoreInfo</see> object.</param>
            <param name="type">The type of certificate store. Can be either 
            EMSSSL_STORE_TYPE_SYSTEM or EMSSSL_STORE_TYPE_FILE.  
            See <see cref="T:TIBCO.EMS.EMSSSLStoreType">EMSSSLStoreType</see> details.</param>
        </member>
        <member name="M:TIBCO.EMS.EMSSSL.GetCertificateStore">
            <summary> returns the current certificate store, null if none
            has been set yet.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.EMSSSLFileStoreInfo">
            <summary>Specifies the file store information.</summary>
            <remarks>
            File Store Info object to be used while setting the 
            store for a connection factory via the 
            <see cref="M:TIBCO.EMS.ConnectionFactory.SetCertificateStoreType(TIBCO.EMS.EMSSSLStoreType,System.Object)"/>
            or while using the global EMSSSL API to set the certificate store.
            The store info consists of the client's identity (the only type
            supported is the pkcs12 file aka .pfx file format), the password
            for the private key stored in the pkcs12 file and any
            optional trusted certificates. 
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLFileStoreInfo.#ctor">
            <summary> creates an object of type file store info</summary>
            <remarks> 
            This object is used mainly to specify file store information when the store
            type of FILE is used by the 
            <see cref="M:TIBCO.EMS.ConnectionFactory.SetCertificateStoreType(TIBCO.EMS.EMSSSLStoreType,System.Object)"/> method.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLFileStoreInfo.SetSSLClientIdentity(System.String)">
            <summary> Set the client identity as a string</summary>
            <remarks>
            Sets Client Identity (The client's digital certificate),
            the only file type that is supported here is a pkcs12 or .pfx file.
            <para>
            <b>Note: </b>If other file format are specifed then a configuration 
            exception will be thrown during the SSL handshake.
            </para>
            <para>
            <example>
            To set the Client Identity as a string:
            <code>
                public void SetSSLClientIdentity(clientId); 
            </code></example>
            </para>
            </remarks>
            <param name="clientIdentity">The X509 Certificate used to identify the client.
            </param>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLFileStoreInfo.SetSSLPassword(System.Char[])">
            <summary>Set the private key password </summary>
            <param name="password">The SSL Password.</param>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLFileStoreInfo.SetSSLClientIdentity(System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary> Set the client identity as a X509 Certificate.</summary>
            <remarks>
            Sets Client Identity (The client's digital certificate),
            the only file type that is supported here is a pkcs12 or .pfx file.
            <para>
            <b>Note: </b>If other file format are specifed then a configuration 
            exception will be thrown during the SSL handshake.
            </para>
            <para>
            <example>
            To set Client Identity as a X509 Certificate, use:
            <code>
                void SetSSLClientIdentity(X509Certificate); 
            </code></example>
            </para>
            </remarks>
            <param name="cert">A pkcs12 or .pfx file used to identify the client.
            </param>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLFileStoreInfo.SetSSLTrustedCertificate(System.String)">
            <summary> Add this specified certificate to the list of
            of trusted certificates </summary>
            <remarks>
            Only ASN1.DER encoded files are supported.
            </remarks>
            <param name="certificate">The name of the certificate to add to the 
            list of trusted certificates.</param>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLFileStoreInfo.SetSSLTrustedCertificate(System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary> Add this specified certificate to the list of
            of trusted certs. Note: only ASN1.DER encoded files are supported
            </summary>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLFileStoreInfo.ClearTrustedCerts">
            <summary>Removes all previously set trusted certificates. </summary>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLFileStoreInfo.ToString">
            <summary> Returns a string representation of the EMSSSLFileStore Info object
            </summary>
        </member>
        <member name="T:TIBCO.EMS.EMSSSLHostNameVerifier">
            <summary> Delegate declaration for host name verifier </summary>
            <remarks>
            The user can perform any necessary specific validations in the host
            name verifier delegate, returning false will cause the SSL handshake
            to terminate, returning true will cause the SSL handshake to continue.
            </remarks>
            <param name="sender">The source of the event. </param>
            <param name="args">The event argument, <see cref="T:TIBCO.EMS.EMSSSLHostNameVerifierArgs"/></param>
        </member>
        <member name="T:TIBCO.EMS.EMSSSLHostNameVerifierArgs">
            <summary>Specifies the host name verifier arguments</summary>
            <remarks>
            The client is handed off an EMSSSLHostNameVerifierArgs object as part 
            of the host name verifier event callback, 
            <see cref="M:TIBCO.EMS.LdapLookupSSLParams.SetSSLVerifyServerCertificateCallback(System.DirectoryServices.Protocols.VerifyServerCertificateCallback)"/>. 
            </remarks>
            
        </member>
        <member name="F:TIBCO.EMS.EMSSSLHostNameVerifierArgs.m_connectedHostName">
            <summary> The host name to which the client is connected to 
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSLHostNameVerifierArgs.m_targetHostName">
            <summary> The targetHostName (which is actually the server certficiate
            CN name) </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSLHostNameVerifierArgs.m_certificateCommonName">
            <summary> The certificate CN name, should be same as the target
            hostname </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSLHostNameVerifierArgs.m_serverCertificate">
            <summary> the server's certificate </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSLHostNameVerifierArgs.m_x509Chain">
            <summary> The server certificate's chain </summary>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLHostNameVerifierArgs.#ctor(System.String,System.String,System.String,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain)">
            <summary> constructor for EMSSSLHostNameVerifierArgs
            </summary>
        </member>
        <member name="T:TIBCO.EMS.EMSSSLStoreType">
            <summary> Certificate Store Type to be used for reading SSL Certificates
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSLStoreType.EMSSSL_STORE_TYPE_FILE">
            <summary> public const to be used if the certificates are stored in 
            a pkcs12 (aka .pfx) file.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSLStoreType.EMSSSL_STORE_TYPE_SYSTEM">
            <summary> public const to be used if the certificates are store in
            the Microsoft certificate store.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.EMSSSLStoreType.EMSSSL_STORE_TYPE_DEFAULT">
            <summary> public const to be used if the certificates are stored in
            the Microsoft certificate store, specifying default will cause the
            Microsoft certificate store to be used.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.EMSSSLSystemStoreInfo">
            <summary>Specifies the system store information</summary>
            <remarks>
            <para>
            System Store Info object to be used while setting the 
            store type for a connection factory via the 
            <see cref="M:TIBCO.EMS.ConnectionFactory.SetCertificateStoreType(TIBCO.EMS.EMSSSLStoreType,System.Object)"/>.
            The store info consists of the store location, store name, the 
            certificate name (to look for in the specified store name at the 
            specified store location).</para>
            <para>
            The default store location is StoreLocation.CurrentUser and the
            default store name is 'my' store as defined by the .NET framework.
            The search criteria to find the certificate in the store name at the
            store location is X509FindType.FindBySubjectDistinguishedName.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLSystemStoreInfo.#ctor">
            <summary> creates an object of type system store info</summary>
            <remarks> 
            This object is used mainly to specify system store information when the store
            type of SYSTEM is used by the 
            <see cref="M:TIBCO.EMS.ConnectionFactory.SetCertificateStoreType(TIBCO.EMS.EMSSSLStoreType,System.Object)"/> method.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLSystemStoreInfo.SetCertificateStoreName(System.String)">
            <summary>Set the certificate store name</summary>
            <remarks>
            This is the name of the store in which certificates are stored. 
            During the SSL handshake, this is where the client library looks 
            for the certificates.
            </remarks>
            <param name="storeName">Name of the certificate store.</param>
            <exception cref="T:System.ArgumentException"> If the store name is null
            </exception>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLSystemStoreInfo.SetCertificateStoreLocation(System.Security.Cryptography.X509Certificates.StoreLocation)">
            <summary>Set location of the certificate store</summary>
            <remarks>
            The certificate store location indicates where to lookup the 
            certificate by name. If no store name is specified, then the 
            default store name is "My" store name within this store location.
            </remarks>
            <param name="storeLocation">Location in which to lookup certificate 
            by name. For example, "CurrentUser" or "LocalMachine."
            </param>
        </member>
        <member name="M:TIBCO.EMS.EMSSSLSystemStoreInfo.SetCertificateName(System.String)">
            <summary> Set the name of the certificate</summary>
            <remarks>
            This method sets the name of the certificate. The certificate 
            name is the subject distinguished name of the certificate. 
            During the SSL handshake, the server searches for the named 
            certificate in the store specified by <see cref="M:TIBCO.EMS.EMSSSLSystemStoreInfo.SetCertificateStoreName(System.String)"/> 
            at the location specified by <see cref="M:TIBCO.EMS.EMSSSLSystemStoreInfo.SetCertificateStoreLocation(System.Security.Cryptography.X509Certificates.StoreLocation)"/>. 
            The search criteria to find the certificate in the store name at the
            store location is X509FindType.FindBySubjectDistinguishedName.
            <b>Note: </b>
            While searching for the certificate in the certificate store, the tag 
            'CN' is automatically prepended to the certificate name.
            </remarks>
            <param name="certName">Certificate name.</param>
            <exception cref="T:System.ArgumentException"> If the certificate name is null.</exception>
            \deprecated Use EMSSSLSystemStoreInfo.SetCertificateNameAsFullSubjectDN instead.
        </member>
        <member name="M:TIBCO.EMS.EMSSSLSystemStoreInfo.SetCertificateNameAsFullSubjectDN(System.String)">
            <summary> Set the name of the certificate as a full subject DN</summary>
            <remarks>
            This method sets the name of the certificate. The certificate 
            name is the subject distinguished name of the certificate. 
            During the SSL handshake, the server searches for the named
            certificate in the store specified by <see cref="M:TIBCO.EMS.EMSSSLSystemStoreInfo.SetCertificateStoreName(System.String)"/> 
            at the location specified by <see cref="M:TIBCO.EMS.EMSSSLSystemStoreInfo.SetCertificateStoreLocation(System.Security.Cryptography.X509Certificates.StoreLocation)"/>. 
            The search criteria to find the certificate in the store name at the
            store location is X509FindType.FindBySubjectDistinguishedName.
            <example>
            A subject DN sample
            <code>
            E=client@testcompany.com, CN=client, OU=client Unit, O=Test Company, L=us-english, S=California, C=US
            </code>
            </example>
            </remarks>
            <param name="certName">Certificate name.</param>
            <exception cref="T:System.ArgumentException"> If the certificate name is null.</exception>
        </member>
        <member name="T:TIBCO.EMS.FederatedConnectionFactory">
            <summary> The FederatedConnectionFactory class represents the connection factory entry
            in the naming server.  A FederatedConnectionFactory object is the query result of a
            connection factory name lookup, the return value of the <c>NameSearcher.Lookup</c> method.  
            </summary>
            <remarks>
            A FederatedConnectionFactory object has a <c>Name</c> property that uniquely identifies 
            the entry in the naming server.  If we want to store the reference of query 
            result into a 3rd-party directory server, this property can be used as the entry name of 
            a System.DirectoryServices.DirectoryEntry in ASDI.
            </remarks>
            
        </member>
        <member name="M:TIBCO.EMS.FederatedConnectionFactory.#ctor(System.String,System.String,System.String,System.Collections.Hashtable,System.Collections.Hashtable)">
            <summary> Construct a FederatedConnectionFactory instance </summary>
            <param name="jndiName">The JNDI name of the entry</param>
            <param name="url">The URL of the naming server</param>
            <param name="id">The id of the entry</param>
            <param name="properties">The naming service properties</param>
            <param name="env"></param>
        </member>
        <member name="P:TIBCO.EMS.FederatedConnectionFactory.Name">
            <summary> Gets the name property of the object.  The name string 
            uniquely identfies the connection factory and can be used as 
            the entry name of a DirectoryEntry in ASDI. </summary>
        </member>
        <member name="T:TIBCO.EMS.FederatedEMSDTCConnectionFactory">
            <summary> The FederatedEMSDTCConnectionFactory class represents the connection factory entry
            in the naming server.  A FederatedEMSDTCConnectionFactory object is the query result of a
            connection factory name lookup, the return value of the <c>NameSearcher.Lookup</c> method.  
            </summary>
            <remarks>
            A FederatedEMSDTCConnectionFactory object has a <c>Name</c> property that uniquely identifies 
            the entry in the naming server.  If we want to store the reference of query 
            result into a 3rd-party directory server, this property can be used as the entry name of 
            a System.DirectoryServices.DirectoryEntry in ASDI.
            </remarks>
            
        </member>
        <member name="M:TIBCO.EMS.FederatedEMSDTCConnectionFactory.#ctor(System.String,System.String,System.String,System.Collections.Hashtable,System.Collections.Hashtable)">
            <summary> Construct a FederatedEMSDTCConnectionFactory instance </summary>
            <param name="jndiName">The JNDI name of the entry</param>
            <param name="url">The URL of the naming server</param>
            <param name="id">The id of the entry</param>
            <param name="properties">The naming service properties</param>
            <param name="env"></param>
        </member>
        <member name="P:TIBCO.EMS.FederatedEMSDTCConnectionFactory.Name">
            <summary> Gets the name property of the object.  The name string 
            uniquely identfies the connection factory and can be used as 
            the entry name of a DirectoryEntry in ASDI. </summary>
        </member>
        <member name="T:TIBCO.EMS.FederatedQueue">
            <summary> The FederatedQueue class represents the queue entry in the naming server.  
            A FederatedQueue object is the query result of a queue name lookup, the return value 
            of the <c>NameSearcher.Lookup</c> method.  
            </summary>
            <remarks>
            A FederatedQueue object has a <c>Name</c> property that uniquely identifies 
            the queue entry in the naming server.  If we want to store the reference of query 
            result into a 3rd-party directory server, this property can be used as the entry name of 
            a System.DirectoryServices.DirectoryEntry in ASDI.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.FederatedQueue.#ctor(System.String,System.String,System.Collections.Hashtable)">
            <summary> Construct a FederatedConnectionFactory instance </summary>
            <param name="name">The name of hte entry</param>
            <param name="jndiName">The JNDI name of the entry</param>
            <param name="env"></param>
        </member>
        <member name="P:TIBCO.EMS.FederatedQueue.Name">
            <summary> Gets the name property of the object.  The name string 
            uniquely identfies the queue and can be used as the entry name of 
            a DirectoryEntry in ASDI. </summary>
        </member>
        <member name="T:TIBCO.EMS.FederatedQueueConnectionFactory">
            <summary> The FederatedQueueConnectionFactory class represents the queue connection factory entry
            in the naming server.  A FederatedQueueConnectionFactory object is the query result of a
            queue connection factory name lookup, the return value of the <c>NameSearcher.Lookup</c> method.  
            </summary>
            <remarks>
            A FederatedQueueConnectionFactory object has a <c>Name</c> property that uniquely identifies 
            the entry in the naming server.  If we want to store the reference of query 
            result into a 3rd-party directory server, this property can be used as the entry name of 
            a System.DirectoryServices.DirectoryEntry in ASDI.
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.FederatedQueueConnectionFactory.Name">
            <summary> Gets the name property of the object.  The name string 
            uniquely identfies the QueueConnectionFactory and can be used as 
            the entry name of a DirectoryEntry in ASDI. </summary>
        </member>
        <member name="T:TIBCO.EMS.FederatedTopic">
            <summary> The FederatedTopic class represents the topic entry in the naming server.  
            A FederatedTopic object is the query result of a topic name lookup, the return value 
            of the <c>NameSearcher.Lookup</c> method.  
            </summary>
            <remarks>
            A FederatedTopic object has a <c>Name</c> property that uniquely identifies 
            the topic entry in the name server.  If we want to store the reference of query 
            result into a 3rd-party directory server, this property can be used as the entry name of 
            a System.DirectoryServices.DirectoryEntry in ASDI.
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.FederatedTopic.Name">
            <summary> Gets the name property of the object.  The name string 
            uniquely identfies the topic and can be used as the entry name of 
            a DirectoryEntry in ASDI. </summary>
        </member>
        <member name="T:TIBCO.EMS.FederatedTopicConnectionFactory">
            <summary> The FederatedTopicConnectionFactory class represents the topic connection factory entry
            in the naming server.  A FederatedTopicConnectionFactory object is the query result of a
            topic connection factory name lookup, the return value of the <c>NameSearcher.Lookup</c> method.  
            </summary>
            <remarks>
            A FederatedTopicConnectionFactory object has a <c>Name</c> property that uniquely identifies 
            the entry in the naming server.  If we want to store the reference of query 
            result into a 3rd-party directory server, this property can be used as the entry name of 
            a System.DirectoryServices.DirectoryEntry in ASDI.
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.FederatedTopicConnectionFactory.Name">
            <summary> Gets the name property of the object.  The name string 
            uniquely identfies the TopicConnectionFactory and can be used as 
            the entry name of a DirectoryEntry in ASDI. </summary>
        </member>
        <member name="T:TIBCO.EMS.ICompletionListener">
            <summary>
            Notifies the application an asynchronous send has completed.
            </summary>
            <remarks ref="true()"> 
            <para> A CompletionListener is implemented by the application and may be 
            specified when a message is sent asynchronously. 
            </para>
            <para> When the sending of the message is complete, the application
            is notified through the OnCompletion(Message) method of the specified
            completion listener.  Only when that callback has been invoked can
            the application be sure that the message has been successfully sent
            with the same degree of confidence as if a normal synchronous send
            had been performed. An application which requires this degree of 
            confidence must therefore wait for the callback to be invoked before
            continuing. If the sending of the message fails for any reason, and
            an exception cannot be thrown by the send method, then the
            OnException(Exception) method of the specified completion listener
            is called.
            </para>
            <para>
            The following information is intended to give an indication of how an
            asynchronous send would typically be implemented. 
            </para>
            <para>
            A normal synchronous send involves sending the message to a remote
            EMS server and then waiting for an acknowledgement to be received
            before returning. EMS implements an asynchronous send by sending
            the message to the remote EMS server and then returning without
            waiting for an acknowledgement. When the acknowledgement is received,
            EMS will notify the application by invoking the OnCompletion method
            on the application-specified ICompletionListener object.
            If for some reason the acknowledgement is not received, then EMS will
            notify the application by invoking the ICompletionListener's
            OnException method. 
            </para>
            <para>
            It is highly recommended that a synchronous send is used when
            using reliable or non-persistent delivery.  An asynchronous send
            will always schedule an ICompletionListener event; with lower levels
            of reliability, synchronous sends will perform better compared
            to asynchronous sends.
            </para>
            <para><b>Quality of service:</b> After the send operation has
            completed successfully, which means that the message has been
            successfully sent with the same degree of confidence as if a
            normal synchronous send had been performed, EMS will invoke the
            ICompletionListener's OnCompletion method. The ICompletionListener
            will not be invoked earlier than this.
            </para>
            <para>
            <b>Exceptions:</b>  If an exception is encountered during the call
            to the send method, then an appropriate exception will be thrown in
            the thread that is calling the send method. EMS will not invoke the
            ICompletionListener's OnCompletion or OnException method. If an
            exception is encountered which cannot be thrown in the thread that
            is calling the send method then EMS will call the ICompletionListener's
            OnException method.  In both cases if an exception occurs it is
            undefined  whether or not the message was successfully sent. </para>
            <para>
            <b>Message order:</b> If the same MessageProducer is used to send
            multiple messages then EMS message ordering will be maintained.
            This applies even if a combination of synchronous and asynchronous
            sends has been performed. The application is not required to wait for
            an asynchronous send to complete before sending the next message.
            </para>
            <para>
            <b>Close, commit or rollback:</b> If the close method is called on the
            MessageProducer or its Session or Connection then EMS will block until
            any incomplete send operations have been completed and all
            ICompletionListener callbacks have returned before closing the object
            and returning. If the session is transacted (uses a local transaction)
            then when the Session's commit or rollback method is called EMS will block
            until any incomplete send operations have been completed and all
            ICompletionListener callbacks have returned before performing the commit
            or rollback. Incomplete sends will be allowed to complete normally
            unless an error occurs. 
            </para>
            <para>
            A ICompletionListener callback method must not call close on its own
            Connection, Session or MessageProducer or call commit or rollback on
            its own Session. Doing so will cause the close, commit or rollback to
            throw an IllegalStateException.
            </para>
            <para>
            <b>Message headers:</b> EMS defines a number of message header fields
            and message properties which are set upon a send.  If the send is
            asynchronous these fields and properties may be accessed on the
            sending client only after the ICompletionListener has been invoked.
            If the ICompletionListener's OnException method is called then the
            state of these message header fields and properties is undefined. 
            </para>
            <para>
            <b>Restrictions on threading:</b> Applications that perform an
            asynchronous send must conform to EMS threading restrictions.  This
            means that the session may be used by only one thread at a time.
            </para>
            <para>
            Setting a CompletionListener does not cause the session to be
            dedicated to the thread of control which calls the CompletionListener.
            The application thread may therefore continue to use the session after 
            performing an asynchronous send. However the CompletionListener's 
            callback methods must not use the session if an application thread
            might be using the session at the same time. 
            </para>
            <para>
            <b>Use of the CompletionListener:</b> A session will only
            invoke one CompletionListener callback method at a time. For a given
            MessageProducer, callbacks (both OnCompletion and OnException) will
            be performed in the same order as the corresponding calls to the
            asynchronous send method. An EMS provider must not invoke the 
            CompletionListener from the thread that is calling the asynchronous
            send method. 
            </para>
            <para>
            <b>Restrictions on the use of the Message object:</b>  Applications
            which perform an asynchronous send must take account of the
            restriction that a Message object is designed to be accessed by one
            logical thread of control at a time and does not support concurrent
            use. 
            </para>
            <para>After the send method has returned, the application must not
            attempt to read the headers, properties or body of the Message
            object until the CompletionListener's OnCompletion or OnException
            method has been called. This is because the EMS may be modifying 
            the Message object in another thread during this time.
            </para>
            <para>ICompletionListener mimics the way in which JMS receives notification of message 
            completion in a Java programming idiom.
            </para>
            </remarks>
            <seealso cref="T:TIBCO.EMS.MessageProducer">MessageProducer class</seealso>
            <seealso cref="T:TIBCO.EMS.TopicPublisher">TopicPublisher class</seealso>
            <seealso cref="T:TIBCO.EMS.QueueSender">QueueSender class</seealso>
        </member>
        <member name="M:TIBCO.EMS.ICompletionListener.OnCompletion(TIBCO.EMS.Message)">
            <summary>  Notifies the application that the message has been successfully sent </summary>
            <remarks ref="true()">
            </remarks>
            <param name="msg"> The message that was sent </param>
        </member>
        <member name="M:TIBCO.EMS.ICompletionListener.OnException(TIBCO.EMS.Message,System.Exception)">
            <summary>  Notifies the application that the specified exception was thrown while
            attempting to send the specified message </summary>
            <remarks ref="true()">
            </remarks>
            <param name="msg"> The message that was sent </param>
            <param name="ex"> The exception </param>
        </member>
        <member name="T:TIBCO.EMS.IExceptionListener">
            <summary> Asynchronously detect problems with connections.</summary>
            <remarks ref="true()">
            <para>The client implements the IExceptionListener interface, and registers it with 
            the <see cref="T:TIBCO.EMS.Connection">Connection</see> object.
            If the client detects a serious problem with the Connection object, it informs the 
            IExceptionListener by calling the listener's <see cref="M:TIBCO.EMS.IExceptionListener.OnException(TIBCO.EMS.EMSException)"/> method, 
            passing it a EMSException argument describing the problem. 
            </para>
            <para>An exception listener allows a client to be notified of a problem asynchronously.
            Some connections only consume messages, so they would have no other way to learn that 
            their connection has failed. 
            </para>
            <para> The client will first attempt to resolve connection problems 
            before it notifies the client of them.
            </para>
            <para>IExceptionListener mimics the way in which JMS detects this type of problem in 
            a Java programming idiom. In contrast, EMSExceptionHandler provides similar 
            functionality in a .NET idiom. Programmers may select either idiom - but not both 
            (which would cause duplicate exception processing with undefined behavior).
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.IExceptionListener.OnException(TIBCO.EMS.EMSException)">
            <summary> Asynchronously notifies the user of an EMSEXception. </summary>
            <remarks ref="true()">
            </remarks>
            <param name="exception"> The EMSException </param>
        </member>
        <member name="T:TIBCO.EMS.IllegalStateException">
            <summary>A method call or server request occurred in an inappropriate context.</summary>
            <remarks>
            This exception is thrown when a method is invoked at an illegal
            or inappropriate time or if the provider is not in an appropriate state 
            for the requested operation. For example, this exception is thrown 
            if <see cref="M:TIBCO.EMS.Session.Commit">Session.commit</see> is called on 
            a non-transacted session. This exception is also called when a domain 
            inappropriate method is called, such as calling CreateBrowser on a TopicSession.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.IllegalStateException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the IllegalStateException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.IllegalStateException.#ctor(System.String)">
            <summary> Initializes a new instance of the IllegalStateException
            with the specified reason.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.ILookupContext">
             <summary> 
             The initial context used to look up administered objects in either 
             an EMS server or a third-party LDAP server.
             </summary>
             <remarks>
             <para>ILookupContext is implemented by the 
             <see cref="T:TIBCO.EMS.LookupContext">LookupContext</see> and 
             <see cref="T:TIBCO.EMS.LdapLookupContext">LdapLookupContext</see> 
             classes. LookupContext is mainly used to lookup up JMS administered objects 
             (such as connection factories and destinations)
             in the TIBCO EMS server, whereas LdapLookupContext is used for looking up 
             JMS administered objects in an LDAP server.
             </para>
             <para>Users obtain an object of type ILookupContext (implemented by LookupContext 
             and LdapLookupContext) by calling the 
             <see cref="M:TIBCO.EMS.LookupContextFactory.CreateContext(System.String,System.Collections.Hashtable)">LookupContextFactory.CreateContext</see> 
             method.
             </para>
             <example> 
             <para>This example shows how to lookup an object in the 
             LDAP server by getting an LdapLookupContext from the LookupConextFactory:
            
             <code>
                 Hashtable table = new Hashtable();
                 table.Add(LdapLookupConsts.LDAP_SERVER_URL, "10.105.185.30:10389");
                 table.Add(LdapLookupConsts.LDAP_BASE_DN, "ou=People,dc=nmunjal1");
                 table.Add(LdapLookupConsts.LDAP_PRINCIPAL, "cn=Manager");
                 table.Add(LdapLookupConsts.LDAP_CONN_TYPE, "ldap");
             
                  LookupContextFactory contextFactory = new LookupContextFactory();
                  ILookupContext searcher = contextFactory.CreateContext("ldap", table);    
                 ConnectionFactory cf = (ConnectionFactory)searcher.Lookup("cn=testConnFact");
             </code>
             </para>
             </example>
             <para>This example shows how to lookup and an object in the LDAP
             server via SSL:
             <code>
                 Hashtable props = new Hashtable(); 
                    props.Add(LdapLookupConsts.LDAP_SERVER_URL", "adc1.na.tibco.com:10636");
                    props.Add(LdapLookupConsts.LDAP_BASE_DN",  "ou=People,dc=test-user");
                    props.Add(LdapLookupConsts.LDAP_PRINCIPAL", "cn=Manager");
                    props.Add(LdapLookupConsts.LDAP_CREDENTIAL", "password");
                    props.Add(LdapLookupConsts.LDAP_SEARCH_SCOPE, "subtree");
                    props.Add(LdapLookupConsts.LDAP_CONN_TYPE, "ldaps");
                    props.Add(LdapLookupConsts.LDAP_CERT_NAME, "certName");
                    props.Add(LdapLookupConsts.LDAP_CERT_STORE_NAME, "My");
                    props.Add(LdapLookupConsts.LDAP_CERT_STORE_LOCATION, "currentuser");
                   
                 optional ssl params:
                 LdapLookupSSLParams sslparams = new LdapLookupSSLParams();
                    sslparams.SetSSLQueryClientCertificateCallback(QueryClientCertificateCallback);
                    sslparams.SetSSLVerifyServerCertificateCallback(VerifyServerCertificateCallback);
                    props.Add(LdapLookupConsts.LDAP_SSL_PARAMS, sslparams);
            
                 LookupContextFactory contextFactory = new LookupContextFactory();
                 ILookupContext searcher = contextFactory.CreateContext("ldap", props);    
                 ConnectionFactory cf =  searcher.Lookup("cn=testConnFact");
                 Console.WriteLine("cf = " + cf.ToString());
             </code>
             </para>
            
             <para> </para>
             <para> </para>
             <para>For lookup of objects in TIBCO EMS Naming server:
             <code>
                 Hashtable env = new Hashtable();
                 env.Add(LookupContext.PROVIDER_URL, "tibjmsnaming://localhost:7222");
                 env.Add(LookupContext.SECURITY_PRINCIPAL", "myUserName");
                 env.Add(LookupContext.SECURITY_CREDENTIALS", "myPassword");
                 try { 
                     // old style code will still work
                     LookupContext searcher = new LookupContext(env);
             
                     // new code
                     LookupContextFactory contextFactory = new LookupContextFactory();
                     ILookupContext searcher = contextFactory.CreateContext("tibjmsnaming", env);
                     TIBCO.EMS.Queue queue = (TIBCO.EMS.Queue)searcher.Lookup("theQueueName");
                     ...
                 } catch (NamingException) {
                     ...
                 }
             
             </code>
             </para>
             </remarks>
        </member>
        <member name="M:TIBCO.EMS.ILookupContext.AddSettings(System.Collections.Hashtable)">
            <summary> Add setting to the lookup context by passing a hash table</summary>
            <remarks>
            <para>Setting added to the lookup context are mainly LDAP or TIBCO EMS 
            Naming Server related parameters used for looking up objects stored 
            in an LDAP server or TIBCO EMS Server. 
            </para>
            <para>Examples of setting names include
            <see cref="F:TIBCO.EMS.LdapLookupConsts.LDAP_SERVER_URL">LDAP_SERVER_URL</see> or 
            <see cref="F:TIBCO.EMS.LdapLookupConsts.LDAP_BASE_DN">LDAP_BASE_DN</see>.
            </para>
            <para>To add settings contained in a hash table:</para>
            <example>
            <code>
                Hashtable table = new Hashtable();
                LookupContextFactory contextFactory = new LookupContextFactory();
                ILookupContext searcher = contextFactory.CreateContext("ldap", table);    
                searcher.AddSettings(table);
            </code>
            </example>
            </remarks>
            <param name="prop">The hash table that contains all of the name-value pairs 
            to be set.</param>
        </member>
        <member name="M:TIBCO.EMS.ILookupContext.AddSettings(System.String,System.Object)">
            <summary> Add setting to the lookup context by passing a property/value pair</summary>
            <remarks>
            <para>Setting added to the lookup context are mainly LDAP or TIBCO EMS 
            Naming Server related parameters used for looking up objects stored 
            in an LDAP server or TIBCO EMS Server.
            </para>
            <para>Examples of setting names include
            <see cref="F:TIBCO.EMS.LdapLookupConsts.LDAP_SERVER_URL">LDAP_SERVER_URL</see> or 
            <see cref="F:TIBCO.EMS.LdapLookupConsts.LDAP_BASE_DN">LDAP_BASE_DN</see>.
            </para>
            <para>To add settings directly:</para>
            <example>
            <code>
                Hashtable table = new Hashtable();
                LookupContextFactory contextFactory = new LookupContextFactory();
                ILookupContext searcher = contextFactory.CreateContext("ldap", table);    
                searcher.AddSettings(LdapLookupConsts.LDAP_SERVER_URL, "adc1.na.tibco.com:10389"); 
            </code>
            </example>
            </remarks>
            <param name="propName">The name of the property to be set.  For property names, see the
            <see cref="T:TIBCO.EMS.LookupContext">LookupContext</see> Fields. </param>
            <param name="propValue">The value to set for this property.</param>
        </member>
        <member name="P:TIBCO.EMS.ILookupContext.Settings">
            <summary>
            Return the current settings of this lookup context
            </summary>
        </member>
        <member name="M:TIBCO.EMS.ILookupContext.RemoveSettings(System.String)">
            <summary> Remove a lookup context setting by name</summary>
            <remarks> To add and then remove the LDAP_SERVER_URL property
             from the lookup context:</remarks>
            <example>
            <code>
                Hashtable table = new Hashtable();
                table.Add(LdapLookupConsts.LDAP_SERVER_URL, "adc1.na.tibco.com:10389");
                LookupContextFactory contextFactory = new LookupContextFactory();
                ILookupContext searcher = contextFactory.CreateContext("ldap", table);    
                searcher.RemoveSettings(LdapLookupConsts.LDAP_SERVER_URL);
            </code>
            </example>
        </member>
        <member name="M:TIBCO.EMS.ILookupContext.Lookup(System.String)">
            <summary> Lookup up an object (given the name of the object) in the
            LDAP or TIBCO EMS Naming server</summary>
            <remarks>
            <para>This method looks up an object in either an LDAP or TIBCO EMS Naming server, 
            depending on which interface is asked for in the 
            <see cref="T:TIBCO.EMS.LookupContextFactory">LookupContextFactory</see>.
            </para>
            <para> <b> Ldap Related Information </b> </para>
            <para>
            This will first initialize the ldap connection environment if the
            the context initialized is LDAP context and then searches for the
            object in the ldap server, constructs the object and returns the 
            object.
            </para>
            <para>
            At a very high level the lookup function performs a set of tasks
            for an ldap context.
                  <list type="bullet"> 
                    <item> Initializes the ldap connection environment, 
                           performs various checks to make 
                           sure the right parameters are passed in. </item>
                    <item> Establishes a LDAP connection to the specified 
                           server </item>
                    <item> Searches for the specified object in the LDAP server
                           </item>
                    <item> Once it receives the XML data for the specified 
                           administered object, it performs XML validation 
                           through the specified DTD. </item>
                    <item> Retrieves the object properties stored as XML.
                           </item>
                    <item> Constructs and returns the appropriate objects.
                           </item>
                  </list>
            </para>
            </remarks>
            <exception cref="T:TIBCO.EMS.NamingException"> Cannot connect to the ldap 
            server; cannot connect to the TIBCO EMS Naming server if the context is 
            tibjmsnaming context; cannot find the object, or some other exception.
            </exception>
            <exception cref="T:TIBCO.EMS.ConfigurationException"> The url, basedn, principal, credential, or
            any combination of the required parameters are missing.
            </exception>
            <example>
            <code>
               LookupContextFactory contextFactory = new LookupContextFactory();
               ILookupContext searcher = contextFactory.CreateContext("ldap", table);    
               ConnectionFactory cf = (ConnectionFactory)searcher.Lookup("cn='testConnFact");
            </code>
            </example>
        </member>
        <member name="T:TIBCO.EMS.IMessageListener">
            <summary>Asynchronously process an arriving message. </summary>
            <remarks ref="true()"> 
            <para>This interface provides an asynchronous pathway for receiving messages. 
            In order to receive messages asynchronously, a client implements this interface 
            and calls setMessageListener to register the message listener with 
            a MessageConsumer. When a message arrives, the client library calls the 
            listener's onMessage method with the message as its argument.
            </para>
            <para>Each session insures that it passes messages serially to the listener. This means that a 
            listener assigned to one or more consumers of the same session can assume that the onMessage method is 
            not called with the next message until the session has completed the last call
            </para>
            <para>IMessageListener mimics the way in which JMS receives messages in a Java 
            programming idiom. In contrast, EMSMessageHandler provides similar functionality 
            in a .NET idiom. Programmers may select either idiom but not both (which would 
            cause duplicate message processing with undefined behavior).
            </para>
            <para><b>Deprecated</b></para>
            <para>In earlier releases, clients could register listeners with sessions as well as 
            consumers. This practice is now deprecated - we recommend migrating existing code 
            to one of these two practices:</para>
            <list type="bullet">
            <item><description>Java Idiom  Register listeners with consumers.</description></item>
            <item><description>.NET Idiom  Register EMSMessageHandler delegates with consumers.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.IMessageListener.OnMessage(TIBCO.EMS.Message)">
            <summary>  Passes a message to the message listener </summary>
            <remarks ref="true()">
            </remarks>
            <param name="message"> The message to be passed to the message listener </param>
        </member>
        <member name="T:TIBCO.EMS.InvalidClientIDException">
            <summary>The provider rejects the connection's client ID</summary>
            <remarks>
            Setting a connection's client ID to an invalid or duplicate value 
            results in this exception. (A duplicate value is one that is already in use 
            by another connection.)
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.InvalidClientIDException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the InvalidClientIDException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.InvalidClientIDException.#ctor(System.String)">
            <summary> Initializes a new instance of the InvalidClientIDException
            with the specified reason.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.InvalidDestinationException">
            <summary>The EMS Server cannot locate the destination </summary>
            <remarks>
            This exception is thrown when a destination either is not understood by
            the system or is no longer valid.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.InvalidDestinationException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the InvalidDestinationException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.InvalidDestinationException.#ctor(System.String)">
            <summary> Initializes a new instance of the InvalidDestinationException
            with the specified reason.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.InvalidSelectorException">
            <summary>The client passed a message selector with invalid syntax</summary>
            <remarks ref="true()"></remarks>
        </member>
        <member name="M:TIBCO.EMS.InvalidSelectorException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the InvalidSelectorException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.InvalidSelectorException.#ctor(System.String)">
            <summary> Initializes a new instance of the InvalidSelectorException
            with the specified reason.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.IResponseCallback">
            <summary>Callback of server response. It is for internal usage </summary>
        </member>
        <member name="T:TIBCO.EMS.ITemporaryDestination">
            <summary>A Temporary destination, parent class of <c>TemporaryQueue</c> and <c>TemporaryTopic</c> </summary>
        </member>
        <member name="T:TIBCO.EMS.LdapLookupConsts">
            <summary>Specifies the parameters used to connect to a third-party 
            LDAP server and lookup EMS administered objects. </summary>
            <remarks>
            <para>The LDAP Lookup Constants are mainly to specify parameters to connect 
            to an LDAP server and specify search scope with the LDAP server for 
            looking up EMS administered objects. 
            </para>
            <para>See <see cref="T:TIBCO.EMS.LookupContext">LookupContext</see> for the 
            parameters used looking up administered objects in the EMS server.
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_SERVER_URL">
            <summary> Use this property name to specify the url to connect to the LDAP server.
            </summary>
            <example>
            <code>
              table.Add(LdapLookupConsts.LDAP_SERVER_URL, "adc1.na.tibco.com:10389");
            </code>
            </example>
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_BASE_DN">
            <summary> Specifies the base dn, i.e where to start looking for 
            the administered objects.
            </summary>
            <example>
            <code>
              table.Add(LdapLookupConsts.LDAP_BASE_DN, "ou=people,dc=test-user");
            </code>
            </example>
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_PRINCIPAL">
            <summary> Use this property name to specify the principal (i.e the user name)
            to use while connecting to the ldap server.
            </summary>        
            <example>
            <code>
              table.Add(LdapLookupConsts.LDAP_PRINCIPAL, "cn=Manager");
            </code>
            </example>
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_CREDENTIAL">
            <summary> Use this property name to specify the credential (i.e the password)
            to use while connecting to the ldap server.
            </summary>        
            <example>
            <code>
              table.Add(LdapLookupConsts.LDAP_CREDENTIAL, "password");
            </code>
            </example>
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_SEARCH_SCOPE">
            <summary> Use this property name to specify the search scope. Acceptable values
            are "subtree" (the default) and "onelevel."
            </summary>
            <example>
            <code>
              table.Add(LdapLookupConsts.LDAP_SEARCH_SCOPE, "subtree");
            </code>
            </example>
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_CONN_TYPE">
            <summary> Use this property name to specify connection type. Aacceptable values
            are "ldap" (the default) and "ldaps."
            </summary>
            <remarks>
            <b>Note: </b>If 'ldaps' is specified for the connection type then
            the other required ssl paramaters also need to be specified.
            </remarks>
            <example>
            <code>
              table.Add(LdapLookupConsts.LDAP_CONN_TYPE, "ldaps");
            </code>
            </example>
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_CERT_NAME">
            <summary> Use this property name to specify certificate name to lookup in the
            store name at the store location.
            <para><b>Note: </b>This is required property when the
            LDAP_CONN_TYPE of ldaps is used and LDAP_SSL_PARAMS is not specified with a 
            <see cref="M:TIBCO.EMS.LdapLookupSSLParams.SetSSLQueryClientCertificateCallback(System.DirectoryServices.Protocols.QueryClientCertificateCallback)">LdapLookupSSLParams.SetSSLQueryClientCertificateCallback</see>
            method.
            </para>
            </summary>
            <example>
            <code>
              table.Add(LdapLookupConsts.LDAP_CERT_NAME, "cn=client_cert");
            </code>
            </example>
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_CERT_STORE_NAME">
            <summary> Use this property name to specify store name. The default is "My" 
            (i.e personel) store at the "currentuser" location.
            </summary>
            <example>
            <code>
              table.Add(LdapLookupConsts.LDAP_CERT_STORE_NAME, "My");
            </code>
            </example>       
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_CERT_STORE_LOCATION">
            <summary> Use this property to specify store location. Acceptable values
            are "currentuser" (the default) and "localmachine."
            </summary>
            <example>
            <code>
              table.Add(LdapLookupConsts.LDAP_CERT_STORE_LOCATION, "currentuser");
            </code>
            </example>       
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_SSL_PARAMS">
            <summary> Use this property to specify other ssl parameters namely 
            <see cref="M:TIBCO.EMS.LdapLookupSSLParams.SetSSLQueryClientCertificateCallback(System.DirectoryServices.Protocols.QueryClientCertificateCallback)">LdapLookupSSLParams.SetSSLQueryClientCertificateCallback</see> 
            and <see cref="M:TIBCO.EMS.LdapLookupSSLParams.SetSSLVerifyServerCertificateCallback(System.DirectoryServices.Protocols.VerifyServerCertificateCallback)">LdapLookupSSLParams.SetSSLVerifyServerCertifeCallback</see>.
            </summary>
            <remarks>
            <para><b>Note: </b> 
            If LDAP_SSL_PARAMS is specified with a valid query client certificate
            callback and also the certificate store location and store name
            along with the certificate name are specified then store location,
            store name, certificate name takes precedence and query client
            certificate callback is ignored. 
            </para>
            </remarks>
            <example>
            <code>
              LdapLookupSSLParams sslparams = new LdapLookupSSLParams();
              table.Add(LdapLookupConsts.LDAP_SSL_PARAMS, sslparams);
            </code>
            </example>       
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_AUTH_TYPE">
            <summary> Use this property to specify the auth type, this value
            gets used when an ldap connection is being established.
            supported values are '0' for Anonumous AuthType) and '1' for Basic
            Authype. (Default AuthType is set to Basic).
            </summary>
            <remarks>
            For more information regarding AuthType, please see 
            http://msdn2.microsoft.com/en-us/library/system.directoryservices.protocols.authtype.aspx
            </remarks>
            <example>
            <code>
              table.Add(LdapLookupConsts.LDAP_AUTH_TYPE, 1);
            </code>
            </example>       
        </member>
        <member name="F:TIBCO.EMS.LdapLookupConsts.LDAP_PROTOCOL_VERSION">
            <summary> Use this property to specify the protocol version for
            the ldap connection's session options. The values for protocol
            version can be either 2 or 3.
            </summary>
            <remarks>
            For more information regarding protocol version, please see 
            http://msdn2.microsoft.com/en-us/library/system.directoryservices.protocols.ldapsessionoptions.protocolversion.aspx
            </remarks>
            <example>
            <code>
              table.Add(LdapLookupConsts.LDAP_PROTOCOL_VERSION, 2);        
            </code>
            </example>       
        </member>
        <member name="T:TIBCO.EMS.LdapLookupContext">
            <summary> 
            This class provides an interface used to search for and perform queries 
            in a third-party LDAP server for EMS administered objects.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.LdapLookupContext.InternalSSLParms">
            internal helper class to keep ssl parameters.
        </member>
        <member name="M:TIBCO.EMS.LdapLookupContext.#ctor">
            <summary> Create a LDAP LookupContext, note this constructor
            should not be called directly. Instread the LookupContextFactory
            should be used to get an instance of LdapLookupContext.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.LdapLookupContext.#ctor(System.Collections.Hashtable)">
            <summary> Create a LDAP LookupContext, note this constructor
            should not be called directly. Instread the LookupContextFactory
            should be used to get an instance of LdapLookupContext.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.LdapLookupContext.AddSettings(System.Collections.Hashtable)">
            <summary> Add or change the lookup context settings defined in a 
            hash table.</summary>
            <remarks>
            Settings are mainly connection parameters and lookup parameters. 
            <para>Example: <see cref="F:TIBCO.EMS.LdapLookupConsts.LDAP_SERVER_URL"/>
            </para>
            </remarks>
            <param name="prop">The hash table that contains the name-value pairs used to
            set the lookup context.
            </param>
            <exception cref="T:System.ArgumentException">If the prop table is null
            </exception>
        </member>
        <member name="M:TIBCO.EMS.LdapLookupContext.AddSettings(System.String,System.Object)">
            <summary>Add or change a lookup context setting.</summary>
            <remarks>
            This method sets one lookup context property. If the property was 
            previously set, this method modifies it and returns the old value.
            <para>Examples:<see cref="F:TIBCO.EMS.LdapLookupConsts.LDAP_SERVER_URL"/>
            <see cref="F:TIBCO.EMS.LdapLookupConsts.LDAP_BASE_DN"/>
            </para>
            </remarks>
            <param name="propName">Set this single property.  
            See <see cref="F:TIBCO.EMS.LdapLookupConsts.LDAP_BASE_DN"/> for property names. </param>
            <param name="propValue">Set the single property to this value.</param>
            <exception cref="T:System.ArgumentException">If either property name or
            value are null.
            </exception>
        </member>
        <member name="P:TIBCO.EMS.LdapLookupContext.Settings">
            <summary> Return a copy of the current settings.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.LdapLookupContext.RemoveSettings(System.String)">
            <summary> Remove a setting by name
            </summary>
            <remarks>Implements 
            <see cref="M:TIBCO.EMS.ILookupContext.RemoveSettings(System.String)">ILookupContext.RemoveSettings</see>.
            </remarks>
            <param name="propName">Remove this property. For property names, see 
            <see cref="T:TIBCO.EMS.LdapLookupConsts">LdapLookupConsts</see>.
            </param>
            <exception cref="T:System.ArgumentException">If the property name is null.
            </exception>
        </member>
        <member name="M:TIBCO.EMS.LdapLookupContext.Lookup(System.String)">
             <summary> Lookup up an EMS administered object by name in an LDAP server.
             </summary>
             <remarks>
             This is an implementation of 
             <see cref="M:TIBCO.EMS.ILookupContext.Lookup(System.String)">ILookupContext.Lookup</see>. 
             The administered objects can be either EMS connection factories, topics, 
             queues stored in a third-party LDAP server.
             <para>
             <b>Note: </b>Lookup of XA connection factories is not supported.
             </para>
             <para>When looking up administered ssl connection factory object, 
             because of certain differences in the .NET ssl implementation and 
             java/c ssl implementation certain paramaters do not hold any 
             relavance in the .NET world and are ignored.</para>
             <para>The following values are supported.</para>
             <list type="bullet">
             <item>SSL Expected hostname is converted to targethostName </item>
             <item>SSL client identity (only pkcs12 file) </item>
             <item>SSL password for the private key in the pkcs12 file </item>
             <item>SSL trace </item>
             <item>SSL trusted </item>
             </list>
             The following (not complete) is the list of values ignored when
             constructing the ssl connection factory object.
             <list type="bullet">
             <item> ssl verify host </item>
             <item> ssl vendor </item>
             <item> ssl verify host name </item>
             <item> ssl issuer certs </item>
             </list>
             
             The following shows how to create and LDAP lookup context object and lookup 
             an object in an LDAP server:
             <code>
            Hashtable props = new Hashtable();
              props.Add(LdapLookupConsts.LDAP_SERVER_URL", "ldap://adc1.na.tibco.com:10389");
              props.Add(LdapLookupConsts.LDAP_BASE_DN", "ou=People,dc=users");
              props.Add(LdapLookupConsts.LDAP_PRINCIPAL", "cn=Manager');
              props.Add(LdapLookupConsts.LDAP_CREDENTIAL", "password");
              props.Add(LdapLookupConsts.LDAP_SEARCH_SCOPE, "subtree");
              props.Add(LdapLookupConsts.LDAP_CONN_TYPE", "ldaps");
            LookupContextFactory lookupCtxFactory = new LookupContextFactory();
            ILookupContext searcher = lookupCtxFactory.Create(LookupContextFactory.LDAP_CONTEXT, props);
            TIBCO.EMS.Queue queue = (TIBCO.EMS.Queue)searcher.Lookup("theQueueName");
             </code>
             </remarks>
             <param name="name">Lookup the object with this name.</param>
             <exception cref="T:System.NullReferenceException">If the name is null.
             </exception>
             <exception cref="T:TIBCO.EMS.ConfigurationException">If any of the configuration
             parameters are missing.
             </exception>
             <exception cref="T:TIBCO.EMS.NamingException">Any other error while establishing
             a connection to the ldap server or during lookup.
             </exception>
        </member>
        <member name="T:TIBCO.EMS.LdapLookupSSLParams">
            <summary> 
            Provides the query client certificate callback and the server 
            verify callback used to establish an SSL connection to the LDAP 
            server (ldaps).</summary>
            <remarks>
            The parameters set by this object are optional. The client may choose 
            to either specify the store location along with the store name and 
            certificate name, or optionally the query client certificate callback.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.LdapLookupSSLParams.#ctor">
            <summary> default constructor for creating an object of 
            this type, that will allow one to set a query client certificate
            callback and ssl server certificate verify callback.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.LdapLookupSSLParams.SetSSLQueryClientCertificateCallback(System.DirectoryServices.Protocols.QueryClientCertificateCallback)">
            <summary>
            Set the query client certificate callback to be invoked during the SSL 
            handshake with the LDAP server.</summary>
            <remarks>
            A query client certificate callback that gets invoked during the SSL 
            handshake with the ldap server, allowing the user to specify a client 
            certificate to be used for ssl handshake.
            </remarks>
            <param name="cb">The query client certificate callback.</param>
        </member>
        <member name="M:TIBCO.EMS.LdapLookupSSLParams.SetSSLVerifyServerCertificateCallback(System.DirectoryServices.Protocols.VerifyServerCertificateCallback)">
            <summary>
            Set the server certificate verify callback to be invoked during the 
            SSL handshake with the ldap server. </summary>
            <remarks>
            A server certificate verify callback if set gets invoked during the 
            SSL handshake with the ldap server. If this is not specified then 
            the client will trust any server.
            </remarks>
            <param name="cb">The server certificate verify callback.</param>
        </member>
        <member name="F:TIBCO.EMS.Link._TYPE_MULTICAST_DAEMON">
            <summary>  </summary>
            \deprecated As of release 8.3.
        </member>
        <member name="T:TIBCO.EMS.LinkSSL">
            <summary> Internal LinkSSL Class that extends the LinkTcp Class
            and uses the .NET 2.0 SSLStream for creating connections with 
            SSL peers
            </summary>
        </member>
        <member name="T:TIBCO.EMS.LookupContext">
            <summary>Search for and perform queries on administered objects in the EMS server </summary>
            <remarks>
            <para>The LookupContext class provides an interface for users to 
            search and perform queries against the naming/directory server built into EMS. 
            </para>
            <para>User can create an instance of the LookupContext and invoke the 
            <c>Lookup(string name)</c> method which returns the queried object 
            or throw a NamingException in case of failure.  The information 
            required to perform a search includes the url of the directory service 
            provider (e.g. the Tibco Enterprise Message Service Server) and user name and 
            password, if necessary.
            </para>
            <para>The following is an example of its usage:
            </para>
            <example><code>
                Hashtable env = new Hashtable();
                env.Add(LookupContext.PROVIDER_URL, "tibjmsnaming://localhost:7222");
                env.Add(LookupContext.SECURITY_PRINCIPAL", "myUserName");
                env.Add(LookupContext.SECURITY_CREDENTIALS", "myPassword");
                try { 
                    LookupContext searcher = new LookupContext(env);
                    TIBCO.EMS.Queue queue = (TIBCO.EMS.Queue)searcher.Lookup("theQueueName");
                    ...
                } catch (NamingException) {
                    ...
                }
            </code></example>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.LookupContext._JNDITYPE_PREFIX_TOPIC">
            <summary>The constant string that prefixes the name to indicate it's a topic object </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext._JNDITYPE_PREFIX_QUEUE">
            <summary>The constant string that prefixes the name to indicate it's a queue object </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext._JNDITYPE_PREFIX_FACTORY">
            <summary>The constant string that prefixes the name to indicate it's a factory object </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SYNTAX_SEPARATOR">
            <summary>The separator that separates naming server url from object name in the <c>Name</c>
            property of the <see cref="T:TIBCO.EMS.FederatedQueue"/>, <see cref="T:TIBCO.EMS.FederatedTopic"/> or
            <see cref="T:TIBCO.EMS.FederatedConnectionFactory"/> </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SYNTAX_QUOTE">
            <summary>The string constant for expressing quote in name string </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SYNTAX_ESCAPE">
            <summary>The string constant that escapes the charater that follows it in name string </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.PROVIDER_URL">
            <summary>URL of the naming server (EMS server). </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SECURITY_PRINCIPAL">
            <summary>User name of the client program. </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SECURITY_CREDENTIALS">
            <summary>User password of the client program. </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SECURITY_PROTOCOL">
            <summary> Constant that holds the name of the environment
            property for specifying the security protocol to use in Tibjms 
            JNDI lookups.  The only value currently recognized is the String
            "ssl", therefore, this property acts as a flag to turn ssl 
            encryption on or off in JNDI lookups.
            This name is defined as "TIBCO.EMS.naming.security_protocol".
            </summary>
            <remarks>
            Note: If ssl connection is needed to lookup administered objects
            then this property needs to be set.
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SSL_TRACE">
            <summary> Constant that holds the name of SSL property specifying
            if client trace is required in Tibjms JNDI lookups.
            This name is defined as "TIBCO.EMS.naming.ssl_trace".
            <see cref="F:TIBCO.EMS.EMSSSL.TRACE"/>
            </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SSL_TARGET_HOST_NAME">
            <summary> Constant that holds the name of SSL property specifying 
            the common name in the server certificate in Tibjms JNDI lookups.
            This name is defined as "TIBCO.EMS.naming.ssl_target_host_name".
            <see cref="F:TIBCO.EMS.EMSSSL.TARGET_HOST_NAME"/>
            </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SSL_AUTH_ONLY">
            <summary> Constant that holds the name of SSL property specifying if 
            client should use SSL for authentication only.
            This name is defined as "TIBCO.EMS.naming.ssl_auth_only".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SSL_HOST_NAME_VERIFIER">
            <summary> Constant that holds the name of SSL property specifying 
            the custom host name verifier in Tibjms JNDI lookups.
            This name is defined as "TIBCO.EMS.naming.ssl_hostname_verifier".
            <see cref="F:TIBCO.EMS.EMSSSL.HOST_NAME_VERIFIER"/>
            </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SSL_STORE_TYPE">
            <summary> Constant that holds the name of SSL property specifying 
            SSL Store type 
            </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SSL_STORE_INFO">
            <summary> Constant that holds the name of SSL property specifying 
            SSL Store Info 
            </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SERVER_NAME">
            <summary>The property for name of naming service </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SERVER_PORT">
            <summary>The property for port that the naming server is listening on </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.SERVER_PROTOCOL">
            <summary>The property for naming server protocol </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.URL_LIST">
            <summary>ArrayList of URLs of naming servers (EMS servers).
            <para>This property lets programs specify URLs as an ArrayList, rather 
            than as a string (as with PROVIDER_URL).</para>
            </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.URL_SEPARATOR">
            <summary>Syntactic separator between URLs in the PROVIDER_URL.</summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.URL_SCHEME_PREFIX">
            <summary>Prefix for specifying naming service provider url</summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.DEFAULT_SERVER_NAME">
            <summary> default name of the naming server is the local host</summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.DEFAULT_SERVER_PORT">
            <summary> default server port </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.DEFAULT_SERVER_PROTOCOL">
            <summary> default server protocol is tcp </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.DEFAULT_SERVER_SSL_PORT">
            <summary> default ssl protocol  </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext._lock">
            <summary>To synchronize Lookup </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext._settingLock">
            <summary>To synchronize AddSettings </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContext.settings">
            <summary>Hashtable of property settings for this namesearcher </summary>
        </member>
        <member name="M:TIBCO.EMS.LookupContext.#ctor">
            <summary> Create a new LookupContext object</summary>
            <remarks>This method creates a new lookup context without property settings.</remarks>
            <exception cref="T:TIBCO.EMS.NamingException">If error occurred in constructing a 
            Namesearcher object </exception>
        </member>
        <member name="M:TIBCO.EMS.LookupContext.#ctor(System.Collections.Hashtable)">
            <summary> Create a new LookupContext object with specific properties
            </summary>
            <remarks>This method creates a new lookup context with the given property 
            settings. The properties that are being referred to here are lookup 
            context properties required to connect naming server.</remarks>
            <param name="prop">The hashtable of property settings </param>
            <exception cref="T:TIBCO.EMS.NamingException">If error occurred in constructing a 
            Namesearcher object </exception>
        </member>
        <member name="P:TIBCO.EMS.LookupContext.Started">
            <summary>Gets or sets whether the namesearcher has already been started </summary>
            <value>true if the LookupContext is already started with current settings, false otherwise </value>
        </member>
        <member name="M:TIBCO.EMS.LookupContext.AddSettings(System.Collections.Hashtable)">
            <summary>Add or change the current LookupContext property 
            settings contained in a hash table</summary>
            <param name="prop">The hashtable containing property settings to be 
            added or changed.</param>
        </member>
        <member name="M:TIBCO.EMS.LookupContext.AddSettings(System.String,System.Object)">
             <summary>Add or change a property setting in the current LookupContext</summary>
             <param name="propName">The name of the property to add or change.</param>
             <param name="propValue">The value of the property to add; 
             or the new value, if changing.</param>
             <returns>The original value of the property, if it was changed.</returns>
            
        </member>
        <member name="P:TIBCO.EMS.LookupContext.Setttings">
            <summary>Gets a copy of the property settings. Deprecated</summary>
            <value>A copy of the hashtable that contains all property settings</value>
            \deprecated Use LookupContext.Settings instead.
        </member>
        <member name="P:TIBCO.EMS.LookupContext.Settings">
            <summary>Gets a copy of the property settings</summary>
            <value>A copy of the hashtable that contains all property settings</value>
        </member>
        <member name="M:TIBCO.EMS.LookupContext.RemoveSettings(System.String)">
            <summary>Remove a property setting from this LookupContext </summary>
            <param name="propName">The name of the property to remove. </param>
            <returns>The value of the property setting. </returns>
        </member>
        <member name="M:TIBCO.EMS.LookupContext.Request(System.Int32,System.String)">
             <summary>
            Translating request into message and send it to server
             </summary>
             <param name="type">Type of the object to request.</param>
             <param name="name">Name of the object to request.</param>
             <returns>The <c>Message</c> that is the server response
             to the request. </returns>
        </member>
        <member name="M:TIBCO.EMS.LookupContext.Close">
            <summary>Close the connection to naming server </summary>
        </member>
        <member name="M:TIBCO.EMS.LookupContext.Lookup(System.String)">
             <summary>Lookup an object in the naming server </summary>
             <remarks>
             This method provides the naming service to
             query an object by its name. 
             
             <example> 
             <para>For example:
             <code>
             
                 Hashtable env = new Hashtable();
                 env.Add(LookupContext.PROVIDER_URL, "tibjmsnaming://localhost:7222");
                 env.Add(LookupContext.SECURITY_PRINCIPAL", "myUserName");
                 env.Add(LookupContext.SECURITY_CREDENTIALS", "myPassword");
                 try {
                       LookupContext searcher = new LookupContext(env);
                       TIBCO.EMS.Queue queue = (TIBCO.EMS.Queue)searcher.Lookup("theQueueName");
                       ...
                 } catch (NamingException) {
                       ...
                 }
             </code>
             </para>
             </example>
             </remarks>
             <param name="name">The name of the object to look up from the naming server.</param>
             <returns>The named object.</returns>
             <exception cref="T:TIBCO.EMS.AuthenticationException">If authentication to the naming server has failed. </exception>
             <exception cref="T:TIBCO.EMS.ServiceUnavailableException">If the naming service is unavailable. </exception>
             <exception cref="T:TIBCO.EMS.NamingException">If the named object is not found or the 
             query to the naming service failed. </exception>
            
        </member>
        <member name="T:TIBCO.EMS.LookupContextFactory">
            <summary>Create ILookupContext objects</summary>
            
            <remarks>
            <para>To lookup administered objects (ConnectionFactories, Topics
            and Queues) in either a third-party LDAP naming 
            server or the TIBCO EMS Naming server, clients create an instance 
            of the LookupContextFactory and invoke the 
            <see cref="M:TIBCO.EMS.LookupContextFactory.CreateContext(System.String,System.Collections.Hashtable)"/> method to get an 
            <see cref="T:TIBCO.EMS.ILookupContext">ILookupContext</see> object.
            </para>
            <para>Users can create an instance of the LookupContextFactory and the
            invoke the CreateContext method to get a LDAP_CONTEXT or 
            TIBJMS_NAMING_CONTEXT object.
            </para>
            <para> Example for creating a context for looking up objects in the
            built in naming/directory server
            <example><code>
                Hashtable env = new Hashtable();
                env.Add(LookupContext.PROVIDER_URL, "tibjmsnaming://localhost:7222");
                env.Add(LookupContext.SECURITY_PRINCIPAL", "myUserName");
                env.Add(LookupContext.SECURITY_CREDENTIALS", "myPassword");
                try { 
                    LookupContextFactory factory = new LookupContextFactory();
                    ILookupContext searcher = factory.CreateContext(LookupContextFactory.TIBJMS_NAMING_CONTEXT, env);
                    TIBCO.EMS.Queue queue = (TIBCO.EMS.Queue)searcher.Lookup("theQueueName");
                    ...
                } catch (NamingException) {
                    ...
                }
            </code></example>
            </para>
            <para> This example shows how to lookup an object in the 
            LDAP server by getting an LdapLookupContext from the LookupConextFactory.
            <example><code>
                 Hashtable table = new Hashtable();
                 table.Add(LdapLookupConsts.LDAP_SERVER_URL, "10.105.185.30:10389");
                 table.Add(LdapLookupConsts.LDAP_BASE_DN, "ou=People,dc=emsproject");
                 table.Add(LdapLookupConsts.LDAP_PRINCIPAL, "cn=Manager");
                 table.Add(LdapLookupConsts.LDAP_CREDENTIAL, "password");
                 table.Add(LdapLookupConsts.LDAP_CONN_TYPE, "ldap");
                try { 
                    LookupContextFactory factory = new LookupContextFactory();
                    ILookupContext searcher = factory.CreateContext(LookupContextFactory.LDAP_CONTEXT, env);
                    TIBCO.EMS.Queue queue = (TIBCO.EMS.Queue)searcher.Lookup("theQueueName");
                    ...
                } catch (NamingException) {
                    ...
                }
            </code></example>
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.LookupContextFactory.LDAP_CONTEXT">
            <summary> Public const string to create a ldap context to lookup
            administered object in an ldap server.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.LookupContextFactory.TIBJMS_NAMING_CONTEXT">
            <summary> Public const string to create a tibjmsnaming context
            to lookup administered object inside the tibjmsnaming server.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.LookupContextFactory.#ctor">
            <summary> Default constructor to create a context factory
            </summary>
        </member>
        <member name="M:TIBCO.EMS.LookupContextFactory.CreateContext(System.String,System.Collections.Hashtable)">
            <summary>Returns the initial context used to search for administered 
            objects</summary>
            <remarks ref="true()">
            <para>This method returns an <see cref="T:TIBCO.EMS.ILookupContext">ILookupContext</see>
            object that is the initial 
            context used to look up administered object in the EMS server or 
            an LDAP server. The currently supported contexts are tibjmsnaming 
            and ldap.
            </para>
            
            <para>Before calling CreateContext, first create a hash table of properties 
            and their values. </para>
            <example>
            <para>This example demonstrates how to create an initial context for looking 
            up a queue object in the EMS naming server:</para>
            <code>
            Hashtable env = new Hashtable();
              env.Add(LookupContext.PROVIDER_URL, "tibjmsnaming://localhost:7222");
              env.Add(LookupContext.SECURITY_PRINCIPAL", "myUserName");
              env.Add(LookupContext.SECURITY_CREDENTIALS", "myPassword");
            
            LookupContextFactory factory = new LookupContextFactory();
            ILookupContext searcher = factory.CreateContext(
                                     LookupContextFactory.TIBJMS_NAMING_CONTEXT, env);
            TIBCO.EMS.Queue queue = (TIBCO.EMS.Queue)searcher.Lookup("theQueueName");
            </code>
            This example shows how to look up a connection factory, named 
            <c>testConnFact</c>, in a third-party LDAP server located at the 
            URL: 10.105.185.30:10389:
            <code>
            Hashtable env = new Hashtable();
              table.Add(LdapLookupConsts.LDAP_SERVER_URL, "10.105.185.30:10389");
              table.Add(LdapLookupConsts.LDAP_BASE_DN,"ou=People,dc=nmunjal1");
              table.Add(LdapLookupConsts.LDAP_PRINCIPAL, "cn=Manager");
              table.Add(LdapLookupConsts.LDAP_CREDENTIAL, "password");
              table.Add(LdapLookupConsts.LDAP_CONN_TYPE, "ldap");
            
            LookupContextFactory contextFactory = new LookupContextFactory();
            ILookupContext searcher = contextFactory.CreateContext(
                                      LookupContextFactory.LDAP_CONTEXT, env); 
            
            ConnectionFactory cf = (ConnectionFactory)searcher.Lookup("cn=testConnFact");
            </code>
            This example shows how to look up a connection factory object in the LDAP server via SSL.
            <code>
            Hashtable props = new Hashtable(); 
              props.Add(LdapLookupConsts.LDAP_SERVER_URL", "adc1.na.tibco.com:10636");
              props.Add(LdapLookupConsts.LDAP_BASE_DN", "ou=People,dc=test-user");
              props.Add(LdapLookupConsts.LDAP_PRINCIPAL", "cn=Manager");
              props.Add(LdapLookupConsts.LDAP_CREDENTIAL", "password");
              props.Add(LdapLookupConsts.LDAP_SEARCH_SCOPE, "subtree");
              props.Add(LdapLookupConsts.LDAP_CONN_TYPE, "ldaps");
              props.Add(LdapLookupConsts.LDAP_CERT_NAME, "certName");
              props.Add(LdapLookupConsts.LDAP_CERT_STORE_NAME, "My");
              props.Add(LdapLookupConsts.LDAP_CERT_STORE_LOCATION, "currentuser");
              
            LdapLookupSSLParams sslparams = new LdapLookupSSLParams();
            sslparams.SetSSLQueryClientCertificateCallback(QueryClientCertificateCallback);
            sslparams.SetSSLVerifyServerCertificateCallback(VerifyServerCertificateCallback);
            props.Add(LdapLookupConsts.LDAP_SSL_PARAMS, sslparams);
            
            LookupContextFactory contextFactory = new LookupContextFactory();
            ILookupContext searcher = contextFactory.CreateContext(
                                      LookupContextFactory.LDAP_CONTEXT,
                                      props);    
            ConnectionFactory cf =  searcher.Lookup("cn=testConnFact");
            Console.WriteLine("cf = " + cf.ToString());
            </code></example>
            </remarks>
            <param name="name">Can be either:
            <list type="bullet">
            <item><see cref="F:TIBCO.EMS.LookupContextFactory.TIBJMS_NAMING_CONTEXT"/> to create an initial context 
            in the EMS server.</item>
            <item><see cref="F:TIBCO.EMS.LookupContextFactory.LDAP_CONTEXT"/> to create an initial context in an 
            LDAP server.</item>
            </list></param>
            <param name="props">Hash table of properties.</param>
            <returns> An object that implements ILookupContext interface 
            </returns>
            <exception cref="T:System.ArgumentException"> If name is <c>null</c> or
            invalid name (anything other than tibjmsnaming or ldap) 
            is specified
            </exception>
        </member>
        <member name="T:TIBCO.EMS.MapMessage">
            <summary> A MapMessage object is used to send a set of name-value pairs. 
            The names are String objects, and the values are primitive data types
            in the .NET programming language. The names must have a value that is
            not null, and not an empty string. The entries can be accessed sequentially
            or randomly by name. The order of the entries is undefined. MapMessage 
            inherits from the Message interface and adds a message body that contains a Map. 
            </summary>
            <remarks ref="true()">
            <para>The primitive types can be read or written explicitly using methods
            for each type. They may also be read or written generically as objects. 
            For instance, a call to MapMessage.setInt("foo", 6) is equivalent 
            to MapMessage.setObject("foo", new Integer(6)). Both forms are provided, 
            because the explicit form is convenient for static programming, and 
            the object form is needed when types are not known at compile time. 
            </para>
            <para> When a client receives a MapMessage, it is in read-only mode.
            If a client attempts to write to the message at this point, 
            a MessageNotWriteableException is thrown. If clearBody is called,
            the message can now be both read from and written to. 
            </para>
            <para><b>Extentions</b></para>
            <para>TIBCO Enterprise Message Service extends the JMS MapMessage and 
            StreamMessage body types in two ways. These extensions allow TIBCO 
            Enterprise Message Service to exchange messages with TIBCO Rendezvous 
            programs, which have certain features not 
            available within the JMS specification. </para>
            <list type="bullet">
            <item><description> You can insert another MapMessage or StreamMessage 
            instance as a submessage into a MapMessage or StreamMessage, generating 
            a series of nested messages, instead of a flat message. </description></item>
            <item><description> You can use arrays as well as primitive types for the values.
            </description></item>
            </list>
            <para> These extensions add considerable flexibility to the two body types. 
            However, they are extensions and therefore not compliant with JMS specifications. 
            Extended messages are tagged as extensions with the vendor property tag JMS_TIBCO_MSG_EXT. </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.#ctor">
            <summary>Construct an empty map message. </summary>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.#ctor(TIBCO.EMS.Session)">
            <summary>Construct an empty map message for a session. </summary>
            <param name="session">The session of the message. </param>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.Clone">
            <summary> Implements the clone method from ICloneable interfacae </summary>
            <remarks> Makes a clone of the message.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetBoolean(System.String)">
            <summary>Returns the boolean value with the specified name. </summary>
            <param name="name">the name of the boolean </param>
            <returns>The boolean value with the specified name.
            Returns null if the message does not have a field set for the name.</returns>
            <exception cref="T:TIBCO.EMS.EMSException">if the message could not be read due to an internal error </exception>
            <exception cref="T:TIBCO.EMS.MessageFormatException">if this type conversion is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetByte(System.String)">
            <summary>Returns the byte value with the specified name. </summary>
            <param name="name">the name of the byte </param>
            <returns>The byte value with the specified name.
            Returns null if the message does not have a field set for the name.</returns>
            <exception cref="T:TIBCO.EMS.EMSException">if the message could not be read due to an internal error </exception>
            <exception cref="T:TIBCO.EMS.MessageFormatException">if this type conversion is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetShort(System.String)">
            <summary>Returns the short value with the specified name. </summary>
            <param name="name">the name of the short </param>
            <returns>The short value with the specified name.
            Returns null if the message does not have a field set for the name.</returns>
            <exception cref="T:TIBCO.EMS.EMSException">if the message could not be read due to an internal error </exception>
            <exception cref="T:TIBCO.EMS.MessageFormatException">if this type conversion is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetChar(System.String)">
            <summary>Returns the char value with the specified name. </summary>
            <param name="name">the name of the char </param>
            <returns>The char value with the specified name.
            Returns null if the message does not have a field set for the name.</returns>
            <exception cref="T:TIBCO.EMS.EMSException">if the message could not be read due to an internal error </exception>
            <exception cref="T:TIBCO.EMS.MessageFormatException">if this type conversion is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetInt(System.String)">
            <summary>Returns the int value with the specified name. </summary>
            <param name="name">the name of the int </param>
            <returns>The int value with the specified name.
            Returns null if the message does not have a field set for the name.</returns>
            <exception cref="T:TIBCO.EMS.EMSException">if the message could not be read due to an internal error </exception>
            <exception cref="T:TIBCO.EMS.MessageFormatException">if this type conversion is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetLong(System.String)">
            <summary>Returns the long value with the specified name. </summary>
            <param name="name">the name of the long </param>
            <returns>The long value with the specified name.
            Returns null if the message does not have a field set for the name.</returns>
            <exception cref="T:TIBCO.EMS.EMSException">if the message could not be read due to an internal error </exception>
            <exception cref="T:TIBCO.EMS.MessageFormatException">if this type conversion is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetFloat(System.String)">
            <summary>Returns the float value with the specified name. </summary>
            <param name="name">the name of the float </param>
            <returns>The float value with the specified name.
            Returns null if the message does not have a field set for the name.</returns>
            <exception cref="T:TIBCO.EMS.EMSException">if the message could not be read due to an internal error </exception>
            <exception cref="T:TIBCO.EMS.MessageFormatException">if this type conversion is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetDouble(System.String)">
            <summary>Returns the double value with the specified name. </summary>
            <param name="name">the name of the double </param>
            <returns>The double value with the specified name.
            Returns null if the message does not have a field set for the name.</returns>
            <exception cref="T:TIBCO.EMS.EMSException">if the message could not be read due to an internal error </exception>
            <exception cref="T:TIBCO.EMS.MessageFormatException">if this type conversion is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetString(System.String)">
            <summary>Returns the string value with the specified name. </summary>
            <param name="name">the name of the string </param>
            <returns>The string value with the specified name.
            Returns null if the message does not have a field set for the name.</returns>
            <exception cref="T:TIBCO.EMS.EMSException">if the message could not be read due to an internal error </exception>
            <exception cref="T:TIBCO.EMS.MessageFormatException">if this type conversion is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetBytes(System.String)">
            <summary>Returns the byte array value with the specified name. </summary>
            <param name="name">the name of the byte array </param>
            <returns>The byte array value with the specified name.
            Returns null if the message does not have a field set for the name.</returns>
            <exception cref="T:TIBCO.EMS.EMSException">if the message could not be read due to an internal error </exception>
            <exception cref="T:TIBCO.EMS.MessageFormatException">if this type conversion is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetObject(System.String)">
            <summary>Returns the object value with the specified name. </summary>
            <param name="name">the name of the object </param>
            <returns>The object value with the specified name.
            Returns null if the message does not have a field set for the name.</returns>
            <exception cref="T:TIBCO.EMS.EMSException">if the message could not be read due to an internal error </exception>
            <exception cref="T:TIBCO.EMS.MessageFormatException">if this type conversion is invalid.</exception>
        </member>
        <member name="P:TIBCO.EMS.MapMessage.FieldCount">
            <summary>
            Returns number of fields that this message holds.
            </summary>
            <remarks>Programs cannot set this property.</remarks>
        </member>
        <member name="P:TIBCO.EMS.MapMessage.MapNames">
            <summary> Returns an Enumeration of all the names in 
            the MapMessage object. </summary>
            <remarks>
            <para>Programs can get an enumerator that produces the names of all the data
            items in the message body.</para>
            </remarks>
            <returns>an enumeration of all the names in this MapMessage </returns>
            \deprecated Use the GetMapNames() instead, which returns a collection of names
        </member>
        <member name="M:TIBCO.EMS.MapMessage.GetMapNames">
             <summary> Returns a collection of all the names in 
             the MapMessage object. </summary>
             <returns>A collection of all the names in this MapMessage </returns>
             <remarks>
             <para>Programs can get a collection of the names of all the data
             items in the message body.</para>
             <code>
                 MapMessage mapMsg = sess.CreateMapMessage();
                 mapMsg.SetBoolean("bool1", true);
                 mapMsg.SetInt("int1", 42);
            
                 // if the user needs a collection for use in a foreach loop
                 ICollection mapNames = mapMsg.GetMapNames();
                 foreach (String name in mapNames)
                    Console.WriteLine("map name = " + name);
             
                 // if the user needs an enumerator like the old MapNames property
                 IEnumerator enumerator = mapMsg.GetMapNames().GetEnumerator();
                 while(enumerator.MoveNext())
                 {
                     String name = (String)enumerator.Current;
                     Console.WriteLine("map name = " + name);
                  }
             </code>
             </remarks>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetBoolean(System.String,System.Boolean)">
            <summary>Sets a boolean value with the specified name into the Map. </summary>
            <param name="name">The name of the boolean. Name cannot be null or an empty string. </param>
            <param name="value">The boolean value to set in the Map </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetByte(System.String,System.Byte)">
            <summary>Sets a byte value with the specified name into the Map. </summary>
            <param name="name">The name of the byte. Name cannot be null or an empty string. </param>
            <param name="value">The byte value to set in the Map </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetShort(System.String,System.Int16)">
            <summary>Sets a short value with the specified name into the Map. </summary>
            <param name="name">The name of the short. Name cannot be null or an empty string. </param>
            <param name="value">The short value to set in the Map </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetChar(System.String,System.Char)">
            <summary>Sets a char value with the specified name into the Map. </summary>
            <param name="name">The name of the char. Name cannot be null or an empty string. </param>
            <param name="value">The char value to set in the Map </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetInt(System.String,System.Int32)">
            <summary>Sets an int value with the specified name into the Map. </summary>
            <param name="name">The name of the int. Name cannot be null or an empty string. </param>
            <param name="value">The int value to set in the Map </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetLong(System.String,System.Int64)">
            <summary>Sets a long value with the specified name into the Map. </summary>
            <param name="name">The name of the long. Name cannot be null or an empty string. </param>
            <param name="value">The long value to set in the Map </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetFloat(System.String,System.Single)">
            <summary>Sets a float value with the specified name into the Map. </summary>
            <param name="name">The name of the float. Name cannot be null or an empty string. </param>
            <param name="value">The float value to set in the Map </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetDouble(System.String,System.Double)">
            <summary>Sets a double value with the specified name into the Map. </summary>
            <param name="name">The name of the double. Name cannot be null or an empty string. </param>
            <param name="value">The double value to set in the Map </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetString(System.String,System.String)">
            <summary>Sets a string value with the specified name into the Map. </summary>
            <param name="name">The name of the string </param>
            <param name="value">The string value to set in the Map </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetBytes(System.String,System.Byte[])">
            <summary>Sets a byte array value with the specified name into the Map. </summary>
            <param name="name">The name of the byte array. </param>
            <param name="value">The byte array value to set in the Map </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetBytes(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>Sets a portion of the byte array value with the specified name into the Map. </summary>
            <param name="name">The name of the boolean. </param>
            <param name="value">The byte array value to set in the Map </param>
            <param name="offset">the initial offset within the byte array </param>
            <param name="length"> the number of bytes to use </param>
            <remarks>This method extracts the specified bytes and uses them as the value; otherwise it 
            uses the entire byte array. The offset and length arguments must be between 
            zero and value.length (inclusive) and their sum must also fall within the same range. 
            That is, these two arguments must specify a span of bytes within the value argument. 
            Otherwise, this method throws an System.IndexOutOfRangeException and does not set any value.</remarks>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if 
            the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if value is null</exception>
            <exception cref="T:System.IndexOutOfRangeException">An IndexOutOfRangeException may be thrown if the 
            offset and length arguments do not specify a span of bytes within the array specified by the
            value argument.</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.SetObject(System.String,System.Object)">
            <summary>Sets an object value with the specified name into the Map. </summary>
            <param name="name">The name of the object. Name cannot be null or an empty string. </param>
            <param name="value">The object value to set in the Map </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">A MessageNotWriteableException may be thrown if the message is in read-only mode </exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.ItemExists(System.String)">
            <summary> Indicates whether an item exists in this MapMessage object. </summary>
            <param name="name">the name of the item to test </param>
            <returns>true if the item exists </returns>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.ClearBody">
            <summary> Clears out the message body. Clearing a message's body does 
            not clear its header values or property entries. 
            </summary>
            <remarks>
            <para> If this message body was read-only, calling this method leaves
            the message body in the same state as an empty body in a newly created
            message. 
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.MapMessage.ToString">
            <summary> returns a string representation of the message </summary>
            <returns> a string representation of the message </returns>
        </member>
        <member name="T:TIBCO.EMS.Message">
             <summary> Messages carry information among EMS client programs.  
             <para>
             The Message interface is the root interface of all TIBCO Enterprise Message Service 
             .NET messages. 
             It defines the message header and the acknowledge method used for all messages. 
             All other message types extend this root interface.
             </para>
             </summary>
             <remarks ref="true()">
             <para>
             The TIBCO Enterprise Message Service .NET Client API messages are composed of the following parts: 
             <list type="bullet">
             <item><description>Header - Headers associate a fixed set of header field names with values.
             Clients and providers use headers to identify and route messages. All messages support the same 
             set of header fields. </description></item>
             <item><description>Properties - Each message contains a built-in facility for supporting 
             application-defined property values. Properties associate an extensible set of property
             names with values. The EMS server uses properties to attach ancillary information to
             messages. Client applications can also use properties - for example, to customize message
             filtering. </description></item>
             <item><description>Body - The body of a message bears the information content of an application. Several types of message body organize that information in different ways. </description></item>
             </list>
             </para>
            
             <para><b>Message Bodies</b></para>
             <para>The TIBCO EMS .NET API defines five types of message body: 
             <list type="bullet">
             <item><description>Stream - A StreamMessage object's message body contains a stream of primitive values in the .NET programming language (".NET primitives"). It is filled and read sequentially. </description></item>
             <item><description>Map - A MapMessage object's message body contains a set of name-value pairs, where names are String objects, and values are .NET primitives. The entries can be accessed sequentially or randomly by name. The order of the entries is undefined. </description></item>
             <item><description>Text - A TextMessage object's message body contains a .NET String object. This message type can be used to transport plain-text messages, and XML messages.</description></item> 
             <item><description>Object - An ObjectMessage object's message body contains a Serializable .NET object. </description></item>
             <item><description>Bytes - A BytesMessage object's message body contains a stream of uninterpreted bytes. This message type is for literally encoding a body to match an existing message format. In many cases, it is possible to use one of the other body types, which are easier to use. Although the TIBCO EMS .NET API allows the use of message properties with byte messages, they are typically not used, since the inclusion of properties may affect the format.</description></item>
             </list>
             </para>
            
             <para><b>JMS Headers as .NET Properties</b></para>
             <para>These JMS headers are available as .NET properties of message objects: 
             <list type="bullet">
             <item><description>CorrelationID</description></item>
             <item><description>CorrelationIDAsBytes </description></item>
             <item><description>DeliveryMode </description></item>
             <item><description>MsgDeliveryMode </description></item>
             <item><description>Destination </description></item>
             <item><description>Expiration </description></item>
             <item><description>MessageID </description></item>
             <item><description>MsgType </description></item>
             <item><description>Priority </description></item>
             <item><description>Redelivered </description></item>
             <item><description>ReplyTo </description></item>
             <item><description>Timestamp </description></item>
             <item><description>DeliveryTime </description></item>
             </list>
             </para>
            
             </remarks>
        </member>
        <member name="F:TIBCO.EMS.Message.DEFAULT_DELIVERY_MODE">
            <summary> The message producer's default delivery mode is PERSISTENT. </summary>
            <remarks ref="true()">
            When neither the sending call nor the producer supplies a delivery mode, this default applies.
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Message.DEFAULT_MSG_DELIVERY_MODE">
            <summary> The message producer's default delivery mode is PERSISTENT. </summary>
            <remarks ref="true()">
            When neither the sending call nor the producer supplies a delivery mode, this default applies.
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Message.DEFAULT_PRIORITY">
            <summary> The message producer's default priority is 4. </summary>
            <remarks ref="true()">
            When neither the sending call nor the producer supplies a priority, this default applies.
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Message.DEFAULT_TIME_TO_LIVE">
            <summary> The message producer's default time to live is unlimited; the message never expires. </summary>
            <remarks ref="true()">
            When neither the sending call nor the producer supplies a priority, 
            this default applies. The default value, zero, indicates that messages do not expire.
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Message.emptyEnum">
            <summary> empty enum object for internal use </summary>
        </member>
        <member name="T:TIBCO.EMS.Message.EmptyEnum">
            <summary>Represents an empty enumerator </summary>
            <remarks>Messages with this body type contain a single value, which is a string.</remarks>
        </member>
        <member name="M:TIBCO.EMS.Message.EmptyEnum.#ctor">
            <summary>Construct an empty enumerator </summary>
        </member>
        <member name="M:TIBCO.EMS.Message.EmptyEnum.MoveNext">
            <summary>Advances the enumerator to the next element of the collection.</summary>
            <remarks>Implements IEnumerator.MoveNext. MoveNext() always returns false.</remarks>
            <returns>False</returns>
        </member>
        <member name="P:TIBCO.EMS.Message.EmptyEnum.Current">
            <summary>Implements IEnumerator.Current.</summary>
            <remarks>Trying to get the current object in enumerator will
            throw an <c>InvalidOperationException</c>. </remarks>
            <exception cref="T:System.InvalidOperationException">When the property is
            called. </exception>
        </member>
        <member name="M:TIBCO.EMS.Message.EmptyEnum.Reset">
            <summary>Reset the enumerator.  </summary>
             <remarks>Implements IEnumerator.Reset. Reset() does nothing since the enumerator
             is empty. </remarks>
        </member>
        <member name="P:TIBCO.EMS.Message.IsCompressed">
            <summary> THIS IS FOR INTERNAL USE ONLY </summary>
            \deprecated Use SetBooleanProperty("JMS_TIBCO_COMPRESS",true) on the Message object instead
        </member>
        <member name="P:TIBCO.EMS.Message.MessageID">
            <summary>Gets and Sets the message ID for the message. </summary>
            <remarks ref="true()">
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.Message.Timestamp">
            <summary>Gets and Sets the timestamp for the message. </summary>
            <remarks ref="true()">
            </remarks>    
        </member>
        <member name="P:TIBCO.EMS.Message.CorrelationID">
            <summary>Gets and Sets the correlation ID for the message. </summary>
            <remarks ref="true()">
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.Message.CorrelationIDAsBytes">
            <summary> Gets and Sets the correlation ID as an array of bytes
            for the message. </summary>
            <remarks ref="true()">
              <para> The use of a byte[] value for CorrelationID is 
              non-portable 
              </para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.Message.Destination">
            <summary> Gets and Sets the Destination object for this message. </summary>
            <remarks ref="true()">
              <para>
              The Destination header field contains the destination to which the
              message is being sent. 
              </para>
              <para> When a message is sent, this field is ignored. After completion of 
              the send or publish method, the field holds the destination 
              specified by the method. 
              </para>
              <para>
              When a message is received, its Destination value must be equivalent
              to the value assigned when it was sent. 
              </para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.Message.ReplyTo">
            <summary>Gets and Sets the message's replyto value. </summary>
            <remarks ref="true()">
            </remarks>    
        </member>
        <member name="P:TIBCO.EMS.Message.DeliveryMode">
            <summary> Get and set the message's delivery mode as an integer constant as defined
            in the DeliveryMode class. 
            Users are recommended to use the MessageDeliveryMode enum instead.
            </summary>
            <remarks ref="true()">
            </remarks>    
        </member>
        <member name="P:TIBCO.EMS.Message.MsgDeliveryMode">
            <summary> Get and set the message's delivery mode as enum value of type MessageDeliveryMode </summary>
            <remarks ref="true()">
            Valid values are:
            <list type="bullet">
            <item>MessageDeliveryMode.Persistent: persistent delivery</item>
            <item>MessageDeliveryMode.NonPersistent: non persistent delivery</item>
            <item>MessageDeliveryMode.ReliableDelivery:  proprietary
            extension and when used offers increased performance of the message
            producers using this mode</item>
            </list>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.Message.Redelivered">
            <summary>Gets and Sets the message's redelivered value. </summary>
            <remarks ref="true()">
            </remarks>    
        </member>
        <member name="P:TIBCO.EMS.Message.MsgType">
            <summary>Gets and Sets the message's type value. </summary>
            <remarks ref="true()">
            </remarks>    
        </member>
        <member name="P:TIBCO.EMS.Message.Expiration">
            <summary>Gets and Sets the message's expiration value. </summary>
            <remarks ref="true()">
              <para> When a message is sent, the Expiration header field is 
              left unassigned. After completion of the send or publish method, 
              it holds the expiration time of the message. This is the sum of 
              the time-to-live value specified by the client and the GMT at the 
              time of the send or publish. 
              </para>
              <para> If the time-to-live is specified as zero, Expiration is 
              set to zero to indicate that the message does not expire. 
              </para>
              <para>When a message's expiration time is reached, the system will 
              the message. The .NET API does not define any form of notification
              of message expiration. 
              </para>
              <para> Clients should not receive messages that have expired; 
              however, the .NET API does not guarantee that this will not happen
              </para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.Message.Priority">
            <summary>Gets and Sets the message's priority value. </summary>
            <remarks ref="true()">
            </remarks>    
        </member>
        <member name="P:TIBCO.EMS.Message.DeliveryTime">
            <summary>Gets the message's delivery time value. </summary>
            <remarks ref="true()">
            <para>Gets the message's delivery time value.</para>
            <para>When a message is sent, the JMSDeliveryTime header field is left unassigned.
            After completion of the send or publish method, it holds the delivery time of the message.
            This is the the difference, measured in milliseconds, between the delivery time and
            midnight, January 1, 1970 UTC.</para>
            <para>A message's delivery time is the earliest time when a JMS provider may deliver
            the message to a consumer. The provider must not deliver messages before the delivery
            time has been reached.</para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Message.Clone">
            <summary>Create a copy of the message object. </summary>
            <remarks>
            <para>Implements ICloneable.Clone.</para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Message.#ctor">
            <summary> Construct an empty message, initially writeable </summary>
        </member>
        <member name="M:TIBCO.EMS.Message.#ctor(System.Int32)">
            <summary> Construct a message of given type, initially writeable </summary>
        </member>
        <member name="M:TIBCO.EMS.Message.#ctor(TIBCO.EMS.Session)">
             <summary> Construct a message for the given session, initially writeable </summary>
            <param name="session">The session of the message. </param>
        </member>
        <member name="M:TIBCO.EMS.Message.#ctor(System.Byte[],System.Int32)">
            <summary> Construct a message given the contents in bytes and read/write mode </summary>
            <param name="bytes">Initial content of the message </param>
            <param name="readMode">Initial read/write mode of the message </param>
        </member>
        <member name="M:TIBCO.EMS.Message.CreateFromBytes(System.Byte[])">
            <summary>Create a message from bytes. </summary>
            <param name="bytes">Bytes as content of the message to create. </param>
        </member>
        <member name="M:TIBCO.EMS.Message.CreateFromBytes(System.Byte[],System.Int32)">
            <summary>Create a message from bytes and for a given read/write mode </summary>
            <param name="bytes">Bytes as content of the message to create. </param>
            <param name="mode">Initial read/write mode of the message </param>
        </member>
        <member name="M:TIBCO.EMS.Message.ClearProperties">
            <summary> Clears a message's properties. </summary>
            <remarks>
            <para> The message's header fields and body are not cleared.  The message header 
            values and body are unchanged. </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Message.PropertyExists(System.String)">
            <summary>Test whether a named property has been set on a message. </summary>
            <param name="name"> the name of the property to test </param>
            <returns>true if the property has a value on the message; otherwise returns false.</returns>
        </member>
        <member name="M:TIBCO.EMS.Message.GetBooleanProperty(System.String)">
            <summary> Returns the value of the boolean property with the 
            specified name. </summary>
            <remarks ref="true()">Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para></para> </remarks>
            <param name="name"> Get the boolean property with this name. </param>
            <returns>The boolean property value for the specified name. 
            When the message does not have a property set for the name, 
            this method returns false. </returns>
            
        </member>
        <member name="M:TIBCO.EMS.Message.GetByteProperty(System.String)">
            <summary> Returns the value of the byte property with the 
            specified name. </summary>
            <remarks ref="true()">Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para></para> </remarks>
            <param name="name"> Get the byte property with this name. </param>
            <returns>The byte property value for the specified name. When the message does not have a property set for the name, this method returns false.</returns>
        </member>
        <member name="M:TIBCO.EMS.Message.GetShortProperty(System.String)">
            <summary> Returns the value of the short property with the 
            specified name. </summary>
            <remarks ref="true()">Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must 
            not be empty strings. <para></para> </remarks>
            <param name="name"> Get the short property with this name. </param>
            <returns>The short property value for the specified name. When the message does not have a property set for the name, this method returns false. </returns>
        </member>
        <member name="M:TIBCO.EMS.Message.GetIntProperty(System.String)">
            <summary> Returns the value of the int property with the 
            specified name. </summary>
            <remarks ref="true()">Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must 
            not be empty strings. <para></para> </remarks>
            <param name="name"> Get the int property with this name. </param>
            <returns>The int property value for the specified name. When the message does not have a property set for the name, this method returns false. </returns>
        </member>
        <member name="M:TIBCO.EMS.Message.GetLongProperty(System.String)">
            <summary> Returns the value of the long property with the 
            specified name. </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para></para> </remarks>
            <param name="name"> Get the long property with this name. </param>
            <returns>The long property value for the specified name. When the message does not have a property set for the name, this method returns false. </returns>
        </member>
        <member name="M:TIBCO.EMS.Message.GetFloatProperty(System.String)">
            <summary> Returns the value of the float property with the 
            specified name. </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para></para> </remarks>
            <param name="name"> Get the float property with this name. </param>
            <returns>The float property value for the specified name. When the message does not have a property set for the name, this method returns false. </returns>
        </member>
        <member name="M:TIBCO.EMS.Message.GetDoubleProperty(System.String)">
            <summary> Returns the value of the double property with the 
            specified name. </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para></para> </remarks>
            <param name="name"> Get the double property with this name.</param>
            <returns>The double property value for the specified name. When the message does not have a property set for the name, this method returns false.</returns>
        </member>
        <member name="M:TIBCO.EMS.Message.GetStringProperty(System.String)">
            <summary> Returns the value of the string property with the 
            specified name. </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must 
            not be empty strings. <para></para> </remarks>
            <param name="name"> Get the string property with this name. </param>
            <returns>The string property value for the specified name. 
            When the message does not have a property set for the name, this method returns
            null. </returns>
        </member>
        <member name="M:TIBCO.EMS.Message.GetObjectProperty(System.String)">
            <summary> Returns the value of the object property with the 
            specified name. </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must 
            not be empty strings. <para></para> </remarks>
            <param name="name"> Get the object property with this name. </param>
            <returns>The object property value for the specified name.
            When the message does not have a property set for the name, this method returns
            null. </returns>
        </member>
        <member name="M:TIBCO.EMS.Message.GetProperty(System.String,System.Type)">
            <summary> THIS IS FOR INTERNAL USE ONLY </summary>
            \deprecated Use type-specific Get methods, e.g. GetIntProperty(), GetObjectProperty(), etc., instead.
        </member>
        <member name="P:TIBCO.EMS.Message.PropertyNames">
            <summary> Returns an Enumeration of all the property names. </summary>
            <remarks>
            <para>Note that standard header fields are not considered 
            properties and are not returned in this enumeration
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Message.SetBooleanProperty(System.String,System.Boolean)">
            <summary>Sets a boolean property value with the specified name into the message </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para> </para> </remarks>
            <param name="name">the name of the boolean property </param>
            <param name="val"> the boolean property value to set  </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">An MessageNotWriteableException may be thrown  if properties are read-only</exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.Message.SetByteProperty(System.String,System.Byte)">
            <summary>Sets a byte property value with the specified name into the message </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para> </para> </remarks>
            <param name="name">the name of the byte property </param>
            <param name="val"> the byte property value to set  </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">An MessageNotWriteableException may be thrown  if properties are read-only</exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.Message.SetShortProperty(System.String,System.Int16)">
            <summary>Sets a short property value with the specified name into the message </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para> </para> </remarks>
            <param name="name">Set the short property with this name. </param>
            <param name="val"> the short property value to set  </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">An MessageNotWriteableException may be thrown  if properties are read-only</exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.Message.SetIntProperty(System.String,System.Int32)">
            <summary>Sets a int property value with the specified name into the message </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para> </para> </remarks>
            <param name="name">the name of the int property </param>
            <param name="val"> the int property value to set  </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">An MessageNotWriteableException may be thrown  if properties are read-only</exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.Message.SetLongProperty(System.String,System.Int64)">
            <summary>Sets a long property value with the specified name into the message </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para> </para> </remarks>
            <param name="name">the name of the long property </param>
            <param name="val"> the long property value to set  </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">An MessageNotWriteableException may be thrown  if properties are read-only</exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.Message.SetFloatProperty(System.String,System.Single)">
            <summary>Sets a float property value with the specified name into the message </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para> </para> </remarks>
            <param name="name">the name of the float property </param>
            <param name="val"> the float property value to set  </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">An MessageNotWriteableException may be thrown  if properties are read-only</exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.Message.SetDoubleProperty(System.String,System.Double)">
            <summary>Sets a double property value with the specified name into the message </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para> </para> </remarks>
            <param name="name">the name of the double property </param>
            <param name="val"> the double property value to set  </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">An MessageNotWriteableException may be thrown  if properties are read-only</exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.Message.SetStringProperty(System.String,System.String)">
            <summary>Sets a string property value with the specified name into the message </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para> </para> </remarks>
            <param name="name">the name of the string property </param>
            <param name="val"> the string property value to set  </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">An MessageNotWriteableException may be thrown  if properties are read-only</exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.Message.SetObjectProperty(System.String,System.Object)">
            <summary>Sets an object property value with the specified name into the message </summary>
            <remarks ref="true()"> Property names must obey the JMS rules for a message selector identifier. 
            Property names must not be null, and must not be empty strings. <para> </para> </remarks>
            <param name="name">the name of the object property </param>
            <param name="val"> the object property value to set  </param>
            <exception cref="T:TIBCO.EMS.MessageNotWriteableException">An MessageNotWriteableException may be thrown  if properties are read-only</exception>
            <exception cref="T:System.ArgumentException">An ArgumentException may be thrown if the name is null or if the name is an empty string</exception>
        </member>
        <member name="M:TIBCO.EMS.Message.SetBytesProperty(System.String,System.Byte[])">
            <summary> FOR INTERNAL USE ONLY </summary>
        </member>
        <member name="M:TIBCO.EMS.Message.Acknowledge">
            <summary> Acknowledges all consumed messages of the session of 
            this consumed message. 
            </summary>
            
            <remarks ref="true()">
            <para>
            The behavior of this call depends on the acknowledgement mode of the Session.
            
            <para>All consumed messages support the acknowledge method 
            for use when a client has specified that its session's consumed 
            messages are to be explicitly acknowledged. By invoking acknowledge 
            on a consumed message, a client acknowledges all messages consumed 
            by the session to which the message was delivered. 
            </para>
            <para> Calls to acknowledge are ignored for both transacted sessions 
            and sessions specified to use implicit acknowledgement modes. 
            </para>
            <para> A client may individually acknowledge each message as it is 
            consumed, or it may choose to acknowledge messages as an 
            application-defined group (which is done by calling acknowledge 
            on the last received message of the group, thereby acknowledging all
            messages consumed by the session.) 
            </para>
            Specifically:
            <list type="bullet"> 
            <item><description> In ClientAcknowledge mode, this call acknowledges all messages 
            that the program has consumed within the session. (This behavior complies with the 
            JMS specification.) </description></item>
            <item><description> In ExplicitClientAcknowledge mode, this call acknowledges only the 
            individual message. (This mode and behavior are proprietary extensions, specific to TIBCO EMS.)
            </description></item>
            <item><description> In ExplicitClientDupsOkAcknowledge mode, this call lazily acknowledges 
            only the individual message. Lazy means that the provider client library can delay 
            transferring the acknowledgement to the server until a convenient time; meanwhile 
            the server might redeliver the message. (This mode and behavior are proprietary 
            extensions, specific to TIBCO EMS.)</description></item>
            <item><description> In all other modes, this call has no effect. In particular, modes 
            that specify transactions or implicit acknowledgement do not require the consuming 
            program to call this method. However, calling it does not produce an exception. 
            (This behavior complies with the JMS specification.)</description></item>
            </list> 
            </para>
            <para><b>Consumed</b></para>
            <para>Three events mark a message as consumed - that is, eligible for acknowledgment using this method:
            <list type="bullet"> 
            <item><description> Just before the provider raises an EMSMessageHandler event, it marks 
            the message argument as consumed.
            </description></item>
            <item><description> Just before the provider calls an IMessageListener.OnMessage callback, 
            it marks the message argument as consumed.
            </description></item>
            <item><description> Just before a receive call returns a message, it marks that message as consumed.
            </description></item>
            </list> 
            </para>
            <para><b>Redelivery</b></para>
            <para>Messages that have been received but not acknowledged may be redelivered.
            </para>
            </remarks>
            <exception cref="T:TIBCO.EMS.IllegalStateException">if this method is called on a closed session</exception>
            <seealso cref="M:TIBCO.EMS.MessageConsumer.Receive(System.Int64)">MessageConsumer.Receive</seealso> methods
            <seealso cref="T:TIBCO.EMS.Session">Session</seealso> class
            <seealso cref="P:TIBCO.EMS.Session.AcknowledgeMode">Session.AcknowledgeMode</seealso>
            <seealso cref="P:TIBCO.EMS.Session.SessionAcknowledgeMode">Session.SessionAcknowledgeMode</seealso>
            <seealso cref="T:TIBCO.EMS.QueueSession">QueueSession</seealso> class
        </member>
        <member name="M:TIBCO.EMS.Message.ClearBody">
            <summary> Clears out the message body. Clearing a message's body does 
            not clear its header values or property entries. 
            </summary>
            <remarks>
            <para> If this message body was read-only, calling this method leaves
            the message body in the same state as an empty body in a newly created
            message. 
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Message.GetDeliveryModeName(TIBCO.EMS.MessageDeliveryMode)">
            <remarks ref="true()">
            Convert a delivery mode constant to a string.
            <para> This method is an extension to the JMS specification.</para>
            </remarks>
            <param name="deliveryMode"> the DeliveryMode header property of the message object. </param>
        </member>
        <member name="M:TIBCO.EMS.Message.GetDeliveryModeName(System.Int32)">
            <remarks ref="true()">
            Convert a delivery mode constant to a string.
            <para> Programs can obtain the delivery mode of a message by accessing the DeliveryMode header property of the message object.</para>
            <para> This method is an extension to the JMS specification.</para>
            </remarks>
            <param name="deliveryMode"> the DeliveryMode header property of the message object. </param>
        </member>
        <member name="M:TIBCO.EMS.Message.GetTimeName(System.Int64)">
            <remarks>Time expressed in UTC </remarks>
            \deprecated Please write your own helper function to perform this task.
            @todo to be removed later
        </member>
        <member name="M:TIBCO.EMS.Message.ToString">
            <summary> returns a string representation of the message </summary>
            <remarks>The string includes the body type, headers (name-value pairs), 
            properties (name-value pairs), and body content.</remarks>
            <returns> a string representation of the message </returns>
        </member>
        <member name="T:TIBCO.EMS.EMSMessageHandler">
            <summary> Delegate declaration for message event handler</summary>
            <remarks>
            <para>This delegate provides an asynchronous pathway for receiving messages. 
            The program implements this delegate, and registers it with a MessageConsumer. 
            When a message arrives, the client library raises an event. This delegate 
            processes the event, which presents the message. </para>
            <para>
            NOTE: The message is read-only, attempting to modify the received message 
            in the handler will result in  MessageNotWriteableException. A consumer can 
            modify a received message after calling either the clearBody or 
            clearProperties method to make the body or properties writable. </para>
            <para>The EMSMessageHandler receives 
            messages in a .NET programming idiom. In contrast, IMessageListener mimics the 
            way in which JMS provides similar functionality in a Java programming idiom. 
            Programmers may select either idiom - but not both (which would cause duplicate 
            message processing, with undefined behavior).</para>
            <para><b>Example Message Event Handler:</b></para>
            <code>
            ...
            consumer.MessageHandler += new EMSMessageHandler(handleMsg);
            ...
            private void handleMsg(object sender, EMSMessageEventArgs arg)
            {
               Message m = arg.Message;
               Console.WriteLine("Received message: " + m);
               ...
            }
            ...
            </code>
            <para><b>Serialization</b></para>
            <para>In compliance with the JMS specification, sessions distribute messages 
            to listeners and event handler delegates in serial (non-concurrent) fashion.</para> 
            </remarks>
            <param name="sender">The source of the event.
            It can be either the MessageConsumer object or the Session object depending
            on to which object is the message handler registered.</param>
            <param name="args">The event argument, <see cref="T:TIBCO.EMS.EMSMessageEventArgs"/></param>
        </member>
        <member name="T:TIBCO.EMS.EMSMessageEventArgs">
            <summary> EMSMessageHandler event argument, used in TIBCO.EMS.MessageConsumer.MessageHandler. </summary>
            <remarks>
            <para>EMSMessageEventArgs presents an arriving message as a .NET event.</para>
            <para>EMSMessageHandler delegates receive this object as an argument.</para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.EMSMessageEventArgs.#ctor(TIBCO.EMS.Message)">
            <summary> Construct a new EMSMessageEventArgs</summary>
            <param name="msg">The new event encapsulates this message and signals its arrival. </param>
        </member>
        <member name="P:TIBCO.EMS.EMSMessageEventArgs.Message">
            <summary> Get the Message that tiggered the event </summary>
        </member>
        <member name="T:TIBCO.EMS.MessageConsumer">
            <summary>
            A client uses a MessageConsumer object to receive messages from a destination.
            </summary>
            <remarks ref="true()">
            <para>MessageConsumer is the parent interface for all message consumers. </para>
            <para> A MessageConsumer object is created by passing a Destination object to a 
            message-consumer creation method supplied by a session.
            A message consumer can be created with a message selector that
            allows the client to restrict the messages delivered to the message 
            consumer to those that match the selector. 
            </para>
            <para> A client may either synchronously receive a message consumer's 
            messages or have the consumer asynchronously deliver them as they arrive. 
            </para>
            <para> For synchronous receipt, a client can request the next message from 
            a message consumer using one of its receive methods. There are several 
            variations of receive that allow a client to poll or wait for the next message. 
            </para>
            
            <para> 
               Consumers can receive messages asynchronously in either of two idioms.
               Programmers may select either idiom - but not both (which would cause
               duplicate message processing with undefined behavior).
            <list type="bullet">
              <item>
                <description><b>MessageHandler</b> - see <see cref="T:TIBCO.EMS.EMSMessageHandler"/>
                   for more information.
                   The client library raises an event when a message arrives at the 
                   destination. The program implements a handler delegate to processes it
                   asynchronously, and registers the delegate here.
                </description>
              </item>
              <item>
                <description><b>MessageListener</b> - see <see cref="T:TIBCO.EMS.IMessageListener"/>
                   for more information.
                   A client can register a MessageListener object with a message consumer.
                   When a message arrives, the client library calls this listener's 
                   onMessage method with the message as its argument. The program
                   implements the message listener interface, and registers a message 
                   listener object by setting this property. The MessageListener mimics 
                   the way in which JMS provides similar functionality in a Java programming
                   idiom
                 </description>
              </item>
            </list>
            </para>
                 <para>A message selector restricts the 
                   set of messages that the consumer receives to those that match the 
                   selector. Programs can set this property only when creating the 
                   consumer object; see <see cref="M:TIBCO.EMS.Session.CreateConsumer(TIBCO.EMS.Destination,System.String)">Session.CreateConsumer</see>.
              </para>
            <para> It is a client programming error for a MessageListener to throw an exception. </para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.MessageConsumer.MessageSelector">
            <summary>Gets this message consumer's message selector expression. </summary>
            <remarks ref="true()">
            <para>
            A message selector restricts the set of messages that the consumer receives to 
            those that match the selector.
            </para><para>
            A client sets this property when calling Session.CreateConsumer 
            to create the consumer object.</para>
            </remarks>
            <returns>This message consumer's message selector, or null if no 
            message selector exists for the message consumer (that is, if 
            the message selector was not set or was set to null or the empty string). 
            </returns>
        </member>
        <member name="E:TIBCO.EMS.MessageConsumer.MessageHandler">
            <summary> The message event handler for asynchronous message consumption.</summary>
            <remarks>
            <para>
            The client library raises an event when a message arrives at the destination. 
            The program implements a handler delegate to processes it asynchronously.</para>
            The delegate declaration for message event handler is as follows: <br/>
            <code>
            public delegate void EMSMessageHandler(object sender, EMSMessageEventArgs args);
            </code>
            <br/>
            sender: The source of the event. It can be either the MessageConsumer object or 
            the Session object depending on to which object is the message handler registered.<br/>
            args: The event argument, <see cref="T:TIBCO.EMS.EMSMessageEventArgs"/><br/>
            <example>Example of using the message event handler:
            <code>
            ...
            consumer.MessageHandler += new EMSMessageHandler(handleMsg);
            ...
            private void handleMsg(object sender, EMSMessageEventArgs arg)
            {
               Message m = arg.Message;
               Console.WriteLine("Received message: " + m);
            }
            ...
            </code></example>
            User should either use MessageHandler or MessageListener
            to handle asynchronous message consumptions, but <b>not</b> both.  
            Setting up both will cause the message to be handled more than once 
            which can result in undefined behavior </remarks>
            <exception cref="T:TIBCO.EMS.IllegalStateException">If the consumer is closed</exception>
        </member>
        <member name="P:TIBCO.EMS.MessageConsumer.MessageListener">
            <summary> Get and set the asynchronous message listener</summary>
            <remarks ref="true()">
            <para>
            The client implements the MessageListener 
            interface and registers a MessageListener object by setting this property. 
            When a message arrives, the client library calls this MessageListener's onMessage 
            method with the message as its argument. 
            </para><para>
            A client can use either MessageHandler or MessageListener
            to handle asynchronous message consumptions, but <b>not</b> both.  
            Setting up both will cause the message to be handled more than once 
            which can result in undefined behavior. 
            </para>
            </remarks>
            <exception cref="T:TIBCO.EMS.IllegalStateException">If the consumer is closed</exception>
        </member>
        <member name="M:TIBCO.EMS.MessageConsumer.Receive">
            <summary>Receives the next message produced for this message consumer. </summary>
            <remarks ref="true()"> 
            <para> This method consumes the next message from the destination (synchronously).
            When the destination does not have any messages ready, this method blocks:</para>
            <list type="bullet">
            <item><description>If a message arrives at the destination, this call immediately 
            returns that message.</description></item>
            <item><description>If another thread closes the consumer, this call returns 
            null.</description></item>
            </list>
            <para>When calling receive within a transaction, the consumer retains the message 
            until transaction commits.</para>
            </remarks>
            <returns>the next message produced for this message consumer, 
            or null if this message consumer is concurrently closed </returns>
        </member>
        <member name="M:TIBCO.EMS.MessageConsumer.Receive(System.Int64)">
            <summary> Receives the next message that arrives within the specified timeout interval. 
            </summary>
            <remarks ref="true()"> 
            <para> This method consumes the next message from the destination (synchronously).
            When the destination does not have any messages ready, this method blocks:</para>
            <list type="bullet">
            <item><description>If a message arrives at the destination, this call immediately 
            returns that message.</description></item>
            <item><description>If the (non-zero) timeout elapses before a message arrives, this 
            call returns null.</description></item>
            <item><description>If another thread closes the consumer, this call returns 
            null.</description></item>
            </list>
            <para>When calling receive within a transaction, the consumer retains the message 
            until transaction commits.</para>
            </remarks>
            <param name="timeout">Wait no longer than this interval 
            (in milliseconds) for a message to arrive. Zero is a special value, 
            which specifies no timeout (block indefinitely).</param>
            <returns>the next message produced for this message consumer, 
            or null if this message consumer is concurrently closed </returns>
        </member>
        <member name="M:TIBCO.EMS.MessageConsumer.ReceiveNoWait">
            <summary> Receives the next message if one is immediately available. </summary>
            <remarks>
            <para>This method receives a message synchronously without blocking.</para>
            <para>When the destination has at least one message ready, this method immediately 
            returns the next message. When the destination does not have any messages ready, 
            this method immediately returns null. When calling receive within a transaction, 
            the consumer retains the message until transaction commits.</para>
            <para>This method should not be used if the destination property prefetch=none.</para>
            </remarks>
            <returns> the next message produced for this message consumer, 
            or null if one is not available </returns>
        </member>
        <member name="M:TIBCO.EMS.MessageConsumer.Close">
            <summary> Closes the message consumer </summary>
            <remarks>
            <para>The Close method stops the message consumer from receiving messages and 
            reclaims resources.</para>
            <para>If a receive call or a message listener is in progress, then Close waits 
            until that call returns. </para>
            <para>Message consumers rely on resources outside the 
            client program. To reclaim these resources in a timely manner, a
            client should explicitly close message consumer objects (rather than 
            waiting for garbage collection).</para>
            </remarks>
            
        </member>
        <member name="M:TIBCO.EMS.MessageConsumer.ToString">
            <summary> return a string representation of the message consumer </summary>
            <returns> a string representation of the message consumer </returns>
        </member>
        <member name="T:TIBCO.EMS.MessageEOFException">
            <summary>The data stream within a message ended unexpectedly</summary>
            <remarks>
            <see cref="T:TIBCO.EMS.BytesMessage">BytesMessage</see> 
            contains a stream of bytes. 
            <see cref="T:TIBCO.EMS.StreamMessage">StreamMessage</see> 
            contains a stream of characters. If any of their read methods detects 
            the end of the stream unexpectedly, it throws this exception.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.MessageEOFException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the MessageEOFException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.MessageEOFException.#ctor(System.String)">
            <summary> Initializes a new instance of the MessageEOFException
            with the specified reason.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.MessageFormatException">
            <summary>Datatype mismatch</summary>
            <remarks>
            This exception must be thrown when a EMS client attempts to use a 
            data type not supported by a message or attempts to read data in a
            message as the wrong type. It must also be thrown when equivalent 
            type errors are made with message property values. 
            <para>For example, this exception must be thrown if:</para>
            <list type="bullet">
            <item>A read method cannot read the data with the specified type.</item>
            <item>A write method cannot store the data in the message or property because 
            the data has the wrong type.</item>
            </list>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.MessageFormatException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the MessageFormatException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.MessageFormatException.#ctor(System.String)">
            <summary> Initializes a new instance of the MessageFormatException
            with the specified reason.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.MessageNotReadableException">
            <summary> Attempt to read from a message in write-only mode</summary>
        </member>
        <member name="M:TIBCO.EMS.MessageNotReadableException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the MessageNotReadableException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.MessageNotReadableException.#ctor(System.String)">
            <summary> Initializes a new instance of the MessageNotReadableException
            with the specified reason.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.MessageNotWriteableException">
            <summary> Attempt to write to a message in read-only mode</summary>
        </member>
        <member name="M:TIBCO.EMS.MessageNotWriteableException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the MessageNotWriteableException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.MessageNotWriteableException.#ctor(System.String)">
            <summary> Initializes a new instance of the MessageNotWriteableException
            with the specified reason.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.MessageProducer">
            <summary>Defines the root behavior of all message producers. 
            </summary>
            <remarks ref="true()">
            <para>
            A client uses a MessageProducer object to send messages to a destination.
            </para>
            <para>MessageProducer is the parent interface for all message producers. 
            A client also has the option of creating a message producer without supplying a 
            destination. In this case, a destination must be provided with every send operation.
            A typical use for this kind of message producer is to send replies to requests 
            using the request's ReplyTo destination. 
            </para>
            <para>A client can specify a default delivery mode, priority, and time to live 
            for messages sent by a message producer. It can also specify the delivery mode, 
            priority, and time to live for an individual message. 
            </para>
            <para>A client can specify a time-to-live value in milliseconds for each message it 
             sends. This value defines a message expiration time that is the sum of the 
             message's time-to-live and the GMT when it is sent (for transacted sends, this is the
             time the client sends the message, not the time the transaction is committed). 
            </para>
            <para>This class lacks a constructor. Instead, clients create message producers 
            using methods of a Session object; subclasses, such as 
            <see cref="T:TIBCO.EMS.QueueSession">QueueSession</see> and 
            <see cref="T:TIBCO.EMS.TopicSession">TopicSession</see>,
            each define methods to create corresponding producer subclasses.
            </para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.MessageProducer.Destination">
            <summary>Gets the destination associated with this MessageProducer. </summary>
            <remarks ref="true()">
            <para>Each send call directs a message to a destination (queue or topic).
            </para>
            <para>This property defines a default destination for messages that this producer 
            sends. Individual sending calls can override this default value.
            </para>
            </remarks>
            <returns>this producer's Destination </returns>
        </member>
        <member name="P:TIBCO.EMS.MessageProducer.DisableMessageID">
            <summary> Get and Sets the disable message id flag </summary>
            <remarks ref="true()">
            <para>Applications that do not require message IDs can reduce overhead 
            costs by disabling IDs (set this property to true).</para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.MessageProducer.DisableMessageTimestamp">
            <summary> Get and Sets the disable message timestamp flag </summary>
            <remarks ref="true()">
            <para>Applications that do not require timestamps can reduce overhead costs by 
            disabling timestamps (set this property to true).</para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.MessageProducer.DeliveryMode">
            <summary> Get and set the delivery mode using integer value, as defined in 
            DeliveryMode class </summary>
            <remarks ref="true()">
            <para>Delivery mode instructs the server concerning persistent storage.
            </para>
            <para>A client use this property to define a default delivery mode for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>For values, see the <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see> class.</para>
            </remarks>
            Users are recommended to use the MessageDeliveryMode enum instead.
        </member>
        <member name="P:TIBCO.EMS.MessageProducer.MsgDeliveryMode">
            <summary> Get and set the delivery mode using one of the enum <see cref="T:TIBCO.EMS.MessageDeliveryMode"/> 
            value. </summary>
            <remarks ref="true()">
            <para>This parallel property accesses the same default value as
            <see cref="P:TIBCO.EMS.MessageProducer.DeliveryMode"/>, but using enumerated values 
            (instead of ordinary integers). We recommend it over the ordinary integer-valued 
            accessor, because it enables .NET to do stronger type checking at compile time, 
            which can enhance program reliability.</para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.MessageProducer.Priority">
            <summary> Gets and Sets the priority of the message producer. </summary>
            <remarks ref="true()">
            <para>Priority affects the order in which the server delivers messages to consumers 
            (higher values first).
            </para>
            <para>The JMS specification defines ten levels of priority value, from zero (lowest priority) 
            to 9 (highest priority). The specification suggests that clients consider 0-4 as 
            gradations of normal priority, and priorities 5-9 as gradations of expedited priority.
            </para>
            <para>A client can use this property to define a default priority for messages that this 
            producer sends. Individual sending calls can override this default value.
            </para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.MessageProducer.TimeToLive">
            <summary> Gets and Sets the time to live property of the message producer. </summary>
            <remarks ref="true()">
            <para>Time-to-live (in milliseconds) determines the expiration time of a message.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.MessageProducer.DeliveryDelay">
            <summary> Gets and Sets the delivery delay property of the message producer. </summary>
            <remarks ref="true()">
            <para>Sets the minimum length of time in milliseconds that must elapse after a message is 
            sent before the JMS provider may deliver the message to a consumer.</para>
            <para>For transacted sends, this time starts when the client sends the message, not when 
            the transaction is committed.</para>
            <para>DeliveryDelay is set to zero by default.</para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Destination,TIBCO.EMS.Message)">
            <summary> Sends a message to a destination for an unidentified message producer.
            Uses the MessageProducer's default delivery mode, priority, and time to live. 
            </summary>
            <remarks ref="true()">
            <para>
              Typically, a message producer is assigned a destination at creation time; 
              however, the TIBCO EMS .NET API also supports unidentified message producers, 
              which require that the destination be supplied every time a message is sent. 
            </para>
            </remarks>
            <param name="dest">The destination (queue or topic) to send this message.</param>
            <param name="message">The message to send.</param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Destination,TIBCO.EMS.Message,TIBCO.EMS.ICompletionListener)">
            <summary> Asynchronously sends a message to a destination for an unidentified message
            producer. Uses the MessageProducer's default delivery mode, priority, and time to live.
            </summary>
            <remarks ref="true()">
            <para>
            See <see cref="T:TIBCO.EMS.ICompletionListener"/> for more information about asynchronous
            sending.
            </para>
            <para>
              Typically, a message producer is assigned a destination at creation time; 
              however, the TIBCO EMS .NET API also supports unidentified message producers, 
              which require that the destination be supplied every time a message is sent. 
            </para>
            </remarks>
            <param name="dest">The destination (queue or topic) to send this message.</param>
            <param name="message">The message to send.</param>
            <param name="completionListener"> An ICompletionListener to be notified when the send has completed.</param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Destination,TIBCO.EMS.Message,System.Int32,System.Int32,System.Int64)">
            <summary>Sends a message to a destination for an unidentified message producer,
            specifying delivery mode, priority and time to live. 
            </summary>
            <remarks ref="true()">
            <para>
            Typically, a message producer is assigned a destination at creation time; 
              however, the TIBCO EMS .NET API also supports unidentified message producers, 
              which require that the destination be supplied every time a message is sent. 
            </para>
            </remarks>
            <param name="dest">The destination (queue or topic) to send this message.</param>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.</param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para></param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Destination,TIBCO.EMS.Message,System.Int32,System.Int32,System.Int64,TIBCO.EMS.ICompletionListener)">
            <summary> Asynchronously sends a message to a destination for an unidentified
            message producer, specifying delivery mode, priority and time to live.
            </summary>
            <remarks ref="true()">
            <para>
            See <see cref="T:TIBCO.EMS.ICompletionListener"/> for more information about asynchronous
            sending.
            </para>
            <para>
            Typically, a message producer is assigned a destination at creation time; 
              however, the TIBCO EMS .NET API also supports unidentified message producers, 
              which require that the destination be supplied every time a message is sent. 
            </para>
            </remarks>
            <param name="dest">The destination (queue or topic) to send this message.</param>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.</param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para></param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
            <param name="completionListener"> An ICompletionListener to be notified when the send has completed.</param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Destination,TIBCO.EMS.Message,TIBCO.EMS.MessageDeliveryMode,System.Int32,System.Int64)">
            <summary>Sends a message to a destination for an unidentified message producer,
            specifying delivery mode, priority and time to live. 
            </summary>
            <remarks ref="true()">
            <para>
            Typically, a message producer is assigned a destination at creation time; 
              however, the TIBCO EMS .NET API also supports unidentified message producers, 
              which require that the destination be supplied every time a message is sent. 
            </para>
            </remarks>
            <param name="dest">The destination (queue or topic) to send this message.</param>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.</param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para></param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Destination,TIBCO.EMS.Message,TIBCO.EMS.MessageDeliveryMode,System.Int32,System.Int64,TIBCO.EMS.ICompletionListener)">
            <summary> Asynchronously sends a message to a destination for an unidentified
            message producer, specifying delivery mode, priority and time to live.
            </summary>
            <remarks ref="true()">
            <para>
            See <see cref="T:TIBCO.EMS.ICompletionListener"/> for more information about
            asynchronous sending.
            </para>
            <para>
            Typically, a message producer is assigned a destination at creation time; 
              however, the TIBCO EMS .NET API also supports unidentified message producers, 
              which require that the destination be supplied every time a message is sent. 
            </para>
            </remarks>
            <param name="dest">The destination (queue or topic) to send this message.</param>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.</param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para></param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
            <param name="completionListener"> An ICompletionListener to be notified when the send has completed.</param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Message)">
            <summary>Sends a message using the MessageProducer's 
            default delivery mode, priority, and time to live. </summary>
            <remarks ref="true()"></remarks>
            <param name="message">The message to send </param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Message,TIBCO.EMS.ICompletionListener)">
            <summary>Asynchronously sends a message using the MessageProducer's 
            default delivery mode, priority, and time to live. </summary>
            <remarks ref="true()">
            <para>
            See <see cref="T:TIBCO.EMS.ICompletionListener"/> for more information about
            asynchronous sending.
            </para>
            </remarks>
            <param name="message">The message to send </param>
            <param name="completionListener"> An ICompletionListener to be notified when the send has completed.</param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Message,System.Int32,System.Int32,System.Int64)">
            <summary>Sends a message to the destination, specifying delivery mode, 
            priority, and time to live. </summary>
            <remarks ref="true()"></remarks>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.</param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para></param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Message,System.Int32,System.Int32,System.Int64,TIBCO.EMS.ICompletionListener)">
            <summary>Asynchronously sends a message to the destination, specifying
            delivery mode, priority, and time to live.
            </summary>
            <remarks ref="true()">
            <para>
            See <see cref="T:TIBCO.EMS.ICompletionListener"/> for more information about
            asynchronous sending.
            </para>
            </remarks>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.</param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para></param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
            <param name="completionListener"> An ICompletionListener to be notified when the send has completed.</param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Message,TIBCO.EMS.MessageDeliveryMode,System.Int32,System.Int64)">
            <summary>Sends a message to the destination, specifying delivery mode, 
            priority, and time to live. </summary>
            <remarks ref="true()"></remarks>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.</param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para></param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Send(TIBCO.EMS.Message,TIBCO.EMS.MessageDeliveryMode,System.Int32,System.Int64,TIBCO.EMS.ICompletionListener)">
            <summary>Asynchronously sends a message to the destination, specifying
            delivery mode, priority, and time to live.
            </summary>
            <remarks ref="true()">
            <para>
            See <see cref="T:TIBCO.EMS.ICompletionListener"/> for more information about
            asynchronous sending.
            </para>
            </remarks>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.</param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para></param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
            <param name="completionListener"> An ICompletionListener to be notified when the send has completed.</param>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.Close">
            <summary> Closes the message producer. </summary>
            <remarks>
            <para>Destroy the producer object and reclaim resources.
            </para>
            <para>Message producers rely on resources outside the client program. 
            To reclaim these resources in a timely manner, we recommend that client 
            programs explicitly close message producer objects (rather than 
            waiting for garbage collection).</para>
            <para>
            This function will not return until any incomplete asynchronous
            send operations for this MessageProducer have been completed and all
            completion listener callbacks have returned. Incomplete sends will
            be allowed to complete normally unless an error occurs.
            </para>
            <para>
            A completion listener callback must not call close on its own MessageProducer. 
            Doing so will throw an IllegalStateException.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.MessageProducer.ToString">
            <summary> returns a string representaion of the message producer
            </summary>
        </member>
        <member name="T:TIBCO.EMS.NamingException">
            <summary>This is the base class for all exceptions related 
            to name lookup requests</summary>
            <remarks>Members of LookupContext throw instances of this class and 
            its subclasses.</remarks>
        </member>
        <member name="F:TIBCO.EMS.NamingException._rootCause">
            <summary>System.Exception reference to the root cause </summary>
            <remarks>When a naming exception results from a more general problem, 
            this exception details that problem.</remarks>
        </member>
        <member name="M:TIBCO.EMS.NamingException.#ctor(System.String)">
            <summary> Constructs a NamingException with the specified reason and with
            the root cause defaulting to null</summary>
            <param name="reason">a description of the exception </param>
        </member>
        <member name="P:TIBCO.EMS.NamingException.RootCause">
            <summary> Gets or sets the root cause of the exception</summary>
            <value> The exception that is the root cause of this NamingException </value>
        </member>
        <member name="T:TIBCO.EMS.CommunicationException">
            <summary> This exception is thrown when a lookup request returns bad data.</summary>
            <remarks> This exception could indicate a version mismatch between the client 
            and the EMS Server. </remarks>
        </member>
        <member name="M:TIBCO.EMS.CommunicationException.#ctor(System.String)">
            <summary> Constructs a CommunicationException with the specified reason and with
            the root cause defaulting to null. </summary>
            <param name="reason">a description of the exception </param>
        </member>
        <member name="T:TIBCO.EMS.ConfigurationException">
            <summary>This exception is thrown when the configuration of the naming service
            has caused failures</summary>
            <remarks>This exception could indicate a version mismatch between the client 
            and the EMS Server. When the client initialized the lookup context, some parameter values 
            were missing or invalid.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.ConfigurationException.#ctor(System.String)">
            <summary> Constructs a ConfigurationException with the specified reason and with
            the root cause defaulting to null. </summary>
            <param name="reason">a description of the exception </param>
        </member>
        <member name="T:TIBCO.EMS.CannotProceedException">
            <summary>This exception is thrown when the naming service cannot be proceeded
            because of insufficient information to resolve a lookup request.</summary>
            <remarks>
            A destination lookup request found both a queue and a topic with the specified name. 
            To resolve this situation, specify the destination name in one of these forms:
            <list type="bullet">
            <item>$topic:<I>topic-name></I></item>
            <item>$queue:<I>queue-name</I></item>
            </list>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.CannotProceedException.#ctor(System.String)">
            <summary> Constructs a CannotProceedException with the specified reason and with
            the root cause defaulting to null</summary>
            <param name="reason">a description of the exception </param>
        </member>
        <member name="T:TIBCO.EMS.NameNotFoundException">
            <summary>The name lookup repository cannot find a name; the name is not bound</summary>
        </member>
        <member name="M:TIBCO.EMS.NameNotFoundException.#ctor(System.String)">
            <summary> Constructs a NameNotFoundException with the specified reason and with
            the root cause defaulting to null. </summary>
            <param name="reason">a description of the exception </param>
        </member>
        <member name="T:TIBCO.EMS.ServiceUnavailableException">
            <summary>A lookup request failed because the client could not connect to 
            the server</summary>
            <remarks>
            This exception is thrown when the naming service becomes unavailable.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.ServiceUnavailableException.#ctor(System.String)">
            <summary> Constructs a ServiceUnavailableException with the specified reason and with
            the root cause defaulting to null. </summary>
            <param name="reason">a description of the exception </param>
        </member>
        <member name="T:TIBCO.EMS.InvalidNameException">
            <summary>In a lookup request, the name has incorrect syntax</summary>
            <remarks>
            This exception is thrown when the naming service url is not valid.
            The most common syntax error is a prefix other than <c>tibjmsnaming://</c>
            (or a misspelling).
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.InvalidNameException.#ctor(System.String)">
            <summary> Constructs a InvalidNameException with the specified reason and with
            the root cause defaulting to null</summary>
            <param name="reason">a description of the exception </param>
        </member>
        <member name="T:TIBCO.EMS.AuthenticationException">
            <summary>This exception is thrown when the client authentication to the naming 
            server failed because of invalid authentication or insufficient privileges for 
            a lookup request.</summary>
        </member>
        <member name="M:TIBCO.EMS.AuthenticationException.#ctor(System.String)">
            <summary> Constructs a AuthenticationException with the specified reason and with
            the root cause defaulting to null. </summary>
            <param name="reason">a description of the exception </param>
        </member>
        <member name="T:TIBCO.EMS.NamingUtil">
            <summary> Utilities for naming service </summary>
        </member>
        <member name="T:TIBCO.EMS.ObjectFactory">
            <summary>
            This is an object factory that when given a reference for a Destination
            or ConnectionFactory object, will create an instance of the corresponding
            Destination or ConnectionFactory.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.ObjectFactory.GetObjectInstance(System.Object,System.Collections.Hashtable)">
            <summary>Returns an object instance given its reference and naming service
            property settings </summary>
            <remarks> The object reference is obtained by querying naming service using 
            the <c>NameSearcher.Lookup</c> method and can be of the following type:
            <list type="bullet">
            <item>TopicName</item>
            <item>QueueName</item>
            <item>ConnectionFactoryAttributes</item>
            </list>
            </remarks>
            <param name="obj">The object refrence</param>
            <param name="prop">The hashtable that contains property settings of the 
            naming service</param>
            <returns>The object instance constructed based on reference</returns>
            <exception cref="T:System.Exception">if error occurred in constructing object
            instance</exception>
        </member>
        <member name="T:TIBCO.EMS.ObjectMessage">
            <summary>
            An ObjectMessage object is used to send a message that
            contains a serializable object. </summary>
            <remarks>
            <para>Setting the content of a MessageObject stores a snapshot of the object. 
            Subsequent changes to the original object do not affect the message.
            </para>
            <para> Object serialization differs among the various EMS language APIs in ways 
            that are incompatible. An ObjectMessage contains a serialized object. Therefore EMS 
            programs can only send an ObjectMessage to another program written in the same language; 
            for example, Java to Java, C to C, .NET to .NET.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.ObjectMessage.#ctor">
            <summary>Construct an empty object message. </summary>
        </member>
        <member name="M:TIBCO.EMS.ObjectMessage.#ctor(TIBCO.EMS.Session)">
            <summary>Construct an empty object message for a session. </summary>
            <param name="session">The session of the message. </param>
        </member>
        <member name="M:TIBCO.EMS.ObjectMessage.#ctor(TIBCO.EMS.Session,System.Object)">
            <summary>Construct an object message for a session. </summary>
            <param name="session">The session of the message. </param>
            <param name="obj">The object as the content of the message. </param>
        </member>
        <member name="M:TIBCO.EMS.ObjectMessage.Clone">
            <summary> Implements the Clone method from ICloneable interface
            </summary>
            <returns> returns the cloned object </returns>
        </member>
        <member name="P:TIBCO.EMS.ObjectMessage.TheObject">
            <summary>Gets or sets the object content of the ObjectMessage. </summary>
            <remarks>An object written to an ObjectMessage is not portable. I.e. An object
            set by an .NET EMS client will only be interpreted correctly by another .NET EMS client.
            </remarks>
            <exception cref="T:TIBCO.EMS.MessageFormatException">If the serialization or deserialization of the object failed</exception>
        </member>
        <member name="M:TIBCO.EMS.ObjectMessage.ClearBody">
            <summary> Clears out the message body. Clearing a message's body does 
            not clear its header values or property entries. 
            </summary>
            <remarks>
            <para> If this message body was read-only, calling this method leaves
            the message body in the same state as an empty body in a newly created
            message. 
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.ObjectMessage.ToString">
            <summary> Return a string representation of the message </summary>
            <returns> string representation of the message </returns>
        </member>
        <member name="M:TIBCO.EMS.ObjectMessage._SetObject(System.Object)">
            <summary> Set the value of object in the message.  
            The object must be serializable, otherwise
            a MessageFormatException will be thrown. </summary>
        </member>
        <member name="T:TIBCO.EMS.Queue">
            <summary>A Queue object encapsulates a TIBCO EMS specific queue name.</summary>
            <remarks ref="true()"><para>Queues store messages in a point-to-point messaging model
            in which each message has one producer and one consumer. 
            </para></remarks>
        </member>
        <member name="M:TIBCO.EMS.Queue.#ctor">
            <summary> Constructs a new Queue object. </summary>
        </member>
        <member name="M:TIBCO.EMS.Queue.#ctor(System.String)">
            <summary> Constructs a new Queue object with the given name.  </summary>
            <remarks><para>This is an utility provided to client so they can either create a dynamic 
            destination or obtain a destination object provided that the object with 
            the given name is already configured on the server. </para>
            <para>
            This constructor creates only local objects (within the program). It does not 
            attempt to lookup the corresponding server object until the program creates a 
            MessageConsumer or a MessageProducer that uses the queue. That automatic lookup 
            can result in either of two outcomes:</para>
            <list type="bullet">
            <item><description>If lookup succeeds, it binds the local queue object to the 
            server queue object.</description></item>
            <item><description>If lookup fails, the server creates a new dynamic queue.
            </description></item>
            </list>
            </remarks>
            <param name="name"> Find or create a queue with this name.</param>
        </member>
        <member name="M:TIBCO.EMS.Queue.#ctor(System.String,System.String)">
            <summary> Internal constructor: construct a new Queue object with the given address and jndi name </summary>
            <param name="name"> address of the queue </param>
            <param name="jndiName"> jndi name of the queue </param>
        </member>
        <member name="M:TIBCO.EMS.Queue.Clone">
            <summary>
            Implementation of ICloneable.  Overrides the cloning process.
            </summary>
            <returns>A object that is a clone of this Queue instance.
            </returns>
        </member>
        <member name="M:TIBCO.EMS.Queue.Equals(System.Object)">
            <summary> Compare with another object for equality. </summary>
            <remarks> The current instance is said to be equals to another
            object when the latter is also a <c>Queue</c> instance and
            both have the same address. </remarks>
            <param name="obj">The object to compare with </param>
            <returns>true if the object passed is also of type <c>Queue</c> and
            has the same address as the current instance, false otherwise.
            </returns>
        </member>
        <member name="M:TIBCO.EMS.Queue.GetHashCode">
            <summary>
            Returns a hashcode representing the current object
            </summary>
            <returns>A hashcode based on the <c>Queue</c>.
            </returns>
        </member>
        <member name="P:TIBCO.EMS.Queue.QueueName">
            <summary> Gets the name of the queue </summary>
            <value>The lookup name of the queue object. If not set, null is returned </value>
            <remarks> Each queue has a name that is unique among all queues.</remarks>
        </member>
        <member name="M:TIBCO.EMS.Queue.ToString">
            <summary>Returns a string representation of this <c>Queue</c> object.
            </summary>
            <returns>A string representation </returns>
        </member>
        <member name="T:TIBCO.EMS.QueueBrowser">
            <summary>Enumerate the messages in a queue without consuming them</summary>
            <remarks>
            <para>A browser is a dynamic enumerator of the queue (not a static snapshot). The contents of
            the queue on the server change as messages arrive and consumers remove them. 
            Meanwhile, a client can call the <see cref="M:TIBCO.EMS.QueueBrowser.MoveNext"/> method to
            advance the browser enumeration to the next message in the queue.
            </para>
            <para>The browser can enumerate messages in a queue, or a subset filtered by a message 
            selector. 
            </para>
            <para>Sessions serve as factories for queue browsers; see
            <see cref="T:TIBCO.EMS.Session">Session</see> or
            <see cref="T:TIBCO.EMS.QueueSession">QueueSession</see>. 
            </para>
            <para>Note that the application must close the QueueBrowser to free server resources.
            </para>
            <para>A client uses a QueueBrowser object to look at messages
            on a queue without removing them. 
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.QueueBrowser.#ctor(TIBCO.EMS.Session,TIBCO.EMS.Queue,System.String,System.Int64)">
            <summary>Construct a queue browser</summary>
            <param name="session">The session for the queue browser. </param>
            <param name="queue">The queue that the queue browser will be browsing. </param>
            <param name="selector">The browser's message selector. </param>
            <param name="consid">The consumer ID. </param>
        </member>
        <member name="M:TIBCO.EMS.QueueBrowser.MoveNext">
            <summary>Advance the browser enumeration to the next message</summary>
            <remarks>
            <para>A browser is a dynamic enumerator of the queue (not a static snapshot). 
            The queue is at the server, and its contents change as message arrive 
            and consumers remove them. Meanwhile, while the browser is at the client. 
            This method asks the server for the next message after Current, that is, 
            the next message that is still in the queue.
            </para>
            <para>After creating a browser, programs must first call this method on the enumerator to
            move to the first message. 
            </para>
            </remarks>
            <returns>True if another message exists; the <see cref="P:TIBCO.EMS.QueueBrowser.Current"/> property subsequently 
            presents the next message.  Returns false otherwise.
            </returns>
        </member>
        <member name="P:TIBCO.EMS.QueueBrowser.Current">
            <summary>Get the current message in the browser</summary>
            <remarks>
            <para>This property presents the current message in the browser enumeration, 
            but accessing the property does not consume that message.
            </para>
            <para>The <see cref="M:TIBCO.EMS.QueueBrowser.MoveNext"/> method advances the current message.
            </para>
            <para>This property can be queried repeatly and the same message 
            will be returned. 
            </para>
            </remarks>
            <returns> The current message. </returns>
            <exception cref="T:System.InvalidOperationException">If queue browser is
            closed or failure to get the current message, or message is null.
            </exception>
        </member>
        <member name="M:TIBCO.EMS.QueueBrowser.Reset">
            <summary>Reset the browser to the location just before the first message </summary>
            <exception cref="T:System.InvalidOperationException">If queue browser is
            closed or has other failure. </exception>
        </member>
        <member name="M:TIBCO.EMS.QueueBrowser.Close">
            <summary> Closes the QueueBrowser and reclaim resources </summary>
        </member>
        <member name="M:TIBCO.EMS.QueueBrowser.GetEnumerator">
            <summary> Get an enumerator for browsing the current queue messages
            in the order they would be received </summary>
            <returns> The browser object, which is itself the enumerator.</returns>
        </member>
        <member name="P:TIBCO.EMS.QueueBrowser.MessageSelector">
            <summary> Get the message selector associated with this QueueBrowser </summary>
            <remarks>The browser message selector expression filters the messages that 
            the browser presents.</remarks>
            <returns> The associated message selector, null if none is associated.</returns>
        </member>
        <member name="P:TIBCO.EMS.QueueBrowser.Queue">
            <summary> Get the queue associated with this queue browser</summary>
            <returns> The queue.</returns>
        </member>
        <member name="T:TIBCO.EMS.QueueConnection">
            <summary>
            A QueueConnection object is an active connection to a point-to-point TIBCO EMS Server.
            </summary>
            <remarks>
            <b>Note: </b>
            This class is provided for backward compatibility to support older EMS clients programs. 
            New clients should use the <see cref="T:TIBCO.EMS.Connection">Connection</see> class instead.
            <para>
            A client uses a QueueConnection object to create one or more QueueSession objects for 
            producing and consuming messages. 
            </para>
            <para> A QueueConnection can be used to create a 
            <see cref="T:TIBCO.EMS.QueueSession">QueueSession</see>, from which 
            specialized queue-related objects can be created.
            </para>
            <para> A QueueConnection cannot be used to create objects specific to the 
            publish/subscribe domain. 
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.QueueConnection.#ctor(TIBCO.EMS.CFImpl,System.String,System.String,System.String,System.String,System.Collections.Hashtable)">
            <summary>Construct a queue connection instance with information </summary>
            <param name="factory">The connection factory instance, of type
            <c>ConnectionFactory</c>, <c>QueueConnectionFactory</c>, 
            </param>
            <param name="urlString">The url for the server </param>
            <param name="clientID">The id of the client </param>
            <param name="userName">The user name of the client </param>
            <param name="password">The user password of the client </param>
            <param name="properties">The hashtable of properties for the client. </param>
        </member>
        <member name="M:TIBCO.EMS.QueueConnection.CreateQueueSession(System.Boolean,System.Int32)">
            <summary>Creates a QueueSession object.</summary>
            <remarks>
            <b>Note: </b>
            This method is provided for backward compatibility to support older EMS clients programs. 
            <para>
            The new queue session uses the connection for all server communications.
            </para>
            </remarks>
            <param name="transacted"><para>Indicates whether the session is transacted.</para>
            <para>When true, the new session has transaction semantics.</para>
            <para>When false, it has non-transaction semantics.</para>
            </param>
            <param name="acknowledgeMode"><para>Indicates whether and how the consumer  
            is to acknowledge received messages. </para>
            <para>This version of CreateQueueSession accepts an integer value associated with
            the acknowledge mode described by a <see cref="T:TIBCO.EMS.Session">Session</see> member
            and should only be used for backward compatibility.</para>
            <para>This parameter is ignored if the session is transacted. </para>
            </param>
            <returns>A newly created queue session </returns>
        </member>
        <member name="M:TIBCO.EMS.QueueConnection.CreateQueueSession(System.Boolean,TIBCO.EMS.SessionMode)">
            <summary>Creates a QueueSession object.</summary>
            <remarks>
            <b>Note: </b>
            This method is provided for backward compatibility to support older EMS clients programs. 
            <para>
            The new queue session uses the connection for all server communications.
            </para>
            </remarks>
            <param name="transacted">Indicates whether the session is transacted.
            <para>When true, the new session has transaction semantics.</para>
            <para>When false, it has non-transaction semantics.</para>
            </param>
            <param name="acknowledgeMode"><para>Indicates whether and how the consumer  
            is to acknowledge received messages. </para>
            <para>Legal values are listed under <see cref="T:TIBCO.EMS.SessionMode">SessionMode</see>.
            </para>
            <para>This parameter is ignored if the session is transacted. </para>
            </param>
            <returns>A newly created queue session </returns>
        </member>
        <member name="T:TIBCO.EMS.QueueConnectionFactory">
            <summary>Backward compatibility. Administered object for creating queue connections.</summary>
            <remarks>
            <b>Note: </b>
            This class is provided for backward compatibility to support older EMS clients programs. 
            New clients should use the <see cref="T:TIBCO.EMS.ConnectionFactory">ConnectionFactory</see> class instead.
            <para>A client uses a QueueConnectionFactory object to create QueueConnection
            objects with a point-to-point TIBCO EMS server.
            </para>
            <para>
            This class is provided only to support older clients.  New clients should use the 
            <see cref="T:TIBCO.EMS.ConnectionFactory">ConnectionFactory</see> object. 
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.QueueConnectionFactory.#ctor">
            <summary> Construct an empty QueueConnectionFactory </summary>
        </member>
        <member name="M:TIBCO.EMS.QueueConnectionFactory.#ctor(System.String)">
            <summary> Construct an QueueConnectionFactory given the server url </summary>
            <remarks> 
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The url to the server </param>
        </member>
        <member name="M:TIBCO.EMS.QueueConnectionFactory.#ctor(System.String,System.String)">
            <summary> Construct an QueueConnectionFactory given the server url, and client id </summary>
            <remarks> 
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The url to the server </param>
            <param name="clientId">The id of the client </param>
        </member>
        <member name="M:TIBCO.EMS.QueueConnectionFactory.#ctor(System.String,System.String,System.Collections.Hashtable)">
            <summary> Construct an QueueConnectionFactory given the server url, client id and
            properties </summary>
            <remarks> 
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The url to the server </param>
            <param name="clientId">The id to the client </param>
            <param name="properties">The properties for creating connection such as username and password </param>
        </member>
        <member name="M:TIBCO.EMS.QueueConnectionFactory.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> ISerializable constructor </summary>
        </member>
        <member name="M:TIBCO.EMS.QueueConnectionFactory.Clone">
            <summary>
            Implementation of ICloneable.  Overrides the Clone process.
            </summary>
            <returns>A object that is a clone of this QueueConnectionFactory instance.
            </returns>
        </member>
        <member name="M:TIBCO.EMS.QueueConnectionFactory.CreateQueueConnection">
            <summary> Create a queue connection object.  </summary>
            <remarks>The connection object presents a default user identity. If the 
            server configuration permits that user, then the call succeeds.</remarks>
            <returns>The newly created QueueConnection.</returns>
        </member>
        <member name="M:TIBCO.EMS.QueueConnectionFactory.CreateQueueConnection(System.String,System.String)">
            <summary> Create a queue connection object for a specific user.  </summary>
            <param name="userName">The username to use to create connection. </param>
            <param name="password">Authenticate the user identity with this password. </param>
            <returns>The newly created QueueConnection.</returns>
        </member>
        <member name="T:TIBCO.EMS.QueueName">
            <summary>
            A class to hold the response from the TIBCO Enterprise naming server
            in response to a queue lookup.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.QueueReceiver">
            <summary>A client uses a QueueReceiver object to receive messages 
            that have been delivered to a queue. 
            </summary>
            <remarks ref="true()">
            <para>
            This class inherits almost all of its behavior from MessageConsumer. It adds only 
            a property, specializing the generic destination to a queue.
            </para> <para>
            Although it is possible to have multiple QueueReceivers for the same queue, 
            the behavior of how messages get distributed between the QueueReceivers is undefined.
            </para>
            <para> If a QueueReceiver specifies a message selector, the messages that are 
            not selected remain on the queue. By definition, a message selector allows a 
            QueueReceiver to skip messages. This means that when the skipped messages 
            are eventually read, the total ordering of the reads does not retain the 
            partial order defined by each message producer. Only QueueReceivers without 
            a message selector will read messages in message producer order. 
            </para>
            </remarks>
            <b>Note: </b>
            This class is provided for backward compatibility to support older EMS clients programs.
            New clients should use the <see cref="T:TIBCO.EMS.MessageConsumer">MessageConsumer</see> class instead.
        </member>
        <member name="M:TIBCO.EMS.QueueReceiver.#ctor(TIBCO.EMS.Session,TIBCO.EMS.Destination,System.String)">
            <summary>Construct a new queue receiver given session, queue and selector string</summary>
             <param name="session">The session that the queue browser is on </param>
             <param name="destination">The queue destination to browse </param>
             <param name="selector">The selector string in message to browse </param>
        </member>
        <member name="P:TIBCO.EMS.QueueReceiver.Queue">
            <summary>Gets the Queue associated with this queue receiver. </summary>
            <remarks><para>The receiver consumes messages from this queue.</para>
            Programs set this queue when creating the receiver, and cannot subsequently 
            change it.
            </remarks>
            <returns>this receiver's Queue </returns>
        </member>
        <member name="T:TIBCO.EMS.QueueRequestor">
            <summary> 
            This class provides a request/reply facility for messaging over a queue, using a
            <see cref="T:TIBCO.EMS.TemporaryQueue">TemporaryQueue</see> for handling replies.
            </summary> 
            <remarks>
            <para>We recommend that clients follow these steps:</para>
            <list type="number">
            <item><description>Create a <see cref="T:TIBCO.EMS.QueueSession">QueueSession</see>, and use it to 
            create a <see cref="T:TIBCO.EMS.Queue">Queue</see> for requests.</description></item>
            <item><description>Create a QueueRequestor, using the queue session and queue as arguments.</description></item>
            <item><description>Send a request and receive a reply. You may repeat this step for several request 
            and reply pairs.</description></item>
            <item><description>Close the requestor object, when done. The <see cref="M:TIBCO.EMS.QueueRequestor.Close">Close</see> 
            method also closes the requestor's session as a side effect.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.QueueRequestor.#ctor(TIBCO.EMS.QueueSession,TIBCO.EMS.Queue)">
            <summary>
            Construct a QueueRequestor object given a queue session and queue.
            </summary>
            <param name="session"><para>The non-transacted 
            <see cref="T:TIBCO.EMS.QueueSession">QueueSession</see>.</para>
            <para>The requestor operates within this queue session.</para>
            <para>This session must not use transaction semantics. Its delivery mode must 
            be either AutoAcknowledge or DupsOkAcknowledge.</para>
            <para>The <see cref="M:TIBCO.EMS.QueueRequestor.Close">Close</see> method also closes this 
            session as a side effect.</para> 
            </param>
            <param name="queue">The queue destination on which to send a request.
            Note that this queue must belong to the <see cref="T:TIBCO.EMS.QueueSession">QueueSession</see>
            provided by the session parameter </param>
            <exception cref="T:TIBCO.EMS.EMSException">An EMSExceptin may be thrown in case of failure </exception>
        </member>
        <member name="M:TIBCO.EMS.QueueRequestor.Request(TIBCO.EMS.Message)">
            <summary> Send the request message and obtain its reply.
            </summary>
            <remarks>
            The requestor waits for and receives only the first reply. It discards other 
            replies that arrive subsequently.
            </remarks>
            <param name="message"> The request message to be sent. </param>
            <returns> The reply for the request sent. </returns>
            <exception cref="T:TIBCO.EMS.EMSException">In case of errors in sending request and receiving reply</exception>
        </member>
        <member name="M:TIBCO.EMS.QueueRequestor.Close">
            <summary> Close the QueueRequestor object.
            </summary>
            <remarks>This method also closes the <see cref="T:TIBCO.EMS.QueueSession">QueueSession</see> 
            as a side effect.</remarks>
            <exception cref="T:TIBCO.EMS.EMSException">In case of errors in closing the QueueRequestor object</exception>
        </member>
        <member name="T:TIBCO.EMS.QueueSender">
            <summary>
            A client uses a QueueSender object to send messages to a queue. 
            </summary>
            <remarks ref="true()">
            <para>This class extends <see cref="T:TIBCO.EMS.MessageProducer">MessageProducer</see>.  
            It overloads more send methods, specializing the destination parameter to a queue.
            </para>
            <para>
            Normally, the <see cref="T:TIBCO.EMS.Queue">Queue</see> is specified when a QueueSender is created. In this case, 
            an attempt to use the send methods for an unidentified QueueSender 
            will throw a UnsupportedOperationException. 
            </para>
            <para> If the QueueSender is created with an unidentified <see cref="T:TIBCO.EMS.Queue">Queue</see>, 
            an attempt to use the send methods that assume that the Queue has 
            been identified will throw a UnsupportedOperationException. 
            </para>
            <para> During the execution of its send method, a message must not 
            be changed by other threads within the client. If the message is 
            modified, the result of the send is undefined. 
            </para>
            <para>After sending a message, a client may retain and modify it 
            without affecting the message that has been sent. The same message 
            object may be sent multiple times. 
            </para>
            <para>
            The following message headers are set as part of sending a message: 
            Destination, DeliveryMode, Expiration, Priority,
            MessageID and TimeStamp. When the message is sent, 
            the values of these headers are ignored. After the completion 
            of the send, the headers hold the values specified by the method 
            sending the message. It is possible for the send method to not set the 
            MessageID and TimeStamp if they are explicitly disabled by setting the 
            <see cref="P:TIBCO.EMS.MessageProducer.DisableMessageID">MessageProducer.DisableMessageID</see> or 
            <see cref="P:TIBCO.EMS.MessageProducer.DisableMessageTimestamp">MessageProducer.DisableMessageTimestamp</see> 
            property. 
            </para>
            </remarks>
            <b>Note: </b>
            This class is provided for backward compatibility to support older EMS clients programs. 
            New clients should use the <see cref="T:TIBCO.EMS.MessageProducer">MessageProducer</see> class instead.
            
        </member>
        <member name="M:TIBCO.EMS.QueueSender.#ctor(TIBCO.EMS.Session,System.Int64,TIBCO.EMS.Queue)">
            <summary>Construct a new queue sender given session, queue and id</summary>
             <param name="session">The session that the queue sender is on </param>
             <param name="prodid">The id of this message producer </param>
             <param name="queue">The queue destination to send messages on. </param>
        </member>
        <member name="P:TIBCO.EMS.QueueSender.Queue">
            <summary> Gets the queue associated with this QueueSender. </summary>
            <remarks>
            <para>Each send call directs a message to a queue.
            </para>
            <para>A client can use this property to define a default queue for messages that this 
            producer sends. Individual sending calls can override this default value.
            </para>
            <para>A client sets this queue when creating the sender, and cannot subsequently change it.
            </para>
            </remarks>
            <returns>this sender's queue </returns>
        </member>
        <member name="M:TIBCO.EMS.QueueSender.Send(TIBCO.EMS.Message)">
            <summary> Sends a message to the queue. Uses the QueueSender's 
            default delivery mode, priority, and time to live. </summary>
            <param name="message">The message to send. </param>
        </member>
        <member name="M:TIBCO.EMS.QueueSender.Send(TIBCO.EMS.Message,System.Int32,System.Int32,System.Int64)">
            <summary> Sends a message to the queue, specifying delivery mode, 
            priority, and time to live. </summary>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.
            </param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para>
            </param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.QueueSender.Send(TIBCO.EMS.Message,TIBCO.EMS.MessageDeliveryMode,System.Int32,System.Int64)">
            <summary> Sends a message to the queue, specifying delivery mode, 
            priority, and time to live. </summary>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.</param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para></param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.QueueSender.Send(TIBCO.EMS.Queue,TIBCO.EMS.Message)">
            <summary>Sends a message to a queue for an unidentified queue sender.
            Uses the QueueSender's default delivery mode, priority, and time to live. 
            </summary>
            <remarks>
            <para>
            Typically, a message producer is assigned a queue at creation time; 
            however, the TIBCO EMS .NET API also supports unidentified message producers, 
            which require that the queue be supplied every time a message is sent. 
            </para>
            </remarks>
            <param name="queue">the queue to send this message to</param>
            <param name="message">The message to send.</param>
        </member>
        <member name="M:TIBCO.EMS.QueueSender.Send(TIBCO.EMS.Queue,TIBCO.EMS.Message,System.Int32,System.Int32,System.Int64)">
            <summary>Sends a message to a queue for an unidentified message producer.
            Uses the QueueSender's default delivery mode, priority, and time to live. 
            </summary>
            <remarks>
            <para>
            Typically, a message producer is assigned a queue at creation time; 
            however, the TIBCO EMS .NET API also supports unidentified message producers, 
            which require that the queue be supplied every time a message is sent. 
            </para>
            </remarks>
            <param name="queue">the queue to send this message to</param>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.</param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para></param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.QueueSender.Send(TIBCO.EMS.Queue,TIBCO.EMS.Message,TIBCO.EMS.MessageDeliveryMode,System.Int32,System.Int64)">
            <summary>Sends a message to a queue for an unidentified message producer.
            Uses the QueueSender's default delivery mode, priority, and time to live. 
            </summary>
            <remarks>
            <para>
            Typically, a message producer is assigned a queue at creation time; 
            however, the TIBCO EMS .NET API also supports unidentified message producers, 
            which require that the queue be supplied every time a message is sent. 
            </para>
            </remarks>
            <param name="queue">the queue to send this message to</param>
            <param name="message">The message to send.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.</param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para></param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="T:TIBCO.EMS.QueueSession">
            <summary>Session restricted to queues</summary>
            <remarks>
            <b>Note: </b>
            The QueueSession class is for backwards compatibility to support older clients.
            New clients should use the <see cref="T:TIBCO.EMS.Session">Session</see> class.
            <para>A QueueSession object provides methods for creating 
            <see cref="T:TIBCO.EMS.QueueReceiver">QueueReceiver</see>, 
            <see cref="T:TIBCO.EMS.QueueSender">QueueSender</see>,
            <see cref="T:TIBCO.EMS.QueueBrowser">QueueBrowser</see>, and
            <see cref="T:TIBCO.EMS.TemporaryQueue">TemporaryQueue</see> objects. 
            </para>
            <para>If there are messages that have been received but not acknowledged 
            when a QueueSession terminates, these messages will be retained and 
            redelivered when a consumer next accesses the queue. 
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.QueueSession.#ctor(TIBCO.EMS.Connection,System.Int64,TIBCO.EMS.SessionMode,System.Boolean,System.Boolean)">
            <summary>Construct a queue session object </summary>
            <param name="connection">The connection the session belongs to </param>
            <param name="sessid">The id of the session </param>
            <param name="acknowledgeMode">The session acknowledgment mode </param>
            <param name="isExplicit">Whether the session is explicitly acknowleging</param>
            <param name="transacted">Whether the session is transacted </param>
        </member>
        <member name="M:TIBCO.EMS.QueueSession.CreateReceiver(TIBCO.EMS.Queue)">
            <summary> Create a QueueReceiver object to receive messages from the specified queue 
            </summary>
            <param name="queue">the Queue to access </param>
        </member>
        <member name="M:TIBCO.EMS.QueueSession.CreateReceiver(TIBCO.EMS.Queue,System.String)">
            <summary> Create a QueueReceiver object to receive messages from 
            the specified queue using a message selector 
            </summary>
            <param name="queue">the Queue to access</param>
            <param name="messageSelector">only messages with properties 
            matching the message selector expression are delivered. 
            A value of null or an empty string indicates that there is 
            no message selector for the message consumer. </param>
        </member>
        <member name="M:TIBCO.EMS.QueueSession.CreateSender(TIBCO.EMS.Queue)">
            <summary> Create a QueueSender object to send messages to the specified queue 
            </summary>
            <param name="queue">the Queue to access, or null if this is an unidentified producer 
            </param>
        </member>
        <member name="T:TIBCO.EMS.ResourceAllocationException">
            <summary>Required resources are not available</summary>
            <remarks>
            This exception is thrown when a TIBCO EMS is unable to allocate 
            the resources required by a method. For example, this exception is thrown 
            when a call to 
            <see cref="M:TIBCO.EMS.TopicConnectionFactory.CreateTopicConnection">TopicConnectionFactory.CreateTopicConnection</see> 
            fails due to a lack of resources on the TIBCO EMS Server.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.ResourceAllocationException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the ResourceAllocationException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.ResourceAllocationException.#ctor(System.String)">
            <summary> Initializes a new instance of the ResourceAllocationException
            with the specified reason.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.Selector.#cctor">
            <summary>static initialization of the class </summary>
        </member>
        <member name="M:TIBCO.EMS.Selector.Promote(System.Object,System.Object)">
            
        </member>
        <member name="M:TIBCO.EMS.SelectorToken.ToStringEx">
            @todo not been used
        </member>
        <member name="T:TIBCO.EMS.SessionMode">
            <summary> Enumerate constants associated with sessions. </summary>
        </member>
        <member name="F:TIBCO.EMS.SessionMode.SessionTransacted">
            <summary> The session is transacted. 
            The IsTransacted property has this value if the session uses transaction semantics. 
            See <see cref="F:TIBCO.EMS.Session.SESSION_TRANSACTED">SESSION_TRANSACTED</see> 
            for more information.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.SessionMode.AutoAcknowledge">
            <summary> Automatic acknowledgment.  
            See <see cref="F:TIBCO.EMS.Session.AUTO_ACKNOWLEDGE">AUTO_ACKNOWLEDGE</see> for more information. </summary>
        </member>
        <member name="F:TIBCO.EMS.SessionMode.ClientAcknowledge">
            <summary> Client acknowledgment. 
            See <see cref="F:TIBCO.EMS.Session.CLIENT_ACKNOWLEDGE">CLIENT_ACKNOWLEDGE</see> 
            for more information. </summary>
        </member>
        <member name="F:TIBCO.EMS.SessionMode.DupsOkAcknowledge">
            <summary> Duplication ok acknowledgment. See <see cref="F:TIBCO.EMS.Session.DUPS_OK_ACKNOWLEDGE">DUPS_OK_ACKNOWLEDGE</see> 
            for more information. </summary>
        </member>
        <member name="F:TIBCO.EMS.SessionMode.NoAcknowledge">
            <summary>
            Defines no acknowledge acknowledge mode.
            This acknowledge mode
            is a proprietary extension and when used offers increased performance
            of the message consumers. Messages delivered to the sessions using
            this acknowledge mode do not require acknowledgement and are
            never redelivered regardless if the delivery has been successfull or not.
            See <see cref="F:TIBCO.EMS.Session.NO_ACKNOWLEDGE">NO_ACKNOWLEDGE</see> for more information.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.SessionMode.ExplicitClientAcknowledge">
            <summary>
            Defines explicit client acknowledge mode.
            This acknowledge mode is a proprietary extension.
            Sessions using this acknowledge mode must acknowledge each message
            explicitly calling the acknowledge() method for all messages.
            The application can call aknowledge() in any order.
            The general rule that acknowledging a
            message will acknowledge all previous messages does not apply. 
            See <see cref="F:TIBCO.EMS.Session.EXPLICIT_CLIENT_ACKNOWLEDGE">EXPLICIT_CLIENT_ACKNOWLEDGE</see>
            for more information.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.SessionMode.ExplicitClientDupsOkAcknowledge">
            <summary>
            Defines explicit client acknowledge mode with dups_ok.
            This acknowledge mode is a proprietary extension. This acknowledge mode
            implements the same explicit acknowledge logic as 
            the ExplicitClientAcknowledge mode. However while 
            ExplicitClientAcknowledge guarantees the success
            of the acknowledge operation upon return, this mode does not 
            and, similarly to DupsOkAcknowledge mode, acknowledges message
            lazily with the possibility that some acknowledged messages
            may be redelivered. Like for ExplicitClientAcknowledge, this mode
            requires an application to explicitly call acknowledge() method,
            in any order, for each message it wants to acknowledge. 
            See <see cref="F:TIBCO.EMS.Session.EXPLICIT_CLIENT_DUPS_OK_ACKNOWLEDGE">EXPLICIT_CLIENT_DUPS_OK_ACKNOWLEDGE</see>
            for more information.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.Session">
            <summary>A Session object is a single-threaded context for 
            producing and consuming messages. 
            </summary>
            <remarks ref="true()">
            <para>Sessions combine several roles:</para>
            <list type="bullet">
            <item>Factory for message producers and consumers.</item>
            <item>Factory for message objects.</item>
            <item>Factory for temporary destinations.</item>
            <item>Factory for dynamic destinations.</item>
            <item>Factory for queue browsers.</item>
            <item>Serializer for inbound and outbound messages.</item>
            <item>Serializer for asynchronous message events (or message listeners) of its consumer objects.</item>
            <item>Cache for inbound messages (until the program acknowledges them).</item>
            <item>Transaction support (when enabled).</item>
            </list>
            <para><b>Single Thread</b></para>
            <para>The JMS specification restricts programs to use each session within a single thread.
            </para>
            <list type="table">
            <item>
            <term>Associated Objects</term>
            <description>The same single-thread restriction applies to objects associated with a session - namely, 
            messages, message consumers, durable subscribers, message producers, queue browsers, 
            and temporary destinations (however, static and dynamic destinations are exempt 
            from this restriction).</description></item>
            <item>
            <term>Corollary</term>
            <description>One consequence of this rule is that all the consumers of a session must deliver 
            messages in the same mode - either synchronously or asynchronously.</description></item>
            <item>
            <term>Asynchronous</term>
            <description>In asynchronous delivery, the program registers message handler events or message 
            listeners with the session's consumer objects. An internal dispatcher thread delivers 
            messages to those event handlers or listeners (in all the session's consumer objects). 
            No other thread may use the session (nor objects created by the session).
            </description></item>
            <item>
            <term>Synchronous</term>
            <description>In synchronous delivery, the program explicitly begins a thread for the session. 
            That thread processes inbound messages and produces outbound messages, serializing 
            this activity among the session's producers and consumers. Methods that request the 
            next message (such as <see cref="M:TIBCO.EMS.MessageConsumer.Receive(System.Int64)">MessageConsumer.Receive</see>) 
            can organize the thread's activity.
            </description></item>
            <item>
            <term>Close</term>
            <description>The only exception to the rule restricting session calls to a single thread is the 
            method <see cref="M:TIBCO.EMS.Session.Close"/>; programs can call Close from any thread at any time.
            </description></item>
            </list>
            <para><b>Transactions</b></para>
            <para>A session has either transaction or non-transaction semantics. When a program 
            specifies transaction semantics, the session object cooperates with the server, and 
            all messages that flow through the session become part of a transaction.
            </para>
            <list type="bullet">
            <item>When the program calls <see cref="M:TIBCO.EMS.Session.Commit"/>, the session acknowledges all inbound 
            messages in the current transaction, and the server delivers all outbound messages 
            in the current transaction to their destinations.</item>
            <item>If the program calls <see cref="M:TIBCO.EMS.Session.Rollback"/>, the session recovers all inbound 
            messages in the current transaction (so the program can consume them in a new 
            transaction), and the server destroys all outbound messages in the current transaction.</item> 
            </list>
            <para>After these actions, both <see cref="M:TIBCO.EMS.Session.Commit"/> and <see cref="M:TIBCO.EMS.Session.Rollback"/> 
            immediately begin a new transaction.
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Session.SESSION_TRANSACTED">
            <summary> The session is transacted </summary>
            <remarks>
            The <see cref="P:TIBCO.EMS.Session.IsTransacted"/> property has this value (true) if the 
            session is transacted.
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Session.AUTO_ACKNOWLEDGE">
            <summary> Automatic acknowledgment </summary>
            <remarks ref="true()">
            In this mode, the session automatically acknowledges a message when message 
            processing is finished.  "Finished" in this case is when either of these methods 
            returns successfully:
            <list type="bullet">
            <item>Synchronous <see cref="M:TIBCO.EMS.MessageConsumer.Receive(System.Int64)">Receive</see> call</item>
            <item>Asynchronous listener handler <see cref="M:TIBCO.EMS.IMessageListener.OnMessage(TIBCO.EMS.Message)">OnMessage</see> 
            call</item>
            </list>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Session.CLIENT_ACKNOWLEDGE">
            <summary> Client acknowledgment </summary>
            <remarks ref="true()">
            <para>In this mode, the client program acknowledges receipt by calling 
            <see cref="M:TIBCO.EMS.Message.Acknowledge">Message.Acknowledge</see>. 
            Each call acknowledges all messages received so far.
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Session.DUPS_OK_ACKNOWLEDGE">
            <summary> Duplication ok acknowledgment </summary>
            <remarks ref="true()">
            <para>As with <see cref="F:TIBCO.EMS.Session.AUTO_ACKNOWLEDGE"/>, the session automatically acknowledges 
            messages. However, it may do so lazily. Lazy means that the provider 
            client library can delay transferring the acknowledgement to the server 
            until a convenient time; meanwhile the server might redeliver the message. 
            Lazy acknowledgement can reduce session overhead.
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Session.NO_ACKNOWLEDGE">
            <summary>No acknowledge acknowledge mode</summary>
            <remarks ref="true()">
            <para>In NO_ACKNOWLEDGE mode, messages do not require acknowledgement 
            (which reduces message overhead). The server never redelivers messages.
            This mode and behavior are proprietary extensions, specific to TIBCO EMS.
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Session.EXPLICIT_CLIENT_ACKNOWLEDGE">
            <summary>Explicit client acknowledge mode</summary>
            <remarks ref="true()">
            <para>
            As with <see cref="F:TIBCO.EMS.Session.CLIENT_ACKNOWLEDGE"/>, the client program acknowledges receipt 
            by calling <see cref="M:TIBCO.EMS.Message.Acknowledge">Message.Acknowledge</see>. 
            However, each call acknowledges only the individual message. The client may 
            acknowledge messages in any order.
            </para>
            <para>This mode and behavior are proprietary extensions, specific to TIBCO EMS.
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Session.EXPLICIT_CLIENT_DUPS_OK_ACKNOWLEDGE">
            <summary>Explicit client acknowledge mode with dups_ok</summary>
            <remarks ref="true()">
            <para>In EXPLICIT_CLIENT_DUPS_OK_ACKNOWLEDGE mode, the client program lazily 
            acknowledges only the individual message, by calling 
            <see cref="M:TIBCO.EMS.Message.Acknowledge">Message.Acknowledge</see>.
            The client may acknowledge messages in any order.
            </para>
            <para>Lazy means that the provider client library can delay transferring the 
            acknowledgement to the server until a convenient time; meanwhile the 
            server might redeliver the message.
            </para>
            <para>This mode and behavior are proprietary extensions, specific to TIBCO EMS.
            </para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.Session.Connection">
            <summary>Get the connection the session belongs to </summary>
            <value>The Connection instance </value>
        </member>
        <member name="P:TIBCO.EMS.Session.FTMode">
            <summary>Gets or set whether the session to fault tolerant mode </summary>
            <value>True if in Fault Tolerant mode, false otherwise </value>
        </member>
        <member name="P:TIBCO.EMS.Session.IsClosed">
            <summary>Get whether the session is closed. </summary>
            <value>True if session closed, false otherwise </value>
        </member>
        <member name="P:TIBCO.EMS.Session.SessID">
            <summary>Gets the id of the session. </summary>
            <value>The unique id of the sesion. </value>
        </member>
        <member name="M:TIBCO.EMS.Session.#ctor(TIBCO.EMS.Connection,System.Int64,TIBCO.EMS.SessionMode,System.Boolean,System.Boolean)">
            <summary>Construct a session object </summary>
            <param name="connection">The connection the session belongs to </param>
            <param name="sessid">The id of the session </param>
            <param name="acknowledgeMode">The session acknowledgment mode </param>
            <param name="isExplicit">Whether the session is explicitly acknowleging</param>
            <param name="transacted">Whether the session is transacted </param>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateBrowser(TIBCO.EMS.Queue)">
            <summary> Create a QueueBrowser object to peek at the messages 
            on the specified queue. </summary>
            <param name="queue">The queue to browse</param>
            <exception cref="T:TIBCO.EMS.EMSException">If the session fails to create a browser due to some internal error. </exception>
            <exception cref="T:TIBCO.EMS.InvalidDestinationException">If an invalid destination is specified </exception>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateBrowser(TIBCO.EMS.Queue,System.String)">
            <summary> Create a QueueBrowser object to peek at the messages on 
            the specified queue using a message selector. </summary>
            <param name="queue">The queue to browse</param>
            <param name="messageSelector">Only messages with properties matching 
            the message selector expression are delivered. A value of null or 
            an empty string specifies that the browser is to view all messages in the queue.</param>
            <exception cref="T:TIBCO.EMS.EMSException">If the session fails to create a browser
            due to some internal error. </exception>
            <exception cref="T:TIBCO.EMS.InvalidDestinationException">If an invalid destination is specified.</exception>
            <exception cref="T:TIBCO.EMS.InvalidSelectorException">If the message selector is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateConsumer(TIBCO.EMS.Destination)">
            <summary>Create a MessageConsumer for a specific destination. </summary>
            <remarks>
            <para>Because Queue and Topic both inherit from Destination, they can be 
            used in the destination parameter to create a MessageConsumer. 
            </para>
            <para> A client uses a MessageConsumer object to receive messages 
            that have been sent to a destination. 
            </para>
            </remarks>
            <param name="dest">The Destination to access.</param>
            <exception cref="T:TIBCO.EMS.EMSException">If the session fails to create 
            a consumer due to some internal error. </exception>
            <exception cref="T:TIBCO.EMS.InvalidDestinationException">If an invalid 
            destination is specified.</exception>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateConsumer(TIBCO.EMS.Destination,System.String)">
            <summary> Create a MessageConsumer for a specific destination,
            using a message selector. </summary>
            <remarks>
            <para>Because Queue and Topic both inherit from
            Destination, they can be used in the destination parameter to 
            create a MessageConsumer. 
            </para>
            <para> A client uses a MessageConsumer object to receive messages 
            that have been sent to a destination. 
            </para>
            </remarks>
            <param name="dest">The Destination to access.</param>
            <param name="messageSelector">Only messages with properties matching 
            the message selector expression are delivered. A value of null 
            or an empty string indicates that the message consumer is to receive all 
            messages. </param>
            <exception cref="T:TIBCO.EMS.EMSException">If the session fails to create 
            a consumer due to some internal error. </exception>
            <exception cref="T:TIBCO.EMS.InvalidDestinationException">If an invalid 
            destination is specified.</exception>
            <exception cref="T:TIBCO.EMS.InvalidSelectorException">If the message selector is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateConsumer(TIBCO.EMS.Destination,System.String,System.Boolean)">
            <summary>Create MessageConsumer for the specified destination, 
            using a message selector. This method can specify whether messages
            published by its own connection should be delivered to it, 
            if the destination is a topic </summary>
            <remarks>
            <para>
            Since Queue and Topic both inherit from Destination, they can be 
            used in the destination parameter to create a MessageConsumer. 
            </para>
            <para> A client uses a MessageConsumer object to receive messages 
            that have been sent to a destination. 
            </para>
            </remarks>
            <param name="dest">The Destination to access</param>
            <param name="messageSelector">Only messages with properties matching 
            the message selector expression are delivered. A value of null 
            or an empty string indicates that the message consumer is to receive all 
            messages. </param>
            <param name="noLocal">When true, the server filters messages so the consumer 
            does not receive messages that originate locally -- that is, messages sent through 
            the same connection.
            <para>When absent or false, the consumer receives messages with local origin.
            </para>
            </param>
            <exception cref="T:TIBCO.EMS.EMSException">If the session fails to create 
            a consumer due to some internal error. </exception>
            <exception cref="T:TIBCO.EMS.InvalidDestinationException">If an invalid 
            destination is specified.</exception>
            <exception cref="T:TIBCO.EMS.InvalidSelectorException">If the message selector is invalid.</exception>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateTemporaryTopic">
            <summary> Create a TemporaryTopic object </summary>
            <remarks>A temporary topic lasts no longer than 
            the <see cref="T:TIBCO.EMS.Connection">Connection</see> object. 
            That is, when the connection is closed or broken, the server deletes 
            temporary topic associated with the connection.
            </remarks>
            <returns> A TemporaryTopic object </returns>
            <exception cref="T:TIBCO.EMS.EMSException">If the session fails to create a temporary topic 
            due to some internal error.</exception>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateTemporaryQueue">
             <summary> Create a TemporaryQueue object </summary>
             <remarks> A temporary queue lasts no longer than the connection. That is, when the
             connection is closed or broken, the server deletes temporary queues associated
             with the connection.</remarks>
             <returns> a temporary queue identity </returns>
             <exception cref="T:TIBCO.EMS.EMSException">if the session fails to create a temporary queue 
            due to some internal error.</exception>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateDurableSubscriber(TIBCO.EMS.Topic,System.String)">
            <summary> Create a durable subscriber to the specified topic </summary>
            <remarks ref="true()">
            <para>
            The server associates a durable subscription with at most one subscriber object 
            at a time. When a subscriber object exists, the subscription is active, and the 
            server delivers messages to it; when no subscriber object exists, the subscription 
            is inactive.</para>
            <para>
            Durable subscriptions guarantee message delivery across periods during which the 
            subscriber is inactive. The server retains unacknowledged messages until the subscriber 
            acknowledges them, or until the messages expire.</para> 
            <para><b>Subscription Continuity</b></para>
            <para>Continuity across inactive periods uses two data items from the client:
            </para>
            <list type="bullet">
            <item>Subscription Name  a parameter of this method</item>
            <item>Client ID  an optional property of the Connection (used only when supplied)</item>
            </list>
            <para>
            The server uses one or both of these two items to match a subscriber object with 
            its subscription. If a matching subscription exists, and it is inactive, then the 
            server associates it with the subscriber (and the subscription becomes active). 
            The server delivers unacknowledged messages to the subscriber.
            </para>
            <para>If a matching subscription exists, but it is already active, this method throws 
            EMSException.
            </para>
            <para>If a matching subscription to the topic does not yet exist, the server creates one.
            </para>
            <para><b>Matching Client ID</b></para>
            <para>If the Connection's client ID is non-null when a session creates a durable 
            subscription, then only sessions of a connection with the same client ID can 
            attach to that subscription.
            </para>
            <para>If the Connection's client ID is null when a session creates a durable subscription, 
            then any session can attach to that subscription (to receive its messages).
            </para>
            <para><b>Changing Topic</b></para>
            
            <para>Notice that the server does not use the topic argument to match 
            a subscriber to an existing subscription. As a result, client programs can change a 
            subscription by altering the topic. The effect is equivalent 
            to deleting the existing subscription (from the server) and creating a new one (albeit 
            with the same client ID and subscription name).
            </para>
            </remarks>
            <param name="topic">Create a durable subscriber for this topic (which cannot 
            be a TemporaryTopic)</param>
            <param name="name">This unique name lets the server associate the subscriber 
            with a subscription.</param>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateDurableSubscriber(TIBCO.EMS.Topic,System.String,System.String,System.Boolean)">
            <summary> Create a durable subscriber to the specified topic, 
            using a message selector and specifying whether messages published 
            by its own connection should be delivered to it. 
            </summary>
            <remarks ref="true()">
            <para>
            The server associates a durable subscription with at most one subscriber object 
            at a time. When a subscriber object exists, the subscription is active, and the 
            server delivers messages to it; when no subscriber object exists, the subscription 
            is inactive.</para>
            <para>
            Durable subscriptions guarantee message delivery across periods during which the 
            subscriber is inactive. The server retains unacknowledged messages until the subscriber 
            acknowledges them, or until the messages expire.</para> 
            <para><b>Subscription Continuity</b></para>
            <para>Continuity across inactive periods uses two data items from the client:
            </para>
            <list type="bullet">
            <item>Subscription Name  a parameter of this method</item>
            <item>Client ID  an optional property of the Connection (used only when supplied)</item>
            </list>
            <para>
            The server uses one or both of these two items to match a subscriber object with 
            its subscription. If a matching subscription exists, and it is inactive, then the 
            server associates it with the subscriber (and the subscription becomes active). 
            The server delivers unacknowledged messages to the subscriber.
            </para>
            <para>If a matching subscription exists, but it is already active, this method throws 
            EMSException.
            </para>
            <para>If a matching subscription to the topic does not yet exist, the server creates one.
            </para>
            <para><b>Matching Client ID</b></para>
            <para>If the Connection's client ID is non-null when a session creates a durable 
            subscription, then only sessions of a connection with the same client ID can 
            attach to that subscription.
            </para>
            <para>If the Connection's client ID is null when a session creates a durable subscription, 
            then any session can attach to that subscription (to receive its messages).
            </para>
            <para><b>Changing Topic or Selector</b></para>
            
            <para>Notice that the server does not use the topic and message selector arguments to match 
            a subscriber to an existing subscription. As a result, client programs can change a 
            subscription by altering either or both of these arguments. The effect is equivalent 
            to deleting the existing subscription (from the server) and creating a new one (albeit 
            with the same client ID and subscription name).
            </para>
            </remarks>
            <param name="topic">Create a durable subscriber for this topic (which cannot 
            be a TemporaryTopic)</param>
            <param name="name">This unique name lets the server associate the subscriber 
            with a subscription.</param>
            <param name="messageSelector">When present, the server filters messages using this 
            selector, so the subscriber receives only matching messages. (See "Message Selectors" in the 
            <I>TIBCO Enterprise Message Service User's Guide</I>.)
            <para>When absent, null, or the empty string, the subscriber receives messages 
            without filtering.</para></param>
            <param name="noLocal">When true, the server filters messages so the subscriber does 
            not receive messages that originate locally - that is, messages sent through the 
            same connection.
            <para>
            When absent or false, the consumer receives messages with local origin.</para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateSharedConsumer(TIBCO.EMS.Topic,System.String)">
            <summary> Create a shared non-durable subscription (with the specified 
            name on the specified topic - if one does not already exist), and 
            a consumer on that subscription.
            </summary>
            <remarks ref="true()">
            <para>
            If a shared non-durable subscription already exists with the same name
            and client identifier (if set), and the same topic and message 
            selector value has been specified, then this method creates a 
            <see cref="T:TIBCO.EMS.MessageConsumer"/> on the existing subscription.
            </para>
            <para>
            A non-durable shared subscription is used by a client which needs to 
            be able to share the work of receiving messages from a topic 
            subscription amongst multiple consumers. A non-durable shared 
            subscription may therefore have more than one consumer. Each 
            message from the subscription will be delivered to only one of 
            the consumers on that subscription. Such a subscription is not 
            persisted and will be deleted (together with any undelivered messages 
            associated with it) when there are no consumers on it. The term 
            "consumer" here means a MessageConsumer on any client.
            </para>
            <para> 
            A shared non-durable subscription is identified by a name specified by
            the client and by the client identifier (which may be unset). An 
            application which subsequently wishes to create a consumer on that 
            shared non-durable subscription must use the same client identifier.
            </para>
            <para>
            If a shared non-durable subscription already exists with the same name 
            and client identifier (if set) but a different topic or message 
            selector has been specified, and there is a consumer already active 
            (i.e. not closed) on the subscription, then an EMSException will be 
            thrown.
            </para>
            <para>
            There is no restriction on durable subscriptions and shared non-durable
            subscriptions having the same name and clientId (which may be unset). 
            Such subscriptions would be completely separate.
            </para>
            </remarks>
            <param name="topic">the <see cref="T:TIBCO.EMS.Topic"/> to subscribe to
            </param>
            <param name="sharedSubscriptionName">the name used to identify the 
            shared non-durable subscription
            </param>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateSharedConsumer(TIBCO.EMS.Topic,System.String,System.String)">
            <summary> Create a shared non-durable subscription (with the specified 
            name on the specified topic - if one does not already exist), and a 
            consumer on that subscription, using the specidied message selector.
            </summary>
            <remarks ref="true()">
            <para>
            If a shared non-durable subscription already exists with the same name
            and client identifier (if set), and the same topic and message 
            selector value has been specified, then this method creates a 
            <see cref="T:TIBCO.EMS.MessageConsumer"/> on the existing subscription.
            </para>
            <para>
            A non-durable shared subscription is used by a client which needs to 
            be able to share the work of receiving messages from a topic 
            subscription amongst multiple consumers. A non-durable shared 
            subscription may therefore have more than one consumer. Each 
            message from the subscription will be delivered to only one of 
            the consumers on that subscription. Such a subscription is not 
            persisted and will be deleted (together with any undelivered messages 
            associated with it) when there are no consumers on it. The term 
            "consumer" here means a MessageConsumer on any client.
            </para>
            <para> 
            A shared non-durable subscription is identified by a name specified by
            the client and by the client identifier (which may be unset). An 
            application which subsequently wishes to create a consumer on that 
            shared non-durable subscription must use the same client identifier.
            </para>
            <para>
            If a shared non-durable subscription already exists with the same name 
            and client identifier (if set) but a different topic or message 
            selector has been specified, and there is a consumer already active 
            (i.e. not closed) on the subscription, then an EMSException will be 
            thrown.
            </para>
            <para>
            There is no restriction on durable subscriptions and shared non-durable
            subscriptions having the same name and clientId (which may be unset). 
            Such subscriptions would be completely separate.
            </para>
            </remarks>
            <param name="topic">the <see cref="T:TIBCO.EMS.Topic"/> to subscribe to
            </param>
            <param name="sharedSubscriptionName">the name used to identify the 
            shared non-durable subscription
            </param>
            <param name="messageSelector">only messages with properties matching 
            the message selector expression are added to the shared non-durable 
            subscription. A value of null or an empty string indicates that 
            there is no message selector for the shared non-durable 
            subscription.
            </param>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateSharedDurableConsumer(TIBCO.EMS.Topic,System.String)">
            <summary> Create a shared durable subscription (with the specified
            name on the specified topic - if one does not already exist), and 
            a consumer on that subscription. 
            </summary>
            <remarks ref="true()">
            <para>
            A durable subscription is used by an application which needs to 
            receive all the messages published on a topic, including the ones 
            published when there is no active consumer associated with it. 
            The EMS Server retains a record of this durable subscription and 
            ensures that all messages from the topic's publishers are retained 
            until they are delivered to, and acknowledged by, a consumer on 
            this durable subscription or until they have expired. 
            </para>
            <para>
            A durable subscription will continue to accumulate messages until 
            it is deleted using the <see cref="M:TIBCO.EMS.Session.Unsubscribe(System.String)"/> method.
            </para>
            <para>
            This method may only be used with shared durable subscriptions. 
            Any durable subscription created using this method will be shared. 
            This means that multiple active (i.e. not closed) consumers on 
            the subscription may exist at the same time. The term 
            "consumer" here means a <see cref="T:TIBCO.EMS.MessageConsumer"/> object in 
            any client.
            </para>
            <para>
            A shared durable subscription is identified by a name specified 
            by the client and by the client identifier (which may be unset). 
            An application which subsequently wishes to create a consumer 
            on that shared durable subscription must use the same client 
            identifier.
            </para>
            <para>
            If a shared durable subscription already exists with the same 
            name and client identifier (if set), and the same topic and message 
            selector has been specified, then this method creates a 
            MessageConsumer on the existing shared durable subscription.
            </para>
            <para>
            If a shared durable subscription already exists with the same 
            name and client identifier (if set) but a different topic or 
            message selector has been specified, and there is no consumer 
            already active (i.e. not closed) on the durable subscription 
            then this is equivalent to unsubscribing (deleting) the old 
            one and creating a new one.
            </para>
            <para>
            If a shared durable subscription already exists with the same 
            name and client identifier (if set) but a different topic or 
            message selector has been specified, and there is a consumer 
            already active (i.e. not closed) on the durable subscription, 
            then an EMSException will be thrown.
            </para>
            <para>
            A shared durable subscription and an unshared durable subscription 
            may not have the same name and client identifier (if set). If an 
            unshared durable subscription already exists with the same name 
            and client identifier (if set) then an EMSException is thrown.
            </para>
            <para>
            There is no restriction on durable subscriptions and shared 
            non-durable subscriptions having the same name and clientId 
            (which may be unset). Such subscriptions would be completely 
            separate. 
            </para>
            </remarks>
            <param name="topic">the <see cref="T:TIBCO.EMS.Topic"/> to subscribe to
            </param>
            <param name="name">the name used to identify this subscription
            </param>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateSharedDurableConsumer(TIBCO.EMS.Topic,System.String,System.String)">
            <summary> Create a shared durable subscription (with the specified
            name on the specified topic - if one does not already exist), and 
            a consumer on that subscription, using the specified message 
            selector.
            </summary>
            <remarks ref="true()">
            <para>
            A durable subscription is used by an application which needs to 
            receive all the messages published on a topic, including the ones 
            published when there is no active consumer associated with it. 
            The EMS Server retains a record of this durable subscription and 
            ensures that all messages from the topic's publishers are retained 
            until they are delivered to, and acknowledged by, a consumer on 
            this durable subscription or until they have expired. 
            </para>
            <para>
            A durable subscription will continue to accumulate messages until 
            it is deleted using the <see cref="M:TIBCO.EMS.Session.Unsubscribe(System.String)"/> method.
            </para>
            <para>
            This method may only be used with shared durable subscriptions. 
            Any durable subscription created using this method will be shared. 
            This means that multiple active (i.e. not closed) consumers on 
            the subscription may exist at the same time. The term 
            "consumer" here means a <see cref="T:TIBCO.EMS.MessageConsumer"/> object in 
            any client.
            </para>
            <para>
            A shared durable subscription is identified by a name specified 
            by the client and by the client identifier (which may be unset). 
            An application which subsequently wishes to create a consumer 
            on that shared durable subscription must use the same client 
            identifier.
            </para>
            <para>
            If a shared durable subscription already exists with the same 
            name and client identifier (if set), and the same topic and message 
            selector has been specified, then this method creates a 
            MessageConsumer on the existing shared durable subscription.
            </para>
            <para>
            If a shared durable subscription already exists with the same 
            name and client identifier (if set) but a different topic or 
            message selector has been specified, and there is no consumer 
            already active (i.e. not closed) on the durable subscription 
            then this is equivalent to unsubscribing (deleting) the old 
            one and creating a new one.
            </para>
            <para>
            If a shared durable subscription already exists with the same 
            name and client identifier (if set) but a different topic or 
            message selector has been specified, and there is a consumer 
            already active (i.e. not closed) on the durable subscription, 
            then an EMSException will be thrown.
            </para>
            <para>
            A shared durable subscription and an unshared durable subscription 
            may not have the same name and client identifier (if set). If an 
            unshared durable subscription already exists with the same name 
            and client identifier (if set) then an EMSException is thrown.
            </para>
            <para>
            There is no restriction on durable subscriptions and shared 
            non-durable subscriptions having the same name and clientId 
            (which may be unset). Such subscriptions would be completely 
            separate. 
            </para>
            </remarks>
            <param name="topic">the <see cref="T:TIBCO.EMS.Topic"/> to subscribe to
            </param>
            <param name="name">the name used to identify this subscription
            </param>
            <param name="messageSelector">only messages with properties 
            matching the message selector expression are added to the 
            durable subscription. A value of null or an empty string 
            indicates that there is no message selector for the durable 
            subscription.
            </param>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateTopic(System.String)">
            <summary>Create a topic </summary>
            <remarks ref="true()">
            <para> If the named topic already exists at the server, then this method returns 
            that topic. (That topic can be either static or dynamic.)</para>
            <para>
            If the named topic does not yet exist at the server, and the server allows 
            dynamic topics, then this method creates a dynamic topic.</para>
            <para>
            Dynamic destinations are provider-specific, so programs that use them might 
            not be portable to other providers.</para>
            <b>Note: </b>This facility is provided for the rare cases where 
             clients need to dynamically manipulate topic identity. 
             This method is not for creating the physical topic.
             The physical creation of topics is an administrative task and is
             not to be initiated by the EMS API. The one exception is the creation 
             of temporary topics, which is accomplished with the createTemporaryTopic method. 
            </remarks>
            <param name="topicName">Get or create the topic with this name. </param>
            <returns> A Topic with the given name. </returns>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateQueue(System.String)">
            <summary>Create a queue </summary>
            <remarks ref="true()">
            <para> This facility is provided for the rare cases where clients 
            need to dynamically manipulate queue identity. 
            </para>
            <para> Note that this method is not for creating the physical queue.
            The physical creation of queues is an administrative task and
            is not to be initiated by the EMS API. The one exception is 
            the creation of temporary queues, which is accomplished with 
            the <see cref="M:TIBCO.EMS.Session.CreateTemporaryQueue"/> method. 
            </para>
            <para>If the named queue already exists at the server, then this method returns 
            that queue. (That queue can be either static or dynamic.)
            </para>
            <para>If the named queue does not yet exist at the server, and the server allows 
            dynamic queues, then this method creates a dynamic queue.
            </para>
            <para>Dynamic destinations are provider-specific, so programs that use them might 
            not be portable to other providers.
            </para>
            </remarks>
            <param name="queueName">The name of the Queue to be created.</param>
            <returns>A Queue with the given name.</returns>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateProducer(TIBCO.EMS.Destination)">
            <summary>Create a MessageProducer to send messages to the 
            specified destination. </summary>
            <remarks>
            <para>
            A client uses a MessageProducer object to send messages to a
            destination. Since Queue and Topic both inherit from Destination,
            they can be used in the destination parameter to create a MessageProducer object. 
            </para>
            </remarks>
            <param name="dest"><para>When non-null, the producer sends messages to this destination.
             When null, the client program must specify the destination for each message individually.
            </para></param>
        </member>
        <member name="P:TIBCO.EMS.Session.IsTransacted">
            <summary> Get whether the session is transacted </summary>
            <remarks>
            <para>When true, the session has transaction semantics, and AcknowledgeMode is irrelevant.
            </para>
            <para>When false, it has non-transaction semantics.
            </para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.Session.AcknowledgeMode">
            <summary> Get the acknowledge mode of the session as integer constants as
            defined in Session class.</summary>
            <remarks ref="true()">
            <b>Note: </b>
            Clients should use the <see cref="T:TIBCO.EMS.SessionMode">SessionMode</see>
            enum instead.
            
            <para>This mode governs message acknowledgement and redelivery for consumers associated 
            with the session. For values, see the <see cref="T:TIBCO.EMS.Session"/> Acknowledge Modes.
            </para>
            <para>This property is irrelevant when <see cref="P:TIBCO.EMS.Session.IsTransacted"/> is true.
            </para>
            </remarks>
            
        </member>
        <member name="P:TIBCO.EMS.Session.SessionAcknowledgeMode">
            <summary> Get the acknowledge mode of the session as a SessionMode type</summary>
            <remarks ref="true()">
            <para>This property accesses the same information as <see cref="P:TIBCO.EMS.Session.AcknowledgeMode"/>,
            but uses enumerated values rather than ordinary integers. It is recommend over 
            <see cref="P:TIBCO.EMS.Session.AcknowledgeMode"/> because it enables .NET to do stronger type 
            checking at compile time, which can enhance program reliability. For return values, 
            see <see cref="T:TIBCO.EMS.SessionMode">SessionMode</see>.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Session.Unsubscribe(System.String)">
            <summary> Unsubscribe a durable topic subscription</summary>
            <remarks>
            <para> This method deletes the named subscription from the server.</para>
            </remarks>
            <param name="name"> The name of the durable subscriber </param>
            <exception cref="T:TIBCO.EMS.EMSException">Attempt to delete an active subscription (while a 
            MessageConsumer or TopicSubscriber exists) or to delete a subscription while one 
            of its messages is either unacknowledged, or uncommitted (in the current transaction). 
            </exception>
            <exception cref="T:TIBCO.EMS.IllegalStateException">Session is closed.</exception>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateBytesMessage">
            <summary>Create a byte array message</summary>
            <remarks>
            This method creates a <see cref="T:TIBCO.EMS.BytesMessage">BytesMessage</see> object,
            which is used to send a message containing a stream of uninterpreted bytes.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateMapMessage">
            <summary>Create a MapMessage object. A MapMessage object is used to
            send a self-defining set of name-value pairs, where names are 
            String objects and values are primitive values in the .NET programming language. 
            </summary>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateMessage">
            <summary> Create a Message object. The Message interface is the root 
            interface of all TIBCO EMS messages. A Message object holds all the 
             standard message header information. It can be sent when a message
            containing only header information is sufficient
            </summary>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateObjectMessage">
            <summary>Create an ObjectMessage object. An ObjectMessage object 
            is used to send a message that contains a serializable .NET object.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateObjectMessage(System.Object)">
            <summary>Create an ObjectMessage object. An ObjectMessage object 
            is used to send a message that contains a serializable .NET object.
            </summary>
            <param name="obj"> and .NET serialized object </param>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateStreamMessage">
            <summary>Create a StreamMessage object </summary>
            <remarks>
            A StreamMessage object is 
            used to send a self-defining stream of primitive values in the .NET 
            programming language.
            </remarks>
            <returns>A new StreamMessage object.</returns>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateTextMessage">
            <summary>Create a TextMessage object</summary>
            <remarks>
            A TextMessage object is 
            used to send a message containing a String object.
            </remarks>
            <returns>A new TextMessage object.</returns>
        </member>
        <member name="M:TIBCO.EMS.Session.CreateTextMessage(System.String)">
            <summary>Create a TextMessage object</summary>
            <remarks> 
            A TextMessage object is 
            used to send a message containing a String object.
            </remarks>
            <param name="text">The string used as data to initialize this message </param>
        </member>
        <member name="P:TIBCO.EMS.Session.Transacted">
            <summary> Get whether an open session is transacted </summary>
            <remarks> IllegalStateException will be thrown if the session is 
            closed. </remarks>
        </member>
        <member name="M:TIBCO.EMS.Session.Commit">
            <summary> Commit the open transaction</summary>
            <remarks>
            A session (with transaction semantics) always has exactly one open 
            transaction. Message operations associated with the session become 
            part of that transaction. This call commits all the messages within 
            the transaction and releases any locks. Then it opens a new transaction.
            </remarks>
            <exception cref="T:TIBCO.EMS.EMSException">If the Commit failed due to some internal error.</exception>
            <exception cref="T:TIBCO.EMS.TransactionRolledBackException">An attempt to commit a transaction 
            resulted in rollback.</exception>
            <exception cref="T:TIBCO.EMS.IllegalStateException">Commit occurred in an inappropriate context.</exception>
            
        </member>
        <member name="M:TIBCO.EMS.Session.Rollback">
            <summary>Roll back messages in the current transaction</summary>
            <remarks>
            Roll back any messages done in this transaction and 
            release any locks currently held. 
            <para>
            Messages sent to a queue with prefetch=none and maxRedelivery=number properties 
            are not received number times by an EMS application that receives in a loop 
            and does an XA rollback after the XA prepare phase.
            </para>
            </remarks>
            <exception cref="T:TIBCO.EMS.IllegalStateException">The session does not have transactional 
            semantics.</exception>
        </member>
        <member name="M:TIBCO.EMS.Session.Close">
            <summary>Close a session and reclaim resources</summary>
            <remarks>
            <para>Closing a session automatically closes its consumers (except for durable 
            subscribers), producers and browsers.
            </para>
            <para><b>Blocking</b></para>
            <para>If any message listener or receive call associated with the session is 
            processing a message when the program calls this method, all facilities 
            of the connection and its sessions remain available to those listeners 
            until they return. In the meantime, this method blocks until that processing 
            completes -- that is, until all message listeners and receive calls have returned.
            A blocked message consumer receive call returns null when this session is closed.
            </para>
            <para><b>Transactions</b></para>
            <para>Closing a session rolls back the open transaction in the session.
            </para>
            </remarks>
            
        </member>
        <member name="M:TIBCO.EMS.Session.Recover">
            <summary> Recover from undetermined state during message processing</summary>
            <remarks>
            <para>Exceptions during message processing can sometimes leave a program in an ambiguous 
            state. For example, some messages might be partially processed. This method lets a 
            program return to an unambiguous state - the point within the message stream when 
            the program last acknowledged the receipt of inbound messages. Programs can then 
            review the messages delivered since that point (they are marked as redelivered), 
            and resolve ambiguities about message processing.
            </para>
            <para>Programs can also use this method to resolve similar ambiguities after a Connection 
            stops delivering messages, and then starts again.
            </para>
            <para><b>Operation</b></para>
            <para>This method requests that the server do this sequence of actions:
            </para>
            <list type="number">
            <item>Stop message delivery within the session.</item>
            <item>Mark as redelivered, any messages that the server has attempted to deliver to 
            the session, but for which it has not received acknowledgement (that is, messages 
            for which processing state is ambiguous).
            According to the JMS specification, the server does not needs to redeliver messages in 
            the same order as it first delivered them.
            </item>
            <item>Restart message delivery (including messages marked as redelivered in step 2).
            </item>
            </list>
            <para>When a session has transactional semantics, this method throws IllegalStateException 
            (commit and rollback are more appropriate for transactions).
            </para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.Session.MessageListener">
            <summary> Get or set the message listener for the session. -Deprecated, use MessageConsumer.MessageListener instead. </summary>
            <remarks> The access of message listener through the Session object 
            is deprecated.  Please use the facility in MessageConsumer instead.
            <p>User should either use MessageHandler or MessageListener
            to handle asynchronous message consumptions, but <b>not</b> both.  
            Setting up both will cause the message to be handled more than once 
            which can result in undefined behavior </p></remarks>
            <exception cref="T:TIBCO.EMS.IllegalStateException">If the session is closed</exception>
            \deprecated Use MessageConsumer.MessageListener instead.
        </member>
        <member name="M:TIBCO.EMS.Session.Run">
            <summary> Obsolete: Not to be used by ordinary JMS Clients </summary>
            \deprecated Ordinary JMS clients should not use this method.
        </member>
        <member name="M:TIBCO.EMS.Session.ToString">
            <summary>Returns a string representation of this <c>Session</c> 
            object.</summary>
            <returns>A string representation </returns>
        </member>
        <member name="T:TIBCO.EMS.StreamMessage">
            <summary>
            A StreamMessage object is used to send a stream of primitive types in the .NET  
            programming language. It is filled and read sequentially. 
            It inherits from the Message interface and adds a stream message body. 
            </summary>
            <remarks ref="true()">
            <para>
            Each datum in the stream must be a primitive type, or an object representation
            of a primitive type.</para>
            <para>
            The primitive types can be read or written explicitly using methods 
            for each type. They may also be read or written generically as objects. 
            For instance, a call to StreamMessage.writeInt(6) is equivalent to 
            StreamMessage.writeObject((object)6). Both forms are provided, because 
            the explicit form is convenient for static programming, and the object form 
            is needed when types are not known at compile time. 
            </para>
            <para> When the message is first created, and when clearBody is called, 
            the body of the message is in write-only mode. After the first call 
            to reset has been made, the message body is in read-only mode. 
            After a message has been sent, the client that sent it can retain and 
            modify it without affecting the message that has been sent. The same 
            message object can be sent multiple times. When a message has been received, 
            the provider has called reset so that the message body is in read-only mode for the client. 
            </para>
            <para> If clearBody is called on a message in read-only mode, 
            the message body is cleared and the message body is in write-only mode. 
            </para> 
            <para>
            If a client attempts to read a message in write-only mode, 
             a MessageNotReadableException is thrown. </para>
            <para>If a client attempts to write a message in read-only mode,
            a MessageNotWriteableException is thrown. </para>
            <para><b>Extensions</b></para>
            <para>
            TIBCO Enterprise Message Service extends the MapMessage and StreamMessage body types 
            in two ways. These extensions allow TIBCO Enterprise Message Service to exchange messages 
            with TIBCO Rendezvous and ActiveEnterprise formats that have certain features not available 
            within the JMS specification.</para>
            <list type="bullet"> 
            <item><description>You can insert another MapMessage or StreamMessage instance as a 
            submessage into a MapMessage or StreamMessage, generating a series of nested messages, 
            instead of a flat message. </description></item>
            <item><description>You can use arrays as well as primitive types for the values. </description></item>
            </list>
            <para>
            These extensions add considerable flexibility to the two body types. However, they are 
            extensions and therefore not compliant with JMS specifications. Extended messages are 
            tagged as extensions with the vendor property tag JMS_TIBCO_MSG_EXT. 
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.#ctor">
            <summary>Construct an empty stream message. </summary>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.#ctor(TIBCO.EMS.Session)">
            <summary>Construct an empty stream message for a session. </summary>
            <param name="session">The session of the message. </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.Clone">
            <summary>Create a copy of the StreamMessage object. </summary>
        </member>
        <member name="P:TIBCO.EMS.StreamMessage.FieldCount">
            <summary>
            Returns number of fields that this message holds.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ReadBoolean">
            <summary> Reads a boolean from the stream message. </summary>
            <remarks>This method reads a byte of data from the stream and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the boolean value read </returns>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ReadByte">
            <summary> Reads a byte from the stream message. </summary>
            <remarks>This method reads a byte of data from the stream and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the byte value read </returns>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ReadShort">
            <summary> Reads a short from the stream message. </summary>
            <remarks>This method reads two bytes of data from the stream and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the short value read </returns>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ReadChar">
            <summary> Reads a char from the stream message. </summary>
            <remarks>This method reads two bytes of data from the stream and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the char value read </returns>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ReadInt">
            <summary> Reads an int from the stream message. </summary>
            <remarks>This method reads four bytes of data from the stream and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the int value read </returns>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ReadLong">
            <summary> Reads a long from the stream message. </summary>
            <remarks>This method reads eight bytes of data from the stream and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the long value read </returns>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ReadFloat">
            <summary> Reads a float from the stream message. </summary>
            <remarks>This method reads four bytes of data from the stream and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the float value read </returns>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ReadDouble">
            <summary> Reads a double from the stream message. </summary>
            <remarks>This method reads eight bytes of data from the stream and advances the read 
            position so that the next read call gets the next datum.</remarks>
            <returns>the double value read </returns>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ReadString">
            <summary> Reads a string from the stream message. </summary>
            <returns>the string value read </returns>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ReadBytes(System.Byte[])">
            <summary> Reads a byte array from the stream message. </summary>
            <remarks>
            <para>Each call reads bytes from the stream into the byte array, and advances the read position.</para>
            <para> This call returns the actual number of bytes read. When the call cannot read even one byte, 
            it returns -1.</para>
            <para>A program that calls this method must call it repeatedly until it returns -1, 
            indicating that the program has extracted the complete set of bytes. Only then may the 
            program call another read method.</para>
            </remarks>
            <returns>The byte array value read, or -1 when there are no more bytes to read.</returns>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ReadObject">
            <summary> Reads an object from the stream message. </summary>
            <returns>the object value read </returns>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteBoolean(System.Boolean)">
            <summary> Writes a boolean to the stream message. </summary>
            <remarks><para>Each call writes a data value to the stream and advances the write 
            position so that the next write call appends to the new end of the stream.
            </para> </remarks> 
            <param name="value">the boolean value to be written. The value true is written as 
             (byte)1; the value false is written as (byte)0. </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteByte(System.Byte)">
            <summary> Writes a byte to the stream message. </summary>
            <remarks><para>Each call writes a data value to the stream and advances the write 
            position so that the next write call appends to the new end of the stream.
            </para> </remarks> 
            <param name="value">the byte value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteShort(System.Int16)">
            <summary> Writes a short to the stream message. </summary>
            <remarks><para>Each call writes a data value to the stream and advances the write 
            position so that the next write call appends to the new end of the stream.
            </para> </remarks> 
            <param name="value">the short value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteChar(System.Char)">
            <summary> Writes a char to the stream message. </summary>
            <remarks><para>Each call writes a data value to the stream and advances the write 
            position so that the next write call appends to the new end of the stream.
            </para> </remarks> 
            <param name="value">the char value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteInt(System.Int32)">
            <summary> Writes an int to the stream message. </summary>
            <remarks><para>Each call writes a data value to the stream and advances the write 
            position so that the next write call appends to the new end of the stream.
            </para> </remarks> 
            <param name="value">the int value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteLong(System.Int64)">
            <summary> Writes a long to the stream message. </summary>
            <remarks><para>Each call writes a data value to the stream and advances the write 
            position so that the next write call appends to the new end of the stream.
            </para> </remarks> 
            <param name="value">the long value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteFloat(System.Single)">
            <summary> Writes a float to the stream message. </summary>
            <remarks><para>Each call writes a data value to the stream and advances the write 
            position so that the next write call appends to the new end of the stream.
            </para> </remarks> 
            <param name="value">the float value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteDouble(System.Double)">
            <summary> Writes a double to the stream message. </summary>
            <remarks><para>Each call writes a data value to the stream and advances the write 
            position so that the next write call appends to the new end of the stream.
            </para> </remarks> 
            <param name="value">the double value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteString(System.String)">
            <summary> Writes a string to the stream message. </summary>
            <remarks><para>Each call writes a data value to the stream and advances the write 
            position so that the next write call appends to the new end of the stream.
            </para> </remarks> 
            <param name="value">the string value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteBytes(System.Byte[])">
            <summary> Writes a byte array to the stream message. </summary>
            <remarks><para>Each call writes bytes from the byte array to the stream and advances the write 
            position so that the next write call appends to the new end of the stream.
            </para> </remarks> 
            <param name="value">the byte array value to be written </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary> Writes a portion of a byte array as a byte array field to the stream message. 
            </summary>
            <remarks><para>Each call writes bytes from the byte array to the stream and advances the write 
            position so that the next write call appends to the new end of the stream.
            </para>
            <para>The a portion of the byte array value is written to the message as 
            a byte array field. Consecutively written byte array fields are treated 
            as two distinct fields when the fields are read. 
            </para>
            <para>
            This method attempts to write the specified bytes to the stream; otherwise it 
            attempts to write the entire byte array. The offset and length arguments must be 
            between zero and value.length (inclusive) and their sum must also fall within the 
            same range. That is, these two arguments must specify a span of bytes within the 
            value argument. Otherwise the call throws an IndexOutOfRangeException (and does 
            not write any bytes).
            </para>
            </remarks>
            <param name="value">the byte value to be written </param>
            <param name="offset">the initial offset within the byte array</param>
            <param name="length">the number of bytes to use </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.WriteObject(System.Object)">
            <summary> Writes an object to the stream message. </summary>
            <remarks>This method converts an object to a primitive value (if possible)
            and writes that value to the stream message.</remarks>
            <param name="value">the object to be written </param>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.Reset">
            <summary> Puts the message body in read-only mode and repositions 
            the stream to the beginning </summary>
            <remarks>Reset prepares a message body for reading, as if the message were 
            newly received. This method contrasts with the ClearBody method, which clears a message 
            body in preparation for writing, as if it were newly created.</remarks>
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ClearBody">
            <summary> Clears a message body in preparation for writing</summary>
            <remarks>When clearBody is called, the message body is cleared and the message
            body is set to write-only mode. After the first call 
            to reset has been made, the message body is in read-only mode. </remarks> 
        </member>
        <member name="M:TIBCO.EMS.StreamMessage.ToString">
            <summary> Return a string representation of the message </summary>
            <returns> string representation of the message </returns>
        </member>
        <member name="T:TIBCO.EMS.TemporaryQueue">
            <summary>
            A TemporaryQueue object is a unique Queue object created 
            for the duration of a Connection. It is a system-defined queue 
            that can be consumed only by the Connection that created it. 
            </summary>
            <remarks ref="true()">
            <para>
            A TemporaryQueue object can be created at either the Session or 
            QueueSession level. Creating a TemporaryQueue at the Session level allows the 
            TemporaryQueue to participate in transactions with objects from the 
            Pub/Sub domain. If a TemporaryQueue is created at the QueueSession level, it will only 
            be able participate in transactions with objects from the PTP domain. 
            </para>
            <para>
            Programs can use temporary queues as reply destinations. 
            A temporary queue exists only for the duration of the session's connection,
            and is available only within that connection.
            Only consumers associated with the same connection as the temporary queue 
            can consume messages from it.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.TemporaryQueue.Clone">
            <summary>
            Throws a NotSupported Exception
            </summary>
        </member>
        <member name="M:TIBCO.EMS.TemporaryQueue.Delete">
            <summary>
            Deletes a temporary queue that belongs to this connection.
            </summary>
            <remarks>
            <para>
            When a client deletes a temporary queue, the 
            server deletes any unconsumed messages in the queue.</para>
            <para>
            If the client still has listeners or receivers for the queue, or is in 
            the middle of a Receive call, then Delete throws an EMSException.</para>
            </remarks>
        </member>
        <member name="T:TIBCO.EMS.TemporaryTopic">
            <summary>
            A TemporaryTopic object is a unique Topic object created for the 
            duration of a Connection.
            </summary>
            <remarks ref="true()">
            <para> A TemporaryTopic object can be created either at the 
            Session or TopicSession level. Creating a TemporaryTopic at the Session level 
            allows the TemporaryTopic to participate in the same transaction 
            with objects from the PTP domain. If a TemporaryTopic is created 
            at the TopicSession level, it will only be able participate in 
            transactions with objects from the Pub/Sub domain
            </para><para>
            Programs can use temporary topics as reply destinations.
            A temporary topic exists only for the duration of the session's connection, 
            and is available only within that connection.
            Only consumers associated with the same connection as the TemporaryTopic 
            can consume messages from a TemporaryTopic.
            </para><para>
            Servers connected by routes exchange messages sent to TemporaryTopic.</para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.TemporaryTopic.Clone">
            <summary>
            Throws a NotSupported Exception
            </summary>
        </member>
        <member name="M:TIBCO.EMS.TemporaryTopic.Delete">
            <summary> Deletes this temporary topic. </summary>
            <remarks>
            <para>When a client deletes a temporary topic, the server deletes any unconsumed 
            messages in the topic.</para>
            <para>If the client still has listeners or receivers for the topic, or is in the 
            middle of a Receive call, then Delete throws an EMSException.
            </para>
            </remarks>
        </member>
        <member name="T:TIBCO.EMS.TextMessage">
            <summary>
            A TextMessage object is used to send a message containing a String. 
            It inherits from the Message interface and adds a text message body. 
            </summary>
            <remarks>
            <para>
            This message type can be used to transport text-based messages, including those with XML content. 
            </para>
            <para> When a client receives a TextMessage, it is in read-only mode. 
            If a client attempts to write to the message at this point, 
            a MessageNotWriteableException is thrown. If clearBody is called, 
            the message can now be both read from and written to. 
            </para>
            </remarks>
        </member>
        <member name="P:TIBCO.EMS.TextMessage.Text">
            <summary>Gets or sets the text content of the text message. </summary>
            <value>The string as the content of the message. </value>
        </member>
        <member name="M:TIBCO.EMS.TextMessage.#ctor">
            <summary> Construct an empty text message. </summary>
        </member>
        <member name="M:TIBCO.EMS.TextMessage.#ctor(TIBCO.EMS.Session)">
            <summary> Construct an empty text message for a session. </summary>
            <param name="session">The session of the message. </param>
        </member>
        <member name="M:TIBCO.EMS.TextMessage.#ctor(TIBCO.EMS.Session,System.String)">
            <summary> Construct a text message for a session. </summary>
            <param name="session">The session of the message. </param>
            <param name="text">The text content of the message. </param>
        </member>
        <member name="M:TIBCO.EMS.TextMessage.Clone">
            <summary> Create a copy of the TextMessage object.</summary>
        </member>
        <member name="M:TIBCO.EMS.TextMessage.ClearBody">
            <summary> Clears a message body in preparation for writing</summary>
            <remarks>
            <para> When a client receives a TextMessage, it is in read-only mode. 
            If a client attempts to write to the message at this point, 
            a MessageNotWriteableException is thrown. </para>
            <para>
            Calling ClearBody clears the body of a text message, but leaves its header and 
            property values unchanged. If the text message body was read-only, calling ClearBody  
            makes the message writable. The message body appears and behaves identically to an 
            empty body in a newly created message.
            </para>
            </remarks>     
        </member>
        <member name="M:TIBCO.EMS.TextMessage.ToString">
            <summary> Return a string representation of the message </summary>
            <returns> string representation of the message </returns>
        </member>
        <member name="T:TIBCO.EMS.FactoryLoadBalanceMetric">
            <summary>Enum defintions for connection factory load balance metrics. </summary>  
            <remarks>
            When a connection factory balances the client load among several servers, it uses 
            this metric to determine the least loaded server, so the connection factory can 
            create a connection to it.
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.FactoryLoadBalanceMetric.None">
            <summary>
            Indicate that no load balancing metric has been set for the connection
            factory.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.FactoryLoadBalanceMetric.Connections">
            <summary>
            Indicate that the connection factory load balances connections across
            multiple servers by creating a connection to the server with the fewest
            number of connections.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.FactoryLoadBalanceMetric.ByteRate">
            <summary>
            Indicate that the connection factory load balances connections across
            multiple servers by creating a connection to the server with the lowest
            total byte rate (input and output).
            </summary>
        </member>
        <member name="T:TIBCO.EMS.MessageDeliveryMode">
            <summary> Defines of the delivery modes as enum </summary>
            <remarks ref="true()">
            The class <see cref="T:TIBCO.EMS.DeliveryMode"/> defines a parallel set of constants as ordinary 
            integers. However, this MessageDeliveryMode enumeration enables .NET to do 
            stronger type checking at compile time, which can enhance program reliability.
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.MessageDeliveryMode.NonPersistent">
            <summary>Non persistent delivery </summary>
        </member>
        <member name="F:TIBCO.EMS.MessageDeliveryMode.Persistent">
            <summary>Persistent delivery </summary>
        </member>
        <member name="F:TIBCO.EMS.MessageDeliveryMode.ReliableDelivery">
            <summary>
            Reliable delivery.  This delivery mode is a proprietary
            extension and when used offers increased performance of the message
            producers using this mode.  
            </summary>
        </member>
        <member name="T:TIBCO.EMS.DeliveryMode">
            <summary>Define delivery mode constants as integers (for backward compatibility) </summary>
            <remarks>
            The class <see cref="T:TIBCO.EMS.MessageDeliveryMode"/> defines a parallel set of constants as .NET enumerated 
            values (instead of ordinary integers). We recommend the enumeration over these ordinary 
            integer values, because it enables .NET to do stronger type checking at compile time, 
            which can enhance program reliability.
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.DeliveryMode.NON_PERSISTENT">
            <summary>Non persistent delivery </summary>
        </member>
        <member name="F:TIBCO.EMS.DeliveryMode.PERSISTENT">
            <summary>Persistent delivery </summary>
        </member>
        <member name="F:TIBCO.EMS.DeliveryMode.RELIABLE_DELIVERY">
            <summary>
            Defines reliable delivery mode. This delivery mode is a proprietary
            extension and when used offers increased performance of the message
            producers using this mode.  
            </summary>
        </member>
        <member name="T:TIBCO.EMS.Tibems">
            <summary> Defines miscellaneous constants and provider properties used by 
            TIBCO Enterprise Message Service</summary>  
            <remarks>
            <para>This class also provides methods for getting the
            size of a <c>Message</c> object and manipulating provider properties.
            </para>
            <para>The static methods <see cref="M:TIBCO.EMS.Tibems.GetProperty(System.String)"/> and <see cref="M:TIBCO.EMS.Tibems.SetProperty(System.String,System.Object)"/> can 
            be use to override default properties by user </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.NPSEND_CHECK_DEFAULT">
            <summary>
            Defines default check mode for sending a NON_PERSISTENT messages. 
            See <see cref="M:TIBCO.EMS.Tibems.SetNPSendCheckMode(TIBCO.EMS.MessageProducer,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.NPSEND_CHECK_ALWAYS">
            <summary>     
            Defines mode when producer always checks result of sending a 
            NON_PERSISTENT message.  See <see cref="M:TIBCO.EMS.Tibems.SetNPSendCheckMode(TIBCO.EMS.MessageProducer,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.NPSEND_CHECK_NEVER">
            <summary>     
            Defines mode when producer never checks result of sending a 
            NON_PERSISTENT message. See <see cref="M:TIBCO.EMS.Tibems.SetNPSendCheckMode(TIBCO.EMS.MessageProducer,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.NPSEND_CHECK_TEMP_DEST">
            <summary>     
            Defines mode when producer checks result of sending a NON_PERSISTENT message
            only when sending into temporary destination. See <see cref="M:TIBCO.EMS.Tibems.SetNPSendCheckMode(TIBCO.EMS.MessageProducer,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.NPSEND_CHECK_AUTH">
            <summary>
            Defines mode when producer checks result of sending a NON_PERSISTENT message
            only when server authorization is enabled. See <see cref="M:TIBCO.EMS.Tibems.SetNPSendCheckMode(TIBCO.EMS.MessageProducer,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.NPSEND_CHECK_TEMP_AUTH">
            <summary>
            Defines mode when producer checks result of sending a NON_PERSISTENT message
            when sending into temporary destination or if server authorization is enabled.
            See <see cref="M:TIBCO.EMS.Tibems.SetNPSendCheckMode(TIBCO.EMS.MessageProducer,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.JMS_TIBCO_IMPORTED">
            <summary>
            Provider-specific message property which is set by the provider if the
            message has been imported from an external message service, such as TIBCO 
            Rendezvous or TIBCO FTL. 
            </summary>
            <remarks>
            This property is defined as string "JMS_TIBCO_IMPORTED".
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.JMS_TIBCO_SENDER">
            <summary>
            Provider-specific message property which may be set in a received message if
            message has been sent on a destination with sender name property.
            When set in the message, the property value is a String specifying
            the name of the user who sent this message.
            </summary>
            <remarks>   
            This property is defined as String "JMS_TIBCO_SENDER".
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.JMS_TIBCO_DISABLE_SENDER">
            <summary>
            Provider specific message property which may be set to prevent the server
            from including the user name into message when sending this message to
            consumers. 
            </summary>
            <remarks>   
            This property is ignored by the server if the destination is
            specified to enforce the inclusion of the user name.
            This property, if used, must be set to boolean value 'true' by the message
            producer before sending the message.
            <para>
            This property is defined as String "JMS_TIBCO_DISABLE_SENDER".</para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.JMS_TIBCO_SS_SENDER">
             <summary>
             Provider-specific message property which is set if imported message
             has been published by TIBCO SmartSockets application.
             </summary>
             <remarks>
             Property value is a String specifying the SmartSockets sender name.
            
             This property is defined as String "JMS_TIBCO_SS_SENDER".
             </remarks>
             \deprecated As of release 8.6
        </member>
        <member name="F:TIBCO.EMS.Tibems.JMS_TIBCO_CM_PUBLISHER">
            <summary>
            Provider-specific message property which may be set if imported message
            has been published by TIBCO Rendezvous Certified Messaging application.
            </summary>
            <remarks>   
            <para>Defines the name of a provider-specific message property. An imported message 
            with that property is an RVCM message. The value of that property is the 
            RVCM sender name. 
            </para>
            <para>This property is defined as string "JMS_TIBCO_CM_PUBLISHER".
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.JMS_TIBCO_CM_SEQUENCE">
            <summary>
            Provider-specific message property which may be set if imported message
            has been published by TIBCO Rendezvous Certified Messaging application.
            </summary>
            <remarks>   
            <para>Defines the name of a provider-specific message property. An imported message 
            with that property is an RVCM message. The value of that property is the RVCM 
            sequence number.
            </para>
            <para>This property is defined as string "JMS_TIBCO_CM_SEQUENCE".
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.JMS_TIBCO_MSG_EXT">
            <summary>
            Provider-specific message property which is set by the provider
            or the application when message extensions are used.
            </summary>
            <remarks>   
            <para>This Message extension allows inclusion of other MapMessage objects
            as well as arrays of primitive types as MapMessage field values.  
            </para>
            This property is defined as string "JMS_TIBCO_MSG_EXT".
            </remarks>   
        </member>
        <member name="F:TIBCO.EMS.Tibems.JMS_TIBCO_MSG_TRACE">
            <summary>
            Provider-specific message property which is set by the provider
            or the application when message extensions are used.
            </summary>
            <remarks>
            This Message extension allows per message tracing to be enabled.  
            <para>
            This property is defined as string "JMS_TIBCO_MSG_TRACE".</para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.JMS_TIBCO_COMPRESS">
            <summary>
            Provider-specific message property which is set by the 
            application if this message should be compressed before
            it is sent to the server.</summary>
            <remarks>This property is defined as string "JMS_TIBCO_COMPRESS".
            <para><b>Note</b>: EMS supports compression only when EMS is
            used with Microsoft .NET Framework 2.0.
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.JMS_TIBCO_PRESERVE_UNDELIVERED">
            <summary>
            Provider-specific message property which is set by the 
            application if this message should be placed into special
            system queue in case it could not be delivered.
            </summary>
            <remarks>  
            This property is defined as string "JMS_TIBCO_PRESERVE_UNDELIVERED".
            </remarks>  
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_MESSAGE_ENCODING">
            <summary> 
            Defines the name of the System Property setting the global encoding
            name for String values in the message properties and data fields.
            </summary>
            <remarks>  
            This property is defined as String "tibco.tibjms.message.encoding".
            </remarks>  
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_SOCKET_RECEIVE">
            <summary>
            Defines the name of the provider property setting the size of 
            the socket receive buffer size in kilobytes for client connections. 
            </summary>
            <remarks>  
            The value of this property is a string encoding the number of kilobytes,
            e.g. "256".
            Some operating systems may ignore this setting.  
            <para>
            This property is defined as String "tibco.tibjms.socket.receive".</para>
            </remarks>  
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_SOCKET_SEND">
            <summary>
            Defines the name of the provider property setting the size of 
            the socket send buffer size in kilobytes for client connections. 
            </summary>
            <remarks>
            The value of this property is a string encoding the number of kilobytes,
            e.g. "256".
            Some operating systems may ignore this setting.  
            <para>
            This property is defined as String "tibco.tibjms.socket.send".</para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_DAEMON_DISPATCHER">
            <summary>
            Defines the name of the provider property controlling the type of 
            Session dispatcher threads
            </summary>
            <remarks>
            When application uses message listeners, TIBCO Enterprise Message 
            Serivce creates internal dispatcher threads for each Session which has
            at least one asynchronous message consumer. By default those dispatcher
            threads are <b>not</b> set to be daemon threads. If this provider property
            is defined then the Session dispatcher threads will be created as
            daemon threads.  
            <para>
            This property is defined as string "tibco.tibjms.daemon.dispatcher".</para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_FT_SWITCH_EXCEPTION">
            <summary>
            Defines the name of the provider property controlling if ExceptionListener
            set on the Connection should be called during fault-tolerant switch.
            </summary>
            <remarks>
            When an application performs fault-tolerant switch it may notify
            the Connection's ExceptionListener by calling it with EMSException
            providing the information about fault-tolerant switch. If this property
            is set, the Connection's ExceptionListener is called with the EMSException
            which has the vendor error code (EMSException.getErrorCode()) set to
            the string in the form: 
            <b><c>FT-SWITCH: &lt;new-server-url&gt;</c></b>
            An application can recognize such calls by analyzing the error code
            in the passed EMSException and perform necessary actions. Notice that
            the ExceptionListener is called with the special EMSException 
            only when fault-tolerant switch has been performed succesfully. In case
            the fault-tolerant switch has failed, the Connection's ExceptionListener
            will be called with regular EMSException (it will not have error code in the
            form 'FT-SWITCH: &lt;new-server-url>' specifying that the connection to 
            Server has been terminated. Notice that if this property is not
            set then by default Connection's ExceptionListener is not called
            after a successfull fault-tolerant switch.  
            <para>
            This property is defined as string "tibco.tibjms.ft.switch.exception".
            <b>NOTE: </b>when the exception listener is called, the exception listener 
            is not allowed to call any EMS method.  To do so in this case risks 
            a deadlock in the client.</para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_FT_EVENTS_EXCEPTION">
            <summary>
            Defines the name of the provider property controlling if ExceptionListener
            set on the Connection should be called for all the following events: disconnected,
            each reconnect attempt, and reconnected.
            </summary>
            <remarks>
            <para>
            Similarly to <see cref="F:TIBCO.EMS.Tibems.PROP_FT_SWITCH_EXCEPTION">
            Tibems.PROP_FT_SWITCH_EXCEPTION</see>, if this property is set and if a 
            Connection's ExceptionListener is set, (and the connection has FT urls), 
            then all above events will trigger the call to the ExceptionListener.OnException 
            callback with an EMSException which has the vendor error code 
            (EMSException.ErrorCode) 
            set to the String in the form:
            </para>
            <code>FT-SWITCH: event</code>
            <para>
            where <i>event</i> is:
            </para>
            <list type="bullet">
            <item><b>Disconnected from <i>server url</i>, will attempt to reconnect</b></item>
            <item><b>Reconnecting to <i>next server url</i>, attempt <i>n</i> out of <i>m</i></b></item>
            <item><b>Reconnected to <i>server url</i></b></item>
            </list>
            <para>
            An application can recognize such calls by analyzing the error code
            in the passed EMSException and perform necessary actions. Notice that this
            property replaces the property Tibems.PROP_FT_SWITCH_EXCEPTION, which means 
            that if both are set, only one "reconnected" event will be passed to the 
            ExceptionListener.OnException callback (the one described above). We 
            recommend that if Tibems.PROP_FT_SWITCH_EXCEPTION was formerly used, 
            and the user wishes to capture all FT events, this new property be used 
            instead and the ExceptionListener.OnException callback modified to handle 
            these new vendor error codes.
            </para>
            <para>
            This property is defined as string "tibco.tibjms.ft.events.exception". 
            </para>
            <b>Note: </b>
            When the exception listener is called, the exception listener 
            is not allowed to call any EMS method. To do so in this case risks 
            a deadlock in the client.
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_CLOSE_IN_CALLBACK">
            <summary>
            Defines the name of the provider property controlling if the
            <see cref="M:TIBCO.EMS.Session.Close">Session.Close</see>,
            <see cref="M:TIBCO.EMS.Connection.Close">Connection.Close</see> or
            <see cref="M:TIBCO.EMS.Connection.Stop">Connection.Stop</see> methods
            can be called in the 
            <see cref="M:TIBCO.EMS.IMessageListener.OnMessage(TIBCO.EMS.Message)">IMessageListener.OnMessage</see> 
            callback.
            </summary>
            <remarks>
            According to the JMS 2.0 specification, calling any of these methods must trigger
            an <see cref="T:TIBCO.EMS.IllegalStateException">IllegalStateException</see>.
            If this property is set then the Close or the Stop method can be called
            inside the callback and it will not throw an exception and will proceed
            without waiting for the same callback to return.
            This property is defined as string "tibco.tibjms.close.in.callback".
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_CONNECT_ATTEMPTS">
            <summary>
            Defines the name of the provider property controlling the 
            number of attempts the connections make to connect to the server.
            </summary>
            <remarks>
            When too many clients connect to the same server, the server may not
            be able to accept all connections at the same time. This parameter
            specifies the number of attempts and delay between the attempt
            the connections perform in order to connect to the server. The value
            of this property is a string in the form "NN[,DELAY]" where NN is the
            number of attempts and DELAY is delay in milliseconds between the
            attempts. Minimum value of NN is 1, minimum value of DELAY is 250
            milliseconds.
            Default value used is "2,500".  
            <para>
            This property is defined as string "tibco.tibjms.connect.attempts".</para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_RECONNECT_ATTEMPTS">
            <summary>
            Defines the name of the provider property controlling the 
            number of attempt the connections make to reconnect to the backup
            server during the fault-tolerant switch. 
            </summary>
            <remarks>This property is similar to
            PROP_CONNECT_ATTEMPTS. The difference is that it may be necessary
            to use different parameters during reconnect than during the initial
            connect. Initial connect of the clients to the server is normally
            distributed in time and there are less chances of the server exceeding its
            maximum accept queue. During fault-tolerant switch, all connected clients
            automatically try to reconnect to the backup server, approximately at
            the same time. When the number of connections is large, it may require
            more attempts to reconnect than the initial connect. The value
            of this property is a string in the form "NN[,DELAY]" where NN is the
            number of attempts and DELAY is delay in milliseconds between the
            attempts. Minimum value of NN is 1, minimum value of DELAY is 250
            milliseconds.
            Default value used is "4,500".  
            <para>
            This property is defined as string "tibco.tibjms.reconnect.attempts".</para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_CONNECT_ATTEMPT_TIMEOUT">
            <summary>
            Defines the name of the System Property controlling the 
            maximum time for the connections to connect to the server.
            When too many clients connect to the same server, the server may not
            be able to accept all connections at the same time or may run out of 
            system resources. This parameter specifies the amount of time a client 
            is willing to wait for a connection to be established. 
            Internally the client library will tear down any hung connections (either
            because of non-availability of system resources or some other EMS server
            problem) after this timeout.
            
            The value of this property in an integer and is in milliseconds.
            This property is defined as String "tibco.tibjms.connect.attempt.timeout".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_RECONNECT_ATTEMPT_TIMEOUT">
            <summary>
            Defines the name of the System Property controlling the 
            maximum time for connections to reconnect to the backup
            server during the fault-tolerant switch. This property is similar to
            PROP_CONNECT_ATTEMPTS_TIMEOUT. The difference is that it may be necessary
            to use different parameters during reconnect than during the initial
            connect. Initial connect of the clients to the server is normally
            distributed in time and there are less chances of the server exceeding its
            maximum accept queue. During fault-tolerant switch, all connected clients
            automatically try to reconnect to the backup server, approximately at
            the same time. When the number of connections is large, it may require
            more reconnect time to reconnect than the initial connect. The value
            of this property is an integer in milliseconds. 
            This property is defined as String "tibco.tibjms.reconnect.attempt.timeout".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_MULTICAST_ENABLED">
            <summary>
            Defines the name of the System Property specifying whether multicast
            is enabled or disabled for this EMS client.
            This property is defined as String "tibco.tibjms.multicast.enabled".
            </summary>
            \deprecated As of release 8.3
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_MULTICAST_DAEMON">
            <summary>
            Defines the name of the System Property specifying the port on which
            EMS clients will connect to the multicast daemon.
            This property is defined as String "tibco.tibjms.multicast.daemon".
            </summary>
            \deprecated As of release 8.3
        </member>
        <member name="F:TIBCO.EMS.Tibems.PROP_PING_INTERVAL">
            <summary>
            Defines the name of the System Property setting the ping interval
            for inactive connections. </summary>
            <remarks>When a connection does not send nor receives
            any data, it may not be able to detect network failure in certain
            situations. To avoid this, inactive connections periodically send "ping"
            messages to the server. Default interval is 60 seconds. In some cases
            it may take several intervals to detect network failure.
            The value of this property is a string encoding the ping interval in seconds,
            e.g. "60". Zero value disables ping messages.
            <para>
            This property is defined as String "tibco.tibjms.ping.interval".</para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.DEFAULT_FACTORY_USERNAME">
            <summary>
            Defines the name of the ConnectionFactory property specifying 
            default user name set for Connections created by the factory
            </summary>  
            <remarks>
            <para>This property is defined as string "TIBCO.EMS.factory.username".
            </para>
            <para>Defines the name of a ConnectionFactory property. That property specifies 
            a default username for the connections that the factory creates.
            </para>
            <para>If the client does not supply a username, the connection factory object uses 
            this username as a default when creating a connection. See also 
            <see cref="M:TIBCO.EMS.ConnectionFactory.CreateConnection">ConnectionFactory.CreateConnection</see>.
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.DEFAULT_FACTORY_PASSWORD">
            <summary>
            Defines the name of the ConnectionFactory property specifying 
            default user password set for Connections created by the factory
            </summary> 
            <remarks>
            <para>This property is defined as string "TIBCO.EMS.factory.password".
            </para>
            <para>Defines the name of a ConnectionFactory property. That property specifies 
            a default user password for the connections that the factory creates.
            </para>
            <para>If the client does not supply a password, the connection factory object uses 
            this password as a default when creating a connection. See also 
            <see cref="M:TIBCO.EMS.ConnectionFactory.CreateConnection">ConnectionFactory.CreateConnection</see>.
            </para>
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_LOAD_BALANCE_METRIC">
            <summary>
            Defines the name of the ConnectionFactory property specifying 
            the load balancing metric to be used by the factory.  
            </summary>
            <remarks>
            <para>This field defines the name of a provider-specific 
            <see cref="T:TIBCO.EMS.ConnectionFactory">ConnectionFactory</see> 
            property that governs the assignment of client connections 
            among a set of load-balanced servers.
            </para>
            <para>The load balance metric can be accessed via 
            <see cref="M:TIBCO.EMS.ConnectionFactory.SetMetric(System.Int32)">ConnectionFactory.SetMetric</see> property.
            The valid metrics are:
            </para>
            <list type="bullet">
            <item>FactoryLoadBalanceMetric.None: no metric</item>
            <item>FactoryLoadBalanceMetric.Connections: number of connections on server</item>
            <item>FactoryLoadBalanceMetric.ByteRate: total byte rate (input and output) on server</item>
            </list>
            This property is defined as string "TIBCO.EMS.factory.metric".
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_LOAD_BALANCE_METRIC_NONE">
            <summary>
            Indicates that no load balancing metric has been set for the connection
            factory.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_LOAD_BALANCE_METRIC_CONNECTIONS">
            <summary>
            Indicates that the connection factory load balances connections across
            multiple servers by creating a connection to the server with the fewest
            number of connections.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_LOAD_BALANCE_METRIC_BYTE_RATE">
            <summary>
            Indicates that the connection factory load balances connections across
            multiple servers by creating a connection to the server with the lowest
            total byte rate (input and output).
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_CONNECT_ATTEMPT_COUNT">
            <summary>
            Defines the name of the ConnectionFactory property specifying
            the maximum iterations a client program will go through its URL list
            until it establishes its first connection to an EMS server.
            </summary>
            <remarks>
            This property is defined as String "TIBCO.EMS.connect.attemptcount"
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_CONNECT_ATTEMPT_DELAY">
            <summary>
            Defines the name of the ConnectionFactory property specifying the
            interval between iterations a client program will try to establish
            its first connection to an EMS server.
            </summary>
            <remarks>
            This property is defined as String "TIBCO.EMS.connect.attemptdelay"
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_RECONNECT_ATTEMPT_COUNT">
            <summary>
             Defines the name of the ConnectionFactory property specifying
            the maximum iterations a client program will try to re-establish
            a connection to an EMS server after losing previous connection.
            </summary>
            <remarks>
            This property is defined as String "TIBCO.EMS.reconnect.attemptcount".
            </remarks>
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_RECONNECT_ATTEMPT_DELAY">
            <summary>
            Defines the name of the ConnectionFactory property specifying
            the interval between reconnection attempts.
            </summary>
            <remarks>
             This property is defined as String "TIBCO.EMS.reconnect.attemptdelay".
            </remarks> 
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_CONNECT_ATTEMPT_TIMEOUT">
            <summary>
            Defines the name of the ConnectionFactory property specifying
            the maximum amount of time a client program will wait for the 
            connection to be established to an EMS server
            
            This property is defined as String "TIBCO.EMS.connect.attempttimeout".
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_RECONNECT_ATTEMPT_TIMEOUT">
             <summary>
             Defines the name of the ConnectionFactory property specifying
             the maximum amount of time a client program will wait for the 
             connection to be re-established to an EMS server
            
             This property is defined as String "TIBCO.EMS.reconnect.attempttimeout".
             </summary>
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_MULTICAST_ENABLED">
             <summary>
             Defines the name of the ConnectionFactory property specifying
             whether MessageConsumers subscribed to a multicast-enabled topic
             are to receive messages over multicast or unicast.
            
             This property is defined as String "TIBCO.EMS.multicast.enabled".
             </summary>
             \deprecated As of release 8.3
        </member>
        <member name="F:TIBCO.EMS.Tibems.FACTORY_MULTICAST_DAEMON">
             <summary>
             Defines the name of the ConnectionFactory property specifying
             the port of the multicast daemon used by MessageConsumers subscribed
             to multicast-enabled topics.
            
             This property is defined as String "TIBCO.EMS.multicast.daemon".
             </summary>
             \deprecated As of release 8.3
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetMessageSize(TIBCO.EMS.Message)">
             <summary>
             Returns the total wire size of the message which was received or sent
             </summary>
             <remarks>
             <para> GetMessageSize returns the total size of a message - that is, 
             the number of bytes that traverse the network when the client sends
             the message. This total is slightly larger than the sum of its three 
             constituent parts, because it includes additional control information.
             Furthermore, the server adds its own control information as well, so 
             the size of message as measured by receivers is slightly larger than 
             its size as measured by the sender.</para>
             <para>The size is implicitly measured and cached when an inbound 
             message arrives at the client, and when the client sends an outbound 
             message. If the client modifies a message, or creates a message but 
             never sends it, then this method could yield an incorrect cached 
             value. To explicitly force a new measurement and cache its results, 
             call <see cref="M:TIBCO.EMS.Tibems.CalculateMessageSize(TIBCO.EMS.Message)">Tibems.CalculateMessageSize</see>; 
             then the method yields the correct 
             value.</para>
             </remarks>
             <param name="msg">The message for which to return the size.</param>
             <returns>The total wire size of the message.</returns>
             <exception cref="T:System.ArgumentException">if parameter is null
             or is a foreign message implementation. </exception>
            
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetMessageHeadersSize(TIBCO.EMS.Message)">
             <summary>
             Returns the total wire size of the message headers for a message
             which was received or sent.
             </summary>
             <remarks>
             <para>The size is implicitly measured and cached when an inbound 
             message arrives at the client, and when the client sends an outbound 
             message. If the client modifies a message, or creates a message but 
             never sends it, then this method could yield an incorrect cached 
             value. To explicitly force a new measurement and cache its results, 
             call <see cref="M:TIBCO.EMS.Tibems.CalculateMessageSize(TIBCO.EMS.Message)">Tibems.CalculateMessageSize</see>; 
             then the method yields the correct value.</para>
             </remarks>
             <param name="msg">The message for which to return the size of the message headers.</param>
             <returns>The total size of the message headers.</returns>
             <exception cref="T:System.ArgumentException">if parameter is null
             or is a foreign message implementation.</exception>
            
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetMessagePropertiesSize(TIBCO.EMS.Message)">
             <summary>
             Returns the total wire size of the message properties for a message
             which was received or sent.
             </summary>
             <remarks>
             <para>The size is implicitly measured and cached when an inbound 
             message arrives at the client, and when the client sends an outbound 
             message. If the client modifies a message, or creates a message but 
             never sends it, then this method could yield an incorrect cached 
             value. To explicitly force a new measurement and cache its results, 
             call <see cref="M:TIBCO.EMS.Tibems.CalculateMessageSize(TIBCO.EMS.Message)">Tibems.CalculateMessageSize</see>; 
             then the method yields the correct value.</para>
             </remarks>
             <param name="msg">The message for which to return the size of the message properties.</param>
             <returns>The total size of the message properties.</returns>
             <exception cref="T:System.ArgumentException">if parameter is null
             or is a foreign message implementation.</exception>
            
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetMessageBodySize(TIBCO.EMS.Message)">
             <summary>
             Returns the total wire size of the message body for a message
             which was received or sent.
             </summary>
             <remarks>
             <para>The size is implicitly measured and cached when an inbound 
             message arrives at the client, and when the client sends an outbound 
             message. If the client modifies a message, or creates a message but 
             never sends it, then this method could yield an incorrect cached 
             value. To explicitly force a new measurement and cache its results, 
             call <see cref="M:TIBCO.EMS.Tibems.CalculateMessageSize(TIBCO.EMS.Message)">Tibems.CalculateMessageSize</see>; 
             then the method yields the correct 
             value.</para>
             <para>If the body of the message is compressed, this method returns the size
             of the compressed wire representation.
             </para>
             </remarks>
             <param name="msg">The message for which to return the size of the 
             message body.</param>
             <returns>The total size of the message body.</returns>
             <exception cref="T:System.ArgumentException">if parameter is null
             or is a foreign message implementation.</exception>
            
        </member>
        <member name="M:TIBCO.EMS.Tibems.CalculateMessageSize(TIBCO.EMS.Message)">
             <summary>
             Calculates and returns total size of the message wire representation.
             </summary>
             <remarks>
             <para>The total size includes headers, properties and body.
             </para>
             <para>This method re-measures the message, and caches the results; 
             contrast Tibems.GetMessageSize.
             </para>
             <para>This method might consume process storage, and might involve 
             disk I/O - with associated performance penalties.
             </para>
             <para>This method always creates internally the actual
             wire format of the message regardless of the state of the message.
             </para>
             </remarks>
             <param name="msg">Compute the size of this message.</param>
             <exception cref="T:System.ArgumentException">if parameter is null
             or is a foreign message implementation.</exception>
             <exception cref="T:TIBCO.EMS.EMSException">if an error occurred while building
             message wire representation.</exception>
            
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetAllowCloseInCallback(System.Boolean)">
            <summary>
            Sets if the <see cref="M:TIBCO.EMS.Session.Close">Session.Close</see>,
            <see cref="M:TIBCO.EMS.Connection.Close">Connection.Close</see> or
            <see cref="M:TIBCO.EMS.Connection.Stop">Connection.Stop</see> methods
            can be called in the 
            <see cref="M:TIBCO.EMS.IMessageListener.OnMessage(TIBCO.EMS.Message)">IMessageListener.OnMessage</see> 
            callback.
            </summary>
            <remarks>
            According to the JMS 2.0 specification, calling any of these methods must trigger
            an <see cref="T:TIBCO.EMS.IllegalStateException">IllegalStateException</see>.
            If this property is set then the Close or the Stop method can be called
            inside the callback and it will not throw an exception and will proceed
            without waiting for the same callback to return.
            <b>Note: </b>
            This method replaces the deprecated method SetAllowCallbackInClose.
            </remarks>
            <param name="allow">
            <para>When true, EMS overrides the JMS specification so client 
            callbacks may call Close or Stop methods.</para>
            <para>When false (the default), EMS obeys the JMS specification.</para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetAllowCallbackInClose(System.Boolean)">
            <summary>
            Deprecated, use Tibems.SetAllowCloseInCallback instead.
            </summary>
            \deprecated Use Tibems.SetAllowCloseInCallback instead.
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetAllowCloseInCallback">
            <summary>
            Determine whether client callbacks may call close methods
            </summary>
            <remarks>
            <para>According to the JMS specification, Close methods (that is, 
            <see cref="M:TIBCO.EMS.MessageConsumer.Close">MessageConsumer.Close</see>, 
            <see cref="M:TIBCO.EMS.Session.Close">Session.Close</see>, 
            <see cref="M:TIBCO.EMS.Connection.Close">Connection.Close</see>) cannot 
            return while any message callbacks (that is, 
            <see cref="T:TIBCO.EMS.EMSMessageHandler">EMSMessageHandler</see>, 
            <see cref="M:TIBCO.EMS.IMessageListener.OnMessage(TIBCO.EMS.Message)">IMessageListener.OnMessage</see>) 
            are running. As a result, a message 
            callback must not call a Close method, lest it cause a deadlock.
            The SetAllowCloseInCallback method explicitly overrides this JMS requirement, 
            permitting callbacks to call Close without deadlock (that is, embedded 
            Close calls do not wait for callbacks to return).
            </para>
            This method returns, if it is allowed to call Close in callbacks.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetAllowCallbackInClose">
            <summary>
            Deprecated, use Tibems.GetAllowCloseInCallback instead.
            </summary>
            \deprecated Use Tibems.GetAllowCloseInCallback instead.
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetExceptionOnFTSwitch(System.Boolean)">
            <summary>
            Sets if ExceptionListener set on the Connection should be called after
            fault-tolerant switch.
            </summary>
            <remarks>
            <para>This setting determines exception behavior when the client successfully 
            switches to a different server (fault-tolerant failover).
            </para>
            <para>When an application performs fault-tolerant switch it may notify
            the Connection's ExceptionListener by calling it with EMSException
            providing the information about fault-tolerant switch. If calling
            the Connection's ExceptionListener is set, it is called with the EMSException
            which has the vendor error code (EMSException.getErrorCode) set to
            the String in the form:</para>
            <code>FT-SWITCH: <I>new-server-url</I></code>
            <para>An application can recognize such calls by analyzing the error code
            in the passed EMSException and perform necessary actions. Notice that
            the ExceptionListener is called with the special EMSException 
            only when fault-tolerant switch has been performed succesfully. In case
            the fault-tolerant switch has failed, the Connection's ExceptionListener
            will be called with regular EMSException (it will not have error code in the
            form 'FT-SWITCH: new-server-url') specifying that the connection to 
            Server has been terminated. Notice that by default
            Connection's ExceptionListener is not called
            after a successfull fault-tolerant switch.
            </para>
            <b>Note: </b>
            When the exception listener is called, the exception listener 
            is not allowed to call any EMS method.  To do so in this case risks 
            a deadlock in the client.
            </remarks>
            <param name="callExceptionListener">
            <para>When true, the connection's ExceptionListener catches an EMSException, 
            which contains the name of the new server.</para>
            <para>When false, fault-tolerant failover does not trigger an exception in 
            the client.</para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetExceptionOnFTSwitch">
            <summary>
            Return the fault tolerance exception setting
            </summary>
            <remarks>
            This setting determines exception behavior when the client successfully 
            switches to a different server (fault-tolerant failover).
            <list type="bullet">
            <item>When true, the connection's 
            <see cref="T:TIBCO.EMS.IExceptionListener">ExceptionListener</see> catches an EMSException, 
            which contains the name of the new server.</item>
            <item>When false, fault-tolerant failover does not trigger an exception in the client.</item>
            </list>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetExceptionOnFTEvents(System.Boolean)">
            <summary>
            Sets if ExceptionListener set on the Connection should be called for all 
            the following events: disconnected, each reconnect attempt, and reconnected.
            </summary>
            <remarks>
            <para>
            Similarly to <see cref="M:TIBCO.EMS.Tibems.SetExceptionOnFTSwitch(System.Boolean)">
            Tibems.SetExceptionOnFTSwitch</see>, if this method is called and if a 
            Connection's ExceptionListener is set, (and the connection has FT urls), 
            then all above events will trigger the call to the ExceptionListener.OnException 
            callback with an EMSException which has the vendor error code 
            (EMSException.ErrorCode) 
            set to the String in the form:
            </para>
            <code>FT-SWITCH: event</code>
            <para>
            where <i>event</i> is:
            </para>
            <list type="bullet">
            <item><b>Disconnected from <i>server url</i>, will attempt to reconnect</b></item>
            <item><b>Reconnecting to <i>next server url</i>, attempt <i>n</i> out of <i>m</i></b></item>
            <item><b>Reconnected to <i>server url</i></b></item>
            </list>
            <para>
            An application can recognize such calls by analyzing the error code
            in the passed EMSException and perform necessary actions. Notice that this
            method replaces the method Tibems.SetExceptionOnFTSwitch(), which means 
            that if both are called, only one "reconnected" event will be passed to the 
            ExceptionListener.OnException callback (the one described above). We 
            recommend that if Tibems.SetExceptionOnFTSwitch() was formerly used, 
            and the user wishes to capture all FT events, this new property be used 
            instead and the ExceptionListener.OnException callback modified to handle 
            these new vendor error codes.
            </para>
            <b>Note: </b>
            When the exception listener is called, the exception listener 
            is not allowed to call any EMS method. To do so in this case risks 
            a deadlock in the client.
            </remarks>
            <param name="callExceptionListener">
            <para>When true, the connection's ExceptionListener catches an EMSException, 
            which contains the server url from which the client got disconnected from,
            the server url the client is attempting to reconnect to, and the server url
            to which the client has reconnected to. Each of these events triggers the 
            call to the exception listener.</para>
            <para>When false, fault-tolerant events such as initial disconnection and 
            further reconnect attempts do not trigger call to the exception listener.</para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetExceptionOnFTEvents">
            <summary>
            Returns if exception listener is called on disconnect and reconnect attempts.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetSessionDispatcherDaemon(System.Boolean)">
            <summary>Set the dispatcher thread setting</summary>
            <remarks>
            <para>This method sets if Session dispatcher threads should be daemon.
            Some operating systems may ignore this setting.
            </para>
            <para>When a program uses asynchronous message consumers (either 
            message listeners or .NET message event handler delegates), 
            EMS creates internal dispatcher threads for each Session that 
            has at least one asynchronous message consumer. By default session
            dispatcher threads are <b>not</b> set to be daemon threads.
            </para>
            </remarks>
            <param name="makeDaemon">
            <list type="bullet">
            <item>When true, dispatcher threads are daemon threads.</item>
            <item>When false, (the default) they are not daemon threads.</item>
            </list>
            </param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetSessionDispatcherDaemon">
            <summary>Return the dispatcher thread setting. </summary>
            <remarks>
            <para>When a program uses asynchronous message consumers (either message 
            listeners or .NET message event handler delegates), EMS creates internal 
            dispatcher threads for each Session that has at least one asynchronous 
            message consumer. When this setting is true, those dispatcher threads 
            are daemon threads; when false (the default) they are not daemon threads.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetConnectAttempts(System.String)">
            <summary>
            Modify the connection attempts setting determining the number of 
            attempts the client makes to connect to the server.
            </summary>
            <remarks ref="true()">
            When too many clients connect to the same server, the server may not
            be able to accept all connections at the same time. This parameter
            specifies the number of attempts and delay between the attempt
            the connections perform in order to connect to the server. The value
            of this parameter is a String in the form "NN[,DELAY]" where NN is the
            number of attempts and DELAY is delay in milliseconds between the
            attempts. Minimum value of NN is 1, minimum value of DELAY is 250
            milliseconds.
            </remarks>
            <param name="specs">
            Set the connect setting to these specifications. The value must be string 
            of the form <I>attempts</I> or <I>attempts,delay</I>:
            <list type="bullet">
            <item>attempts limits the number of times that the connection object attempts 
            to establish a connection to the server. When this property is absent, 
            the default value is 2. The minimum value is 1.</item>
            <item>delay is the time (in milliseconds) between connection attempts. When 
            absent, the default value is 500. The minimum value is 250.</item>
            </list>
            </param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetConnectAttempts">
            <summary>
            Returns the connect attempts setting.
            </summary>
            <remarks ref="true()">
            <para>This setting governs all client Connection objects as they attempt to 
            connect to the server. Its value is a string of the form <I>attempts</I> or 
            <I>attempts,delay</I></para>
            <list type="bullet">
            <item>attempts limits the number of times that the connection object attempts 
            to establish a connection to the server. When this property is absent, 
            the default value is 2. The minimum value is 1.</item>
            <item>delay is the time (in milliseconds) between connection attempts. When 
            absent, the default value is 500. The minimum value is 250.</item>
            </list>
            </remarks>
            <returns>The string argument to <see cref="M:TIBCO.EMS.Tibems.SetConnectAttempts(System.String)"/>, rather than the 
            numeric value of the setting. If the client has not set a value, this method 
            returns the null string.</returns>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetConnectAttemptTimeout(System.Int32)">
            <summary>Set the maximum amount of time a client will 
            wait for the connection to be established
            </summary>
            <remarks ref="true()">
            When too many clients connect to the same server, the server may not be 
            able to accept all connections at the same time or may run out of system 
            resources. This method specifies the maxmimum amount of time a client is willing 
            to wait for a connection to be established. Internally the client library 
            will tear down any hung connections (either because of non-availability 
            of system resources or some other EMS server problem) after the timeout 
            period has elapsed. 
            </remarks>
            <param name="timeout">
            <para>Timeout value, in milliseconds. The minimum value is 100 milliseconds, if 
            value less than 100 milliseconds is specified, then the minimum value of 
            100 milliseconds is used.
            </para>
            <para>Default value is 0 (no timeout).</para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetConnectAttemptTimeout">
            <summary>
            Returns the connect attempt timeout value
            </summary>
            <remarks ref="true()">
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetReconnectAttemptTimeout(System.Int32)">
            <summary>Sets the maximum amount of time a client will wait for 
            the reconnect to complete </summary>
            <remarks ref="true()">
            This method is similar to <see cref="M:TIBCO.EMS.Tibems.SetConnectAttemptTimeout(System.Int32)"/>. However, 
            during the initial connect of the clients to the server, the time for 
            each connect attempt is normally distributed and there are less chances 
            of the server exceeding its maximum accept queue. During a fault-tolerant 
            switch, all of the clients automatically try to reconnect to the backup 
            server at approximately the same time. When the number of connections 
            is large, it may require more reconnect time to reconnect than the 
            initial connect. 
            </remarks>
            <param name="timeout">
            <para>Timeout value, in milliseconds. The minimum value is 100 milliseconds, 
            if value less than 100 milliseconds is specified, then the minimum 
            value of 100 milliseconds is used.
            </para>
            <para>Default value is 0 (no timeout).
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetReconnectAttemptTimeout">
            <summary>
            Returns the connect attempt timeout value
            </summary>
            <remarks ref="true()"></remarks>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetReconnectAttempts(System.String)">
            <summary>
            Sets the parameter for the number of attempts the connections
            make to reconnect to the backup server during fault-tolerant switch.
            </summary>
            <remarks ref="true()">
            This parameter is similar to the parameter set by setConnectAttempts 
            method. The difference is that it may be necessary
            to use different parameters during reconnect than during the initial
            connect. Initial connect of the clients to the server is normally
            distributed in time and there are less chances of the server exceeding its
            maximum accept queue. During fault-tolerant switch, all connected clients
            automatically try to reconnect to the backup server, approximately at
            the same time. When the number of connections is large, it may require
            more attempts to reconnect than the initial connect. 
            </remarks>
            <param name="specs">
            Set the reconnect setting to these specifications. The value must be string 
            of the form <I>attempts</I> or <I>attempts,delay</I>:
            <list type="bullet">
            <item>attempts limits the number of times that the connection object attempts 
            to reestablish a connection to the server. When this property is absent, 
            the default value is 4. The minimum value is 1.</item>
            <item>delay is the time (in milliseconds) between reconnection attempts. 
            When absent, the default value is 500. The minimum value is 250.</item>
            </list>
            </param> 
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetReconnectAttempts">
            <summary>Returns the reconnect attempts setting.</summary>
            <remarks ref="true()">
            This setting governs all client Connection objects as they attempt to 
            reconnect to the server after a network disconnect. Its value is a string 
            of the form <I>attempts</I> or <I>attempts,delay</I>:
            <list type="bullet">
            <item>attempts limits the number of times that the connection object attempts 
            to reestablish a connection to the server. When this property is absent, 
            the default value is 4. The minimum value is 1.</item>
            <item>delay is the time (in milliseconds) between reconnection attempts. When 
            absent, the default value is 500. The minimum value is 250.</item>
            </list>
            <para>This method returns the string argument to Tibems.SetReconnectAttempts, 
            rather than the numeric value of the setting. If the client has not set a value, 
            this method returns the null string.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetSocketReceiveBufferSize(System.Int32)">
            <summary>Set the size of socket receive buffers</summary>
            <remarks>
            <para>This value overrides the operating system's default for the 
            size of receive buffers associated with sockets that the client 
            uses for connections to the server.
            </para>
            <para>Use this call before creating server connections. This call sets 
            an override buffer size for new socket buffers; it does not change 
            the size of existing socket buffers.
            </para>
            </remarks>
            <param name="size">Sockets use receive buffers of this size 
            (in kilobytes).</param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetSocketReceiveBufferSize">
            <summary>
            Returns the size of socket receive buffer.
            </summary>
            <remarks>
            <para>When set, this value overrides the operating system's default for 
            the size of receive buffers associated with sockets that the client 
            uses for connections to the server. (Some operating systems do not 
            allow you to override the default size.)
            </para>
            </remarks>
            <returns>The size of the socket's receive buffer.</returns>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetSocketSendBufferSize(System.Int32)">
            <summary>Set the size of socket send buffers</summary>
            <remarks>
            <para>This value overrides the operating system's default 
            for the size of send buffers associated with sockets that 
            the client uses for connections to the server.
            </para>
            <para>Use this call before creating server connections. This call 
            sets an override buffer size for new socket buffers; it does 
            not change the size of existing socket buffers.
            </para>
            Sets the size of the socket send buffer size for client connections.
            Some operating systems may ignore this setting.
            </remarks>
            <param name="size">Sockets use send buffers of this size 
            (in kilobytes).</param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetSocketSendBufferSize">
            <summary>
            Return the size of socket send buffer</summary>
            <remarks>
            When set, this value overrides the operating system's default for the 
            size of send buffers associated with sockets that the client uses for 
            connections to the server. (Some operating systems do not allow you to 
            override the default size.)
            </remarks>
            <returns>The size of the socket's send buffer.</returns>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetPingInterval(System.Int32)">
            <summary>
            Set the interval at which the client tests network connectivity
            </summary>
            <remarks>
            Clients test network connectivity by sending ping requests to the 
            server at regular intervals. This method sets that interval (in 
            seconds). If your program calls this method, it must do so before 
            creating its first Connection object; after creating that object, 
            this call has no effect.
            </remarks>
            <param name="seconds">Ping at this interval (in seconds).
            <para>Zero is a special value that disables ping testing.</para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetPingInterval">
            <summary>
            Return the ping interval in seconds used by inactive connections
            </summary>
            <remarks>
            Clients test network connectivity by sending ping requests to the server 
            at regular intervals. This method returns that interval (in seconds). Zero 
            is a special value that disables ping testing.
            </remarks>
            <returns>The ping interval in seconds </returns>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetProperty(System.String)">
            <summary>Retrieve the property value given the property name</summary>
            <remarks>
            <para>The properties here refer to those explicitly set by 
            calling <see cref="M:TIBCO.EMS.Tibems.SetProperty(System.String,System.Object)"/> or system
            properties (e.g <see cref="F:TIBCO.EMS.Tibems.PROP_PING_INTERVAL"/> etc.) 
            set by either calling the specific methods 
            (e.g <see cref="M:TIBCO.EMS.Tibems.SetPingInterval(System.Int32)"/>) or system properties set 
            via <see cref="M:TIBCO.EMS.Tibems.SetProperty(System.String,System.Object)"/>.
            </para>
            <para>You can supply any of the following constants:
            <list type="bullet">
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_SOCKET_RECEIVE"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_SOCKET_SEND"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_CONNECT_ATTEMPTS"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_RECONNECT_ATTEMPTS"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_CLOSE_IN_CALLBACK"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_PING_INTERVAL"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_FT_SWITCH_EXCEPTION"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_MESSAGE_ENCODING"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_DAEMON_DISPATCHER"/></item>
            </list>
            The constants 
            are defined as static fields of Tibems. The values of those constants are 
            the actual property names.
            </para>
            <para>In .NET, methods exist to get and set the properties. This method 
            provides an alternate way to get property values, which is consistent 
            with the EMS Java API (for easy porting to .NET).
            </para>
            <para><b>NOTE:</b> In case of system properties if the values are never set then the 
            default values are returned. </para>
            </remarks>
            <param name="key">Return the value associated with this property name.</param>
            <returns>The value for the given property.  If the property is not
            set, null is returned </returns>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetProperty(System.String,System.Object)">
            <summary>Modify a property value</summary>
            <remarks>
            <para>In .NET, methods exist to get and set the properties. 
            SetProperty provides an alternate 
            way to set property values, which is consistent with the 
            EMS Java API (for easy porting to .NET).
            </para>
            <para>You can supply any of the following constants:
            <list type="bullet">
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_SOCKET_RECEIVE"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_SOCKET_SEND"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_CONNECT_ATTEMPTS"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_RECONNECT_ATTEMPTS"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_CLOSE_IN_CALLBACK"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_PING_INTERVAL"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_FT_SWITCH_EXCEPTION"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_MESSAGE_ENCODING"/></item>
            <item><see cref="F:TIBCO.EMS.Tibems.PROP_DAEMON_DISPATCHER"/></item>
            </list>
            The constants are defined as static fields of Tibems. 
            The values of those constants are the actual property names. 
            </para>
            </remarks>
            <param name="key">Set the value associated with this property name.
            </param>
            <param name="val">Set the property to this value.</param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetEncoding(System.String)">
            <summary> 
            Set global string encoding for messages
            </summary>
            <remarks>
            <para>Clients can override the global encoding for individual messages. 
            When neither a global nor an individual message encoding has been set, 
            then EMS encodes the strings of an outbound message using the default 
            UTF-8 encoding.
            </para>
            <para>This encoding applies to all strings in message body fields (names and values), 
            and properties (names and values). It does not apply to message header fields. 
            The methods BytesMessage.ReadUTF and BytesMessage.WriteUTF are exempt from 
            global and individual encoding settings.
            </para>
            <b>Note: </b>
            The only encoding names that are supported by the .NET client are
            the ones defined by the .NET framework. Please refer to the .NET framework
            documentation for a complete list of the encoding names supported by the .NET 
            framework. 
            </remarks>
            <param name="encodingName"> The name of the encoding (for example, "utf-8").
            For a list of standard encoding names, see www.iana.org. </param>
            <exception cref="T:TIBCO.EMS.EMSException"> If the encoding is not supported. </exception>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetEncoding">
            <summary>
            Return the name of the global string encoding for messages 
            </summary>
            <remarks> 
            <para>Programs can override the global encoding for individual messages. 
            When neither a global nor an individual message encoding has been set, 
            then EMS encodes the strings of an outbound message using the 
            default UTF-8 encoding.
            </para>
            <para>This encoding applies to all strings in message bodies (names and values), 
            and properties (names and values). It does not apply to header names or 
            values. The methods 
            <see cref="M:TIBCO.EMS.BytesMessage.ReadUTF">BytesMessage.ReadUTF</see> and 
            <see cref="M:TIBCO.EMS.BytesMessage.WriteUTF(System.String)">BytesMessage.WriteUTF</see> are 
            exempt from global and individual encoding settings.
            </para>
            </remarks>
            <returns> The name of the encoding used for global string encoding for message, 
            or null global encoding has not been set.</returns>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetMessageEncoding(TIBCO.EMS.Message,System.String)">
            <summary>
            Set the character encoding for an individual message 
            </summary>
            <remarks>
            <para>This encoding for an individual message overrides the global 
            encoding. When neither a global nor an individual message encoding 
            has been set, then EMS encodes the strings of an outbound message 
            using the default UTF-8 encoding.
            </para>
            <para>This encoding applies to all strings in message bodies (names and values), 
            and properties (names and values). It does not apply to header names or 
            values. The methods 
            <see cref="M:TIBCO.EMS.BytesMessage.ReadUTF">BytesMessage.ReadUTF</see> and 
            <see cref="M:TIBCO.EMS.BytesMessage.WriteUTF(System.String)">BytesMessage.WriteUTF</see> are 
            exempt from global and individual encoding settings.
            </para>  
            </remarks>
            <param name="message">Set the encoding for this message.</param>
            <param name="encodingName"> The name of the encoding (for example, "utf-8").
            For a list of standard encoding names, see www.iana.org. </param>
            <exception cref="T:TIBCO.EMS.EMSException">If the encoding is not supported </exception>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetMessageEncoding(TIBCO.EMS.Message)">
            <summary>
            Return string encoding name set for this message
            </summary>
            <remarks>
            <para>This encoding for an individual message overrides the global encoding. 
            When neither a global nor an individual encoding has been set, then EMS 
            encodes the strings of an outbound message using the default UTF-8 encoding.
            </para>
            <para>This encoding applies to all strings in message bodies (names and values), 
            and properties (names and values). It does not apply to header names nor 
            values. The methods BytesMessage.ReadUTF and BytesMessage.WriteUTF are exempt 
            from global and individual encoding settings.
            </para>
            </remarks>
            <param name="message">Get the encoding for this message.</param>
            <returns> The string encoding name for this message, or null is no encoding is set. </returns>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetAsBytes(TIBCO.EMS.Message)">
            <summary>
            Return a copy of the message data as a byte array, suitable for archiving in a file
            </summary>
            <remarks>
            To reconstruct the message from bytes use method createFromBytes.
            Parameter must be an instance of TIBCO Enterprise Message Service Message object.
            </remarks>
            <param name="message">The source message with which to fill the byte array. </param>
            <returns>The byte array as a copy of the message. </returns>
        </member>
        <member name="M:TIBCO.EMS.Tibems.CreateFromBytes(System.Byte[])">
            <summary>
            Create a message from specified byte array
            </summary>
            <remarks>
            Specified byte array must be previously obtained using the <see cref="M:TIBCO.EMS.Tibems.GetAsBytes(TIBCO.EMS.Message)"/> method.
            Created message is set to read-only state, use the <see cref="M:TIBCO.EMS.Tibems.MakeWriteable(TIBCO.EMS.Message)"/> method to enable
            message modification without erasing its content.
            </remarks>
            <param name="bytes">The byte array representation of the message. 
            This byte array must be the result of previously calling 
            <see cref="M:TIBCO.EMS.Tibems.GetAsBytes(TIBCO.EMS.Message)"/>. </param>
            <returns>The message constructed from the byte array </returns>
        </member>
        <member name="M:TIBCO.EMS.Tibems.MakeWriteable(TIBCO.EMS.Message)">
            <summary>
            Set message to writeable state without resetting its content.
            </summary>
            <param name="message">The message to become writeable. </param>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetConnectionActiveURL(TIBCO.EMS.Connection)">
            <summary> Return the URL of the EMS server for the specified connection. </summary>
            <param name="connection">The connection to the EMS server.</param>
            <returns> The string representing the URL </returns>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetNPSendCheckMode(TIBCO.EMS.MessageProducer,System.Int32)">
            <summary>
            Set the mode defining when a producer should check the result of sending
            a <c>NON_PERSISTENT</c> message.
            </summary>
            <remarks>
            <para>
            This mode only applies to messages sent using the
            <c>MesssageDeliveryMode.NonPersistent</c> delivery mode and a
            non-transactional <c>Session</c>; it does <b>not</b> apply to cases
            when a message was sent using <c>MessageDeliveryMode.Persistent</c>
            or the {<see cref="F:TIBCO.EMS.MessageDeliveryMode.ReliableDelivery"/>} delivery mode
            or if the corresponding <c>Session</c> is transactional.
            If the producer's send check mode is not set, it may execute the mode applied
            globally to all producers via the EMS server parameter. Setting any mode other
            than {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_DEFAULT"/>} unconditionally overrides the
            global setting defined by the server.
            </para>
            <para>
            Normally, applications use the server's setting or configure producers with
            a specific send mode only once. However, if required, applications may choose
            to change this mode before sending every message.
            </para>
            <para>
            When a producer does not check the result of sending a message, it will not
            know if any problem has occurred and the message was not processed by the
            server. If a producer checks the result of the send, the <c>Send</c>
            method will receive the server's response to the send and throw the appropriate
            exception if any problem has occurred. However, this will reduce the producer's
            performance.
            </para>
            </remarks>
            <param name="producer"> message producer, must not be <c>null</c>
            </param>
            <param name="mode"> one of constants {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_DEFAULT"/>},
            {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_ALWAYS"/>}, {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_NEVER"/>},
            {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_TEMP_DEST"/>}, {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_AUTH"/>}
            or {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_TEMP_AUTH"/>}  
            </param>
            <exception cref="T:System.ArgumentException"> if the producer is <c>null</c> or if
            the mode value is invalid.
            </exception>
            <see cref="M:TIBCO.EMS.Tibems.GetNPSendCheckMode(TIBCO.EMS.MessageProducer)"/>
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetNPSendCheckMode(TIBCO.EMS.MessageProducer)">
            <summary>
            Return the mode defining when a producer checks the result of sending
            a <c>NON_PERSISTENT</c> message.
            </summary>
            <remarks>
            This method returns the send check mode previously set by 
            {<see cref="M:TIBCO.EMS.Tibems.SetNPSendCheckMode(TIBCO.EMS.MessageProducer,System.Int32)"/>}
            method. Notice that if the returned value is {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_DEFAULT"/>}
            then the effective mode can be set by the server parameter applied to all producers.
            </remarks>
            <param name="producer"> message producer, must not be <c>null</c>
            </param>
            <returns> one of constants {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_DEFAULT"/>},
            {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_ALWAYS"/>}, {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_NEVER"/>},
            {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_TEMP_DEST"/>}, {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_AUTH"/>}
            or {<see cref="F:TIBCO.EMS.Tibems.NPSEND_CHECK_TEMP_AUTH"/>}  
            </returns>
            <exception cref="T:System.ArgumentException"> if producer is <c>null</c>
            </exception>
            <see cref="M:TIBCO.EMS.Tibems.SetNPSendCheckMode(TIBCO.EMS.MessageProducer,System.Int32)"/>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetTraceFile(System.String)">
            <summary>
            Use this method to instruct the TIBCO EMS Client library to direct
            the tracing, that would normally go to stderr or stdout, to a file named
            <b>fileName</b>.
            </summary>    
            <remarks>
            <para>
            This call alone does not generate tracing, that is, the tracing still needs 
            to be enabled as usual: from the admin tool and/or with the ssl trace 
            parameter in order to trace SSL connections' handshake.
            </para>
            <para>
            The trace file is opened in append mode. An IOException will be
            thrown if the file can not be opened, and the tracing will be directed to
            stderr or stdout based on the connection's tracing setting (check the admin
            command <c>set server client_trace</c> for more details).
            </para>
            <para>
            Since there is only one trace file allowed, an InvalidOperationException
            will be thrown if this method is called with a non null file name after a
            trace file has already been set.
            </para>
            <para>
            Pass <c>null</c> to this method to instruct the TIBCO EMS Client library
            to stop directing tracing to the file. Normal tracing (stderr or stdout) will then
            resume.
            </para>
            </remarks>   
            <param name="fileName"> the name of the TIBCO EMS Client trace file for this application, 
            or <c>null</c> to stop directing tracing to the file.
            </param>   
            <exception cref="T:System.InvalidOperationException"> if this method is called twice with 
            a non null fileName.</exception>
            <exception cref="T:System.IO.IOException"> if an error occurs while opening/creating 
            the file.</exception>
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetMulticastEnabled(System.Boolean)">
            <summary>
            Set whether MessageConsumers subscribed to a multicast-enabled topic
            will receive messages over multicast.</summary>
            <remarks>
            When enabled, MessageConsumers subscribed to a multicast-enabled topic
            will receive messages over multicast. The default is enabled.
            </remarks>
            <param name="enabled">
            true to enable multicast, false to disable multicast. Default value is enabled.
            </param>
            \deprecated As of release 8.3
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetMulticastEnabled">
            <summary>
            Get whether MessageConsumers subscribed to a multicast-enabled topic
            will receive messages over multicast.
            </summary>
            \deprecated As of release 8.3
        </member>
        <member name="M:TIBCO.EMS.Tibems.SetMulticastDaemon(System.String)">
            <summary>
            Set the port on which the EMS client will connect to the multicast
            daemon.
            </summary>
            <remarks>
            A connection to the multicast daemon is required when multicast is
            enabled and a MessageConsumer is subscribed to a multicast-enabled
            topic. Setting the port with this method will override the default
            port supplied by the server and the port specified on the connection
            factory.
            </remarks>
            <param name="port">
            the port of the multicast daemon
            </param>
            \deprecated As of release 8.3
        </member>
        <member name="M:TIBCO.EMS.Tibems.GetMulticastDaemon">
            <summary>
            Get the port on which the EMS client will connect to the multicast
            daemon.
            </summary>
            \deprecated As of release 8.3
        </member>
        <member name="M:TIBCO.EMS.Tibems.IsConsumerMulticast(TIBCO.EMS.MessageConsumer)">
            <summary>
            Checks if a MessageConsumer is receiving messages over multicast.
            </summary>
            <param name="consumer">
            the MessageConsumer to check
            </param>
            \deprecated As of release 8.3
        </member>
        <member name="E:TIBCO.EMS.Tibems.MulticastExceptionHandler">
            <summary> The multicast exception event handler</summary>
            <remarks> 
            <para>The client library raises an event if it detects a problem with EMS 
            multicast.  The program implements a handler delegate to processes it 
            asynchronously and registers the delegate here.</para>
            
            Delegate declaration for multicast exception handler is as follows: 
            <code>
            public delegate void EMSMulticastExceptionHandler(object sender, EMSExceptionEventArgs args); <br/>
            sender: The source of the event, the connection in this case. <br/>
            args: The event argument, <see cref="T:TIBCO.EMS.EMSExceptionEventArgs"/> <br/> 
            </code>
            <example>Example of using the exception event handler:
            <code>
            ...
            Tibems.MulticastExceptionHandler += new EMSMulticastExceptionHandler(handleEx);
            ...
            private void handleEx(object sender, EMSExceptionEventArgs arg)
            {
               Connection   connection = arg.Connection;
               Session      session    = arg.Session;
               Consumer     consumer   = arg.Consumer;
               EMSException e          = arg.Exception;
               Console.WriteLine("Exception: " + e.Message);
            }
            ...
            </code> 
            </example>
            </remarks>
            \deprecated As of release 8.3
        </member>
        <member name="M:TIBCO.EMS.Tibems.RecoverMsg(TIBCO.EMS.Message)">
            <summary>
            Recover a single message.
            </summary>
            <param name="msg">
            the Message to recover
            </param>
        </member>
        <member name="T:TIBCO.EMS.EMSMulticastExceptionEventArgs">
            <summary>Presents a multicast problem as a .NET event. </summary>
            <remarks>
            <see cref="T:TIBCO.EMS.EMSMulticastExceptionHandler"/> delegates receive this object as an argument.
            </remarks>
            \deprecated As of release 8.3
        </member>
        <member name="M:TIBCO.EMS.EMSMulticastExceptionEventArgs.#ctor(TIBCO.EMS.Connection,TIBCO.EMS.Session,TIBCO.EMS.MessageConsumer,TIBCO.EMS.EMSException)">
            <summary> Construct a new EMSExceptionEventArgs</summary>
            <param name="connection">The connection </param>
            <param name="session">The session </param>
            <param name="consumer">The MessageConsumer </param>
            <param name="emse">The EMSException which raised the event </param>
        </member>
        <member name="P:TIBCO.EMS.EMSMulticastExceptionEventArgs.Exception">
            <summary> Get the EMSException that caused the event </summary>
        </member>
        <member name="P:TIBCO.EMS.EMSMulticastExceptionEventArgs.Connection">
            <summary> Get the Connection on which this event occurred. </summary>
        </member>
        <member name="P:TIBCO.EMS.EMSMulticastExceptionEventArgs.Session">
            <summary> Get the Session on which this event occurred. </summary>
        </member>
        <member name="P:TIBCO.EMS.EMSMulticastExceptionEventArgs.Consumer">
            <summary> Get the Consumer affected by this event.  This may 
            be null in some situations </summary>
        </member>
        <member name="T:TIBCO.EMS.EMSMulticastExceptionHandler">
            <summary> Delegate declaration for the multicast exception handler </summary>
            <remarks>
            <para>Asynchronously detect problems with connections.
            </para>
            <para>When a program uses EMS mutlicast, EMS can detect problems with 
            multicast and notify the client program by throwing exceptions or invoking
            this delegate.
            </para>
            <para>This delegate provides a pathway for alerting a client program of multicast 
            problems. The program implements this delegate, and registers it.
            When the client library detects or is notified of a multicast problem, 
            it raises an event. This delegate processes the event, 
            which contains an exception that details the problem.
            </para>
            <para>EMSMulticastExceptionHandler detects this type of problem in a .NET programming idiom.
            </para>
            
            <para><b>Multicast Exception Event Handler Example:</b></para>
            <code>
            ...
            Tibems.MulitcastExceptionHandler += new EMSMulticastExceptionHandler(handleEx);
            ...
            private void handleEx(object sender, EMSMulticastExceptionEventArgs arg)
            {
               EMSException e = arg.Exception;
               Console.WriteLine("Exception: " + e.Message);
            }
            ...
            </code>
            </remarks>
            <param name="sender">The source of the event, the <see cref="T:TIBCO.EMS.Connection"/> object in this case.</param>
            <param name="args">The event argument, <see cref="T:TIBCO.EMS.EMSExceptionEventArgs"/>, that 
            contains the exception object.</param>
            \deprecated As of release 8.3
        </member>
        <member name="T:TIBCO.EMS.Topic">
            <summary>A Topic object encapsulates a TIBCO EMS specific topic name.</summary>
            <remarks ref="true()">
            <para> Topics deliver each message to multiple consumers.</para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.Topic.#ctor">
            <summary> Constructs a new Topic object. </summary>
        </member>
        <member name="M:TIBCO.EMS.Topic.#ctor(System.String)">
            <summary> Constructs a new Topic object with the given name.  </summary>
            <remarks>
            <para>This constructor either creates a dynamic 
            Topic or obtains a Topic object that is already configured on the server. </para>
            <para>
            This constructor creates only local Topic objects (within the program). It does not 
            attempt to lookup the corresponding server Topic object until the program creates a 
            MessageConsumer or a MessageProducer that uses the topic. That automatic 
            lookup can result in either of two outcomes:
            <list type="bullet">
            <item><description>If lookup succeeds, it binds the local Topic object to the server Topic object.</description></item>
            <item><description>If lookup fails, the server creates a new dynamic topic.</description></item>
            </list>
            </para>
            </remarks>
            <param name="name"> Name of the topic to find or create. </param>
        </member>
        <member name="M:TIBCO.EMS.Topic.#ctor(System.String,System.String)">
            <summary> Constructor a new topic object with the given address and jndi name </summary>
            <param name="name"> address of the topic </param>
            <param name="jndiName"> jndi name of the topic </param>
        </member>
        <member name="M:TIBCO.EMS.Topic.Clone">
            <summary>
            Implementation of ICloneable.  Overrides the cloning process.
            </summary>
            <returns>A object that is a clone of this Topic instance.
            </returns>
        </member>
        <member name="M:TIBCO.EMS.Topic.Equals(System.Object)">
            <summary> Compare with another object for equality. </summary>
            <remarks> The current instance is said to be equals to another
            object when the latter is also a <c>Topic</c> instance and
            both have the same address. </remarks>
            <param name="obj">The object to compare with </param>
            <returns>true if the object passed is also of type <c>Topic</c> and
            has the same address as the current instance, false otherwise.
            </returns>
        </member>
        <member name="M:TIBCO.EMS.Topic.GetHashCode">
            <summary>
            Returns a hashcode representing the current object
            </summary>
            <returns>A hashcode based on the <c>Topic</c>.
            </returns>
        </member>
        <member name="P:TIBCO.EMS.Topic.TopicName">
            <summary> Gets the name of the topic </summary>
            <remarks>Each topic has a name that is unique among all topics.</remarks>
            <returns>The name of the topic, if not set, null is returned </returns>
        </member>
        <member name="M:TIBCO.EMS.Topic.ToString">
            <summary>Returns a string representation of this <c>Topic</c> object.
            </summary>
            <returns>A string representation </returns>
        </member>
        <member name="T:TIBCO.EMS.TopicConnection">
            <summary>A TopicConnection object is an active connection 
            to a publish/subscribe TIBCO EMS Server.  </summary>
            <remarks>
            <b>Note: </b>
            This class is provided for backward compatibility to support older EMS clients programs. 
            New clients should use the <see cref="T:TIBCO.EMS.Connection">Connection</see> class instead.
            <para>
            A TopicConnection creates a <see cref="T:TIBCO.EMS.TopicSession">TopicSession</see> 
            for producing and consuming messages.
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.TopicConnection.#ctor(TIBCO.EMS.CFImpl,System.String,System.String,System.String,System.String,System.Collections.Hashtable)">
            <summary>Construct a topic connection instance with information </summary>
            <param name="factory">The connection factory instance, of type
            <c>ConnectionFactory</c>, <c>TopicConnectionFactory</c>, 
            </param>
            <param name="urlString">The url of the server </param>
            <param name="clientID">The id of the client </param>
            <param name="userName">The user name of the client </param>
            <param name="password">The user password of the client </param>
            <param name="properties">The hashtable of properties for the client. </param>
        </member>
        <member name="M:TIBCO.EMS.TopicConnection.CreateTopicSession(System.Boolean,System.Int32)">
            <summary> Creates a TopicSession object. </summary>    
            <remarks>
            <b>Note: </b>
            This method is provided for backward compatibility to support older EMS clients programs. 
            <para>
            The new topic session uses the connection for all server communications.
            </para>
            </remarks>
            <param name="transacted"><para>Indicates whether the session is transacted.</para>
            <para>When true, the new session has transaction semantics.</para>
            <para>When false, it has non-transaction semantics.</para>
            </param>
            <param name="acknowledgeMode"><para>Indicates whether and how the consumer  
            is to acknowledge received messages. </para>
            <para>This version of CreateTopicSession accepts an integer value associated with
            the acknowledge mode described by a <see cref="T:TIBCO.EMS.Session">Session</see> member
            and should only be used for backward compatibility.</para>
            <para>This parameter is ignored if the session is transacted. </para>
            </param>
            <returns>A newly created topic session </returns>
        </member>
        <member name="M:TIBCO.EMS.TopicConnection.CreateTopicSession(System.Boolean,TIBCO.EMS.SessionMode)">
            <summary> Creates a TopicSession object. </summary>
            <remarks>
            <b>Note: </b>
            This method is provided for backward compatibility to support older EMS clients programs. 
            <para>
            The new topic session uses the connection for all server communications.
            </para>
            </remarks>
            <param name="transacted">Indicates whether the session is transacted.
            <para>When true, the new session has transaction semantics.</para>
            <para>When false, it has non-transaction semantics.</para>
            </param>
            <param name="acknowledgeMode"><para>Indicates whether and how the consumer  
            is to acknowledge received messages. </para>
            <para>Legal values are listed under <see cref="T:TIBCO.EMS.SessionMode">SessionMode</see>.
            </para>
            <para>This parameter is ignored if the session is transacted. </para>
            </param>
            <returns>A newly created topic session </returns>
        </member>
        <member name="T:TIBCO.EMS.TopicConnectionFactory">
            <summary>Backward compatibility. Administered object for creating topic connections.</summary>
            <remarks>
            <b>Note: </b>
            This class is provided for backward compatibility to support older EMS clients programs. 
            New clients should use the <see cref="T:TIBCO.EMS.ConnectionFactory">ConnectionFactory</see> class instead.
            <para>A client uses a TopicConnectionFactory object to create TopicConnection
            objects with the EMS Server.
            </para>
            <para>This class is provided only to support older clients.  New clients should use the 
            <see cref="T:TIBCO.EMS.ConnectionFactory">ConnectionFactory</see> object. 
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.TopicConnectionFactory.#ctor">
            <summary> Construct an empty TopicConnectionFactory </summary>
        </member>
        <member name="M:TIBCO.EMS.TopicConnectionFactory.#ctor(System.String)">
            <summary> Construct an TopicConnectionFactory given the server url </summary>
            <remarks> 
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The url to the server </param>
        </member>
        <member name="M:TIBCO.EMS.TopicConnectionFactory.#ctor(System.String,System.String)">
            <summary> Construct an TopicConnectionFactory given the server url and client id.</summary>
            <remarks> 
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The url to the server </param>
            <param name="clientId">The id to the client </param>
        </member>
        <member name="M:TIBCO.EMS.TopicConnectionFactory.#ctor(System.String,System.String,System.Collections.Hashtable)">
            <summary> Construct an TopicConnectionFactory given the server url, client id and
            properties </summary>
            <remarks> 
            <para>
            <b> Reconnect and Fault Tolerance </b>
            </para>
            <para> To enable reconnection behavior and fault tolerance, the 
            connection factory's server URL parameter must be a comma-separated 
            list of two or more URLs. To enable client reconnection in a situation 
            with only one server, you may supply two copies of that server's 
            URL (for example, tcp://localhost:7222,tcp://localhost:7222)
            </para>
            </remarks>
            <param name="serverUrl">The url to the server </param>
            <param name="clientId">The id to the client </param>
            <param name="properties">The properties for creating connection such as username and password </param>
        </member>
        <member name="M:TIBCO.EMS.TopicConnectionFactory.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> ISerializable constructor </summary>
        </member>
        <member name="M:TIBCO.EMS.TopicConnectionFactory.Clone">
            <summary>
            Implementation of ICloneable.  Overrides the cloning process.
            </summary>
            <returns>A object that is a clone of this TopicConnectionFactory instance.
            </returns>
        </member>
        <member name="M:TIBCO.EMS.TopicConnectionFactory.CreateTopicConnection">
            <summary> Create a topic connection object.  </summary>
            <remarks>The connection object presents a default user identity. If the 
            server configuration permits that user, then the call succeeds.</remarks>
            <returns>The newly created TopicConnection.</returns>
        </member>
        <member name="M:TIBCO.EMS.TopicConnectionFactory.CreateTopicConnection(System.String,System.String)">
            <summary> Create a topic connection object for a specific user.  </summary>
            <param name="userName">The username to use to create connection. </param>
            <param name="password">Authenticate the user identity with this password. </param>
            <returns>The newly created TopicConnection.</returns>
        </member>
        <member name="T:TIBCO.EMS.TopicName">
            <summary>
             A class to hold the response from the TIBCO Enterprise Message Service
            naming server in response to a topic lookup.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.TopicPublisher">
            <summary>A client uses a TopicPublisher object to publish messages on a topic. 
            A TopicPublisher object is the publish-subscribe form of a message producer. 
            </summary>
            <remarks>
            <para>This class extends <see cref="T:TIBCO.EMS.MessageProducer">MessageProducer</see>.  
            It overloads more send methods, specializing the destination parameter to a queue.
            </para>
            <para> Normally, the Topic is specified when a TopicPublisher is created. 
              In this case, an attempt to use the publish methods for an unidentified 
              TopicPublisher will throw a UnsupportedOperationException. 
              </para>
              <para> If the TopicPublisher is created with an unidentified Topic, 
              an attempt to use the publish methods that assume that the Topic has
              been identified will throw a UnsupportedOperationException. 
            </para>
            <para>During the execution of its publish method, a message must
               not be changed by other threads within the client. If the message 
               is modified, the result of the publish is undefined. 
            </para>
            <para>After publishing a message, a client may retain and modify 
              it without affecting the message that has been published. 
              The same message object may be published multiple times. 
            </para>
            <para>The following message headers are set as part of publishing a message: 
              Destination, DeliveryMode, Expiration, Priority, MessageID 
              and TimeStamp. When the message is published, the values of 
              these headers are ignored. After completion of the publish, the
              headers hold the values specified by the method publishing the message.
              It is possible for the publish method to not set the 
            MessageID and TimeStamp if they are explicitly disabled by setting the 
            <see cref="P:TIBCO.EMS.MessageProducer.DisableMessageID">MessageProducer.DisableMessageID</see> or 
            <see cref="P:TIBCO.EMS.MessageProducer.DisableMessageTimestamp">MessageProducer.DisableMessageTimestamp</see> 
            property. 
            </para>
            <para>
            Creating a <see cref="T:TIBCO.EMS.MessageProducer">MessageProducer</see> 
            provides the same features as creating a TopicPublisher. 
            A <see cref="T:TIBCO.EMS.MessageProducer">MessageProducer</see> object is recommended when 
            creating new code. The TopicPublisher is provided to support existing code. 
            Because TopicPublisher inherits from <see cref="T:TIBCO.EMS.MessageProducer">MessageProducer</see>, 
            it inherits the 
            send methods that are a part of the <see cref="T:TIBCO.EMS.MessageProducer">MessageProducer</see> 
            interface. Using the send methods will have the same effect as using the 
            publish methods: they are functionally the same
            </para>
            </remarks>
            <b>Note: </b>
            This class is provided for backward compatibility to support older EMS clients programs. 
            New clients should use the <see cref="T:TIBCO.EMS.MessageProducer">MessageProducer</see> class instead.
            
        </member>
        <member name="M:TIBCO.EMS.TopicPublisher.#ctor(TIBCO.EMS.Session,System.Int64,TIBCO.EMS.Topic)">
            <summary>Construct a new topic publisher given session, topic and id</summary>
             <param name="session">The session that the topic publisher is on </param>
             <param name="prodid">The id of this message producer </param>
             <param name="topic">The topic destination to publish messages on. </param>
        </member>
        <member name="P:TIBCO.EMS.TopicPublisher.Topic">
            <summary> Gets the topic associated with this TopicPublisher. </summary>
            <remarks>
            <para>Each send call directs a message to a topic.
            </para>
            <para>A client can use this property to define a default topic for messages that 
            this publisher sends. Individual sending calls can override this default value.
            </para>
            <para>A client sets this topic when creating the publisher, and cannot subsequently change it.
            </para>
            </remarks>
            <returns>this publisher's topic </returns>
        </member>
        <member name="M:TIBCO.EMS.TopicPublisher.Publish(TIBCO.EMS.Message)">
            <summary> Publishes a message to the topic. Uses the 
            TopicPublisher's default delivery mode, priority, and time to live. </summary>
            <param name="message">The message to publish. </param>
        </member>
        <member name="M:TIBCO.EMS.TopicPublisher.Publish(TIBCO.EMS.Message,System.Int32,System.Int32,System.Int64)">
            <summary>Publishes a message to the topic, specifying delivery mode, 
            priority, and time to live. 
            </summary>
            <param name="message">The message to publish.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.
            </param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para>
            </param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.TopicPublisher.Publish(TIBCO.EMS.Message,TIBCO.EMS.MessageDeliveryMode,System.Int32,System.Int64)">
            <summary>Publishes a message to the topic, specifying delivery mode, 
            priority, and time to live. </summary>
            <param name="message">The message to publish.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.
            </param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para>
            </param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.TopicPublisher.Publish(TIBCO.EMS.Topic,TIBCO.EMS.Message)">
            <summary> 
            Publishes a message to a topic for an unidentified message producer. 
            Uses the TopicPublisher's default delivery mode, priority, and time to live. 
            </summary>
            <remarks>
            <para>
            Typically, a message producer is assigned a topic at creation time; however, 
             the TIBCO EME .NET API also supports unidentified message producers, 
            which require that the topic be supplied every time a message is published. 
            </para> </remarks>
            <param name="topic">The <see cref="T:TIBCO.EMS.Topic">Topic</see> to which this 
            message is to be published.</param>
            <param name="message">The message to publish.</param>
            
        </member>
        <member name="M:TIBCO.EMS.TopicPublisher.Publish(TIBCO.EMS.Topic,TIBCO.EMS.Message,System.Int32,System.Int32,System.Int64)">
            <summary> Publishes a message to a topic for an unidentified message producer,
            specifying delivery mode, priority and time to live. </summary>
            <remarks>
            <para>
            Typically, a message producer is assigned a topic at creation time; however, 
             the TIBCO EME .NET API also supports unidentified message producers, 
            which require that the topic be supplied every time a message is published. 
            </para> </remarks>
            <param name="topic">The <see cref="T:TIBCO.EMS.Topic">Topic</see> to which this 
            message is to be published</param>
            <param name="message">The message to publish.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.
            </param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para>
            </param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="M:TIBCO.EMS.TopicPublisher.Publish(TIBCO.EMS.Topic,TIBCO.EMS.Message,TIBCO.EMS.MessageDeliveryMode,System.Int32,System.Int64)">
            <summary> Publishes a message to a topic for an unidentified message producer,
            specifying delivery mode, priority and time to live. </summary>
            <remarks>
            <para>
            Typically, a message producer is assigned a topic at creation time; however, 
             the TIBCO EME .NET API also supports unidentified message producers, 
            which require that the topic be supplied every time a message is published. 
            </para> </remarks>
            <param name="topic">The <see cref="T:TIBCO.EMS.Topic">Topic</see> to which this 
            message is to be published</param>
            <param name="message">The message to publish.</param>
            <param name="deliveryMode">The delivery mode to use.  This argument may be either an 
            enumerated value (see <see cref="T:TIBCO.EMS.MessageDeliveryMode">MessageDeliveryMode</see>) or an integer 
            (see <see cref="T:TIBCO.EMS.DeliveryMode">DeliveryMode</see>). We recommend enumerated values, because 
            they enable .NET to do stronger type checking at compile time, which can 
            enhance program reliability.
            </param>
            <param name="priority"><para>The priority for this message.
            </para>
            <para>Priority affects the order in which the server delivers messages to 
            consumers (higher values first). The JMS specification defines ten levels 
            of priority value, from zero (lowest priority) to 9 (highest priority). 
            The specification suggests that clients consider 0-4 as gradations of normal 
            priority, and priorities 5-9 as gradations of expedited priority.</para>
            </param>
            <param name="timeToLive"><para>The message's lifetime (in milliseconds) before it expires.
            </para>
            <list type="bullet">
            <item><description>If the time-to-live is non-zero, the expiration is the sum of that time-to-live 
            and the sending client's current time (GMT). This rule applies even within 
            sessions with transaction semantics - the timer begins with the send call, 
            not the commit call.
            </description></item>
            <item><description>If the time-to-live is zero, then expiration is also zero - indicating that 
            the message never expires.
            </description></item>
            </list>
            <para>
            Programs can use this property to define a default time-to-live for messages 
            that this producer sends. Individual sending calls can override this default value.
            </para>
            <para>Whenever your application uses non-zero values for message expiration or time-to-live, 
            you must ensure that clocks are synchronized among all the host computers that 
            send and receive messages. Synchronize clocks to a tolerance that is a very 
            small fraction of the smallest or time-to-live.
            </para>
            </param>
        </member>
        <member name="T:TIBCO.EMS.TopicRequestor">
            <summary> 
            This class provides a request/reply facility for messaging over a topic.  
            </summary> 
            <remarks>
            <para>We recommend that clients follow these steps:</para>
            <list type="number">
            <item><description>Create a <see cref="T:TIBCO.EMS.TopicSession">TopicSession</see>, and use it to 
            create a <see cref="T:TIBCO.EMS.Topic">Topic</see> for requests and replies.</description></item>
            <item><description>Create a TopicRequestor, using the topic session and Topic as arguments.</description></item>
            <item><description>Send a request and receive a reply. You may repeat this step for several request 
            and reply pairs.</description></item>
            <item><description>Close the requestor object, when done. The <see cref="M:TIBCO.EMS.TopicRequestor.Close">Close</see> 
            method also closes the requestor's session as a side effect.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.TopicRequestor.#ctor(TIBCO.EMS.TopicSession,TIBCO.EMS.Topic)">
            <summary>
            Construct a TopicRequestor object given a topic session and topic.
            </summary>
            <param name="session"><para>The non-transacted 
            <see cref="T:TIBCO.EMS.TopicSession">TopicSession</see>.</para>
            <para>The requestor operates within this topic session.</para>
            <para>This session must not use transaction semantics. Its delivery mode must 
            be either AutoAcknowledge or DupsOkAcknowledge.</para>
            <para>The <see cref="M:TIBCO.EMS.TopicRequestor.Close">Close</see> method also closes this 
            session as a side effect.</para> 
            </param>
            <param name="topic">The topic destination on which to send a request and
            wait for a reply.  Note that this topic must belong to the 
            <see cref="T:TIBCO.EMS.TopicSession">TopicSession</see>
            provided by the session parameter </param>
            <exception cref="T:TIBCO.EMS.EMSException">An EMSExceptin may be thrown in case of failure </exception>
        </member>
        <member name="M:TIBCO.EMS.TopicRequestor.Request(TIBCO.EMS.Message)">
            <summary> Send the request message and obtain its reply.
            </summary>
            <remarks>The requestor receives only the first reply. It discards other replies
             that arrive subsequently.</remarks>
            <param name="message"> The request message. </param>
            <returns> The reply for the request sent. </returns>
            <exception cref="T:TIBCO.EMS.EMSException">In case of errors in sending request and receiving reply</exception>
        </member>
        <member name="M:TIBCO.EMS.TopicRequestor.Close">
            <summary> Close the TopicRequestor object.
            </summary>
            <remarks>This method also closes the <see cref="T:TIBCO.EMS.TopicSession">TopicSession</see> 
            as a side effect.</remarks>
            <exception cref="T:TIBCO.EMS.EMSException">In case of errors in closing the TopicRequestor object</exception>
        </member>
        <member name="T:TIBCO.EMS.TopicSession">
            <summary>A TopicSession object provides methods for creating TopicPublisher, 
            TopicSubscriber.
            </summary>
            <remarks>
            <b>Note: </b>
            The TopicSession class is for backwards compatibility to support older clients.
            New clients should use the <see cref="T:TIBCO.EMS.Session">Session</see> class.
            <para> A TopicSession is used for creating Pub/Sub specific objects.
            In general, use the Session object, and use TopicSession only to support 
            existing code. Using the Session object simplifies the programming model 
            and allows transactions to be used across the two messaging domains
            </para>
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.TopicSession.#ctor(TIBCO.EMS.Connection,System.Int64,TIBCO.EMS.SessionMode,System.Boolean,System.Boolean)">
            <summary>Construct a topic session object </summary>
            <param name="connection">The connection the session belongs to </param>
            <param name="sessid">The id of the session </param>
            <param name="acknowledgeMode">The session acknowledgment mode </param>
            <param name="_explicit">Whether the session is explicitly acknowledging</param>
            <param name="transacted">Whether the session is transacted </param>
        </member>
        <member name="M:TIBCO.EMS.TopicSession.CreateSubscriber(TIBCO.EMS.Topic)">
            <summary> Create a nondurable subscriber to the specified topic. </summary>
            <remarks>
            <para>
            A client uses a TopicSubscriber object to receive messages that have been 
            published to a topic. 
            </para>
            <para> Regular TopicSubscriber objects are not durable. They receive only 
            messages that are published while they are active. 
            </para>
            <para>In some cases, a connection may both publish and subscribe to a topic. 
            The subscriber NoLocal attribute allows a subscriber to inhibit 
            the delivery of messages published by its own connection.
            The default value for this attribute is false
            </para>
            </remarks>
            <param name="topic">The Topic to subscribe to</param>
            <exception cref="T:TIBCO.EMS.InvalidDestinationException"> if an invalid topic is specified</exception>
        </member>
        <member name="M:TIBCO.EMS.TopicSession.CreateSubscriber(TIBCO.EMS.Topic,System.String,System.Boolean)">
            <summary> Create a nondurable subscriber to the specified topic, using a
            message selector or specifying whether messages published by its own
            connection should be delivered to it. 
            </summary>
            <remarks>
            <para>
            A client uses a TopicSubscriber object to receive messages that have been published
             to a topic. 
            </para>
            <para>
            Regular TopicSubscriber objects are not durable. They receive only messages that 
            are published while they are active. 
            Messages filtered out by a subscriber's message selector will never be delivered 
            to the subscriber. From the subscriber's perspective, they do not exist. 
            </para>
            <para> In some cases, a connection may both publish and subscribe to a topic.
            The subscriber NoLocal attribute allows a subscriber to inhibit the delivery of 
            messages published by its own connection. The default value for this attribute is false. 
            </para>
            </remarks>
            <param name="topic">the Topic to subscribe to</param>
            <param name="messageSelector">only messages with properties matching the 
            message selector expression are delivered. 
            A value of null or an empty string indicates that there is no 
            message selector for the message consumer.</param>
            <param name="noLocal">if set, inhibits the delivery of messages published by 
            its own connection </param>
        </member>
        <member name="M:TIBCO.EMS.TopicSession.CreatePublisher(TIBCO.EMS.Topic)">
            <summary>Create a publisher for the specified topic. </summary>
            <remarks>
            <para>
            A client uses a TopicPublisher object to publish messages on a topic. 
            Each time a client creates a TopicPublisher on a topic, it defines a 
            new sequence of messages that have no ordering relationship with the messages
            it has previously sent. 
            </para>
            </remarks>
            <param name="topic">the Topic to publish to, or null if this is an unidentified producer </param>
        </member>
        <member name="T:TIBCO.EMS.TopicSubscriber">
            <summary>A client uses a TopicSubscriber object to receive messages that 
            have been published to a topic. </summary>
            <remarks ref="true()">
              <para> 
            A TopicSubscriber object is the publish/subscribe form of a MessageConsumer. 
            The TopicSubscriber class inherits almost all of its behavior from MessageConsumer and adds 
            the properties, NoLocal and Topic.
            A MessageConsumer is created by Session.createConsumer. 
            
            </para><para>
            A TopicSession allows the creation of multiple TopicSubscriber 
            objects per topic. It will deliver each message for a topic to 
            each subscriber eligible to receive it. Each copy of the message is treated 
            as a completely separate message. Work done on one copy has no effect 
            on the others; acknowledging one does not acknowledge the others;
             one message may be delivered immediately, while another waits for its 
             subscriber to process messages ahead of it. </para>
             <para>Regular TopicSubscriber objects are not durable. They receive only
             messages that are published while they are active. 
             </para>
             <para>Messages filtered out by a subscriber's message selector will 
             never be delivered to the subscriber. From the subscriber's perspective,
             they do not exist. </para>
             <para>In some cases, a connection may both publish and subscribe to a topic.
             The subscriber NoLocal attribute allows a subscriber to inhibit the delivery
             of messages published by its own connection. 
             </para>
             <para>If a client needs to receive all the messages published on a topic, 
             including the ones published while the subscriber is inactive, 
             it uses a durable TopicSubscriber. The EMS Server retains a record of this 
             durable subscription and insures that all messages from the topic's publishers 
             are retained until they are acknowledged by this durable subscriber or they have expired. 
             </para>
             <para> Sessions with durable subscribers must always provide the same 
             client identifier. In addition, each client must specify a name that 
             uniquely identifies (within client identifier) each durable subscription 
             it creates. Only one session at a time can have a TopicSubscriber for 
             a particular durable subscription. 
             </para>
             <para> A client can change an existing durable subscription by creating 
             a durable TopicSubscriber with the same name and a new topic and/or 
             message selector. Changing a durable subscription is equivalent to
             unsubscribing (deleting) the old one and creating a new one. 
            </para>
            <para> The unsubscribe method is used to delete a durable subscription.
            The unsubscribe method can be used at the Session or TopicSession level. 
            This method deletes the state being maintained on behalf of the subscriber by its provider.
            </para>
            </remarks>
            <b>Note: </b>
            This class is provided for backward compatibility to support older EMS clients programs.
            New clients should use the <see cref="T:TIBCO.EMS.MessageConsumer">MessageConsumer</see> class instead.
        </member>
        <member name="M:TIBCO.EMS.TopicSubscriber.#ctor(TIBCO.EMS.Session,TIBCO.EMS.Topic,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Construct a new topic subscriber given session, topic and selector string</summary>
             <param name="session">The session that the topic subscriber is on </param>
             <param name="topic">The topic destination to browse </param>
             <param name="selector">The selector string in message to subscribe. </param>
             <param name="subscriptionName">the subscription name of the subscriber </param>
             <param name="isDurable">if this subscriber is durable </param>
             <param name="isShared">if this subscriber is shared </param>
             <param name="noLocal">whether to deliver locally produced msgs or not</param>
        </member>
        <member name="P:TIBCO.EMS.TopicSubscriber.Topic">
            <summary> Gets the Topic associated with this subscriber </summary>
            <remarks><para>The subscriber consumes messages from this topic.</para>
            <para>Programs set this topic property when creating the subscriber and cannot 
            subsequently change it.</para>
            </remarks>
            <returns> this subscriber's Topic </returns>
        </member>
        <member name="P:TIBCO.EMS.TopicSubscriber.NoLocal">
            <summary> Gets the NoLocal attribute for this subscriber. </summary>
            <remarks>
            <para>When NoLocal is true, the subscriber does not receive messages sent through 
            the same server connection (that is, the connection associated with the subscriber).</para>
            <para>Programs set this property when creating the subscriber, and cannot subsequently 
            change it.</para>
            </remarks>
            <returns> true if locally published messages are being inhibited </returns>
        </member>
        <member name="T:TIBCO.EMS.TransactionInProgressException">
            <summary>This exception indicates that the transaction associated with 
            processing of the request is in progress
            </summary>
            <remarks>
            When a session uses an XA transaction manager, the XA resource must be the
            location for all commit and rollback requests. Local commit or rollback calls 
            are not permitted, and throw this exception.
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.TransactionInProgressException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the TransactionInProgressException
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.TransactionInProgressException.#ctor(System.String)">
            <summary> Initializes a new instance of the TransactionInProgressException
            with the specified reason.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.TransactionRolledBackException">
            <summary>An attempt to commit a transaction resulted in rollback</summary>
            <remarks>
            This exception indicates that the transaction associated with 
            processing of the request has been rolled back, or it has been marked to roll back.
            As a result, the requested operation either could not be performed or was not performed 
            because further computation on behalf of the transaction would have no effect. 
            </remarks>
        </member>
        <member name="M:TIBCO.EMS.TransactionRolledBackException.#ctor(System.String,System.String)">
            <summary> Initializes a new instance of the TransactionRolledBackException 
            with the specified reason and error code.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.TransactionRolledBackException.#ctor(System.String)">
            <summary> Initializes a new instance of the TransactionRolledBackException 
            with the specified reason.
            </summary>
        </member>
        <member name="F:TIBCO.EMS.Utilities.MILLIS_TICKS_CONVERSION">
            <summary>The conversion between milliseconds and DateTime.Ticks
            which is in units of 100-nanoseconds. 1 msec = 10000 ticks </summary>
        </member>
        <member name="F:TIBCO.EMS.Utilities.SHIFT_TIME">
            <summary>The ticks time that needed to be shifted to convert
            between in milliseconds time of c/java approach (elapsed 
            since 00:00:00 January 1, 1970 and that of .NET (elapsed 
            since 00:00:00 January 1, 0001. 
            Add this value when converting from c/java to .NET, and substract
            otherwise. </summary>
        </member>
        <member name="M:TIBCO.EMS.Utilities.IsJavaIdentifierStart(System.Char)">
            <summary>Verify whether a character is a java indentifier start.
             Implementation followed that of the C library</summary>
        </member>
        <member name="M:TIBCO.EMS.Utilities.IsJavaIdentifierPart(System.Char)">
            <summary>Verify whether a character is part of a java indentifier.
             Implementation followed that of the C library</summary>
        </member>
        <member name="M:TIBCO.EMS.Utilities.GetCurrentTimeInMillis">
            <summary>Get the current time in milliseconds since 
            coordinated universal time (UTC) 12:00 am, January 1, 
            1970.</summary>
            <remarks>This .NET DateTime class takes reference on 
            12:00am, January 1, 0001.  But both java and c takes
            12:00am, January 1, 1970.  The time information
            in the message has to be consistent in order for
            heterogenous clients to co-operate.  This function
            thus performs the conversion so that the milliseconds
            since 12:00am, January 1, 1970 is returned.
            </remarks>
            <returns> current time in millisecondes </returns>
        </member>
        <member name="M:TIBCO.EMS.Utilities.MillisToDateTime(System.Int64)">
            <summary>Construct a DateTime object given the number
            of milliseconds elapseds since UTC 00:00:00, January
            1 of 1970. </summary>
            <param name="msec">Time in milliseconds elapsed since UTC
            00:00:00 January 1, 1970.</param>
            <returns>A DateTime object representing the time.</returns>
        </member>
        <member name="M:TIBCO.EMS.Utilities.HostToNet(System.Byte[],System.Boolean)">
            <summary> Convert a byte array from host byte order to
            network byte order </summary>
            <param name="val"> The byte array in host byte order to convert </param>
            <param name="makeCopy"> If true, the returned array is a copy of the argument array, 
            otherwise, the argumetn array itself is modified. </param>
            <returns> byte array in network order </returns>
        </member>
        <member name="M:TIBCO.EMS.Utilities.NetToHost(System.Byte[],System.Boolean)">
            <summary> Convert a byte array from network byte order to
            host byte order </summary>
            <param name="val"> The byte array in network byte order to convert </param>
            <param name="makeCopy"> If true, the returned array is a copy of the argument array, 
            otherwise, the argumetn array itself is modified. </param>
            <returns> byte array in host order </returns>
        </member>
        <member name="M:TIBCO.EMS.Utilities.NetToHost(System.Byte[],System.Int32,System.Int32)">
            <summary> Convert a portion of a byte array from network byte order to
            host byte order </summary>
            <param name="val"> The byte array in network byte order </param>
            <param name="start"> The index of the argument array from which the convertion starts </param>
            <param name="length"> The length from the starting index </param>
            <returns> byte array in host order </returns>
            <remarks> The content of the argument array is not modified.  The array returned is
            a newly allocated array containing portion of the argument array in host byte order 
            </remarks>
        </member>
        <member name="T:TIBCO.EMS.XAConnection">
            <summary>
            For Internal Use Only. Internally used for .NET 2.0 clients.
            </summary>
        </member>
        <member name="T:TIBCO.EMS.XAConnectionFactory">
            <summary> 
            For Internal Use Only. Internally used for .NET 2.0 clients.
            </summary>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetServerUrl(System.String)">
            <summary> set the server url.</summary>
            <remarks ref="true()">
            <para>The server URL is of the form:</para>
            <code><I>protocol</I>://<I>hostName</I>:<I>portNumber</I></code>
            <para>For example: </para>
            <code>tcp://localhost:7222</code>
            <para>The server URL for a fault-tolerant configuration is a string 
            with multiple URL's that are comma separated. </para>
            <para>For example: </para>
            <code>tcp://localhost:7222,tcp://localhost:7224</code>
            </remarks>
            <param name="serverUrl">The constructor contacts the EMS server at this URL, to
            access a factory. If connecting a fault-tolerant client, specify two or more
            comma-separated URLs, as described below in Reconnect and Fault Tolerance.</param>
            <exception cref="T:TIBCO.EMS.EMSException">Url is already set or some other 
            error. </exception>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetClientID(System.String)">
            <summary> Set the client id </summary>
            <param name="clientID">The client id </param>
            <exception cref="T:TIBCO.EMS.EMSException"> The specified client id already exists</exception>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetMetric(System.Int32)">
            <summary> Set the load balance metric
            </summary>
            <param name="metric"> The load balance metric </param>
            <exception cref="T:TIBCO.EMS.EMSException"> Invalid metric </exception>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetConnAttemptCount(System.Int32)">
            <summary> Set the number of connection attempts</summary>
            <remarks ref="true()"></remarks>
            <param name="attempts"> The number of connection attempts </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetConnAttemptDelay(System.Int32)">
            <summary> Set delay between connection attempts
            </summary>
            <remarks ref="true()"></remarks>
            <param name="delay"> Time (in milliseconds) of the delay between connection attempts. </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetReconnAttemptCount(System.Int32)">
            <summary> Set number of reconnect attempts
            </summary>
            <remarks ref="true()"></remarks>
            <param name="attempts"> The number of connection attempts </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetReconnAttemptDelay(System.Int32)">
            <summary> Set delay between reconnect attempts
            </summary>
            <remarks ref="true()"></remarks>
            <param name="delay"> Time (in milliseconds) of the delay between reconnect attempts </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetUserName(System.String)">
            <summary> Set user name
            </summary>
            <param name="username"> User name </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetUserPassword(System.String)">
            <summary> Set user password
            </summary>
            <param name="password"> User password </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetConnAttemptTimeout(System.Int32)">
            <summary>Set the Connect Attempt timeout for a given connection.</summary>
            <remarks ref="true()"> 
            <para>This timeout is per url and per connect_attempt.
            For example, to specify two connect attempts for a given url, then 
            for each attempt the client will wait for the period specified by the 
            connect attempt timeout for the connection to be established. If no 
            connection is established within that the specified timeframe, the client 
            connection attempt is terminated. </para>
            </remarks>
            <param name="timeout">The timeout, in milliseconds.  The
            minimum value is 100 milliseconds. If a value of less than 100 
            milliseconds is specified, then the minimum value of 100 milliseconds 
            is used. </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetReconnAttemptTimeout(System.Int32)">
            <summary>
            Set the Reconnect Attempt timeout for a given connection.</summary>
            <remarks ref="true()">
            This timeout is per url and per reconnect_attempt. For example, to specify two 
            reconnect attempts for a given url, then for each attempt the client will 
            wait for the period specified by the reconnect attempt timeout for the 
            connection to be established. If no reconnection is established within 
            that the specified timeframe, the reconnection attempt is terminated. 
            </remarks>
            <param name="timeout">The timeout, in milliseconds.  The
            minimum value is 100 milliseconds. If a value of less than 100 
            milliseconds is specified, then the minimum value of 100 milliseconds 
            is used. </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetMulticastEnabled(System.Boolean)">
            <summary>
            Set whether MessageConsumers subscribed to a multicast-enabled topic
            will receive messages over multicast.</summary>
            <remarks ref="true()">
            When enabled, MessageConsumers subscribed to a multicast-enabled topic
            will receive messages over multicast. The default is enabled.
            </remarks>
            <param name="enabled">true to enable multicast, false to disable 
            multicast.</param>
            \deprecated As of release 8.3
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetMulticastDaemon(System.String)">
            <summary>
            Set the port on which the client will connect to the multicast
            daemon.</summary>
            <remarks ref="true()">
            A connection to the multicast daemon is required when multicast is
            enabled and a MessageConsumer is subscribed to a multicast-enabled
            topic. Setting the port with this method will override the default
            port supplied by the server.
            </remarks>
            <param name="port">the port on which the client will connect to the
            multicast daemon.</param>
            \deprecated As of release 8.3
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetSSLTrace(System.Boolean)">
            <summary> Enable or disable tracing on the client side.</summary>
            <remarks>Tracing will show information during the SSL handshake 
            and on messages received and sent by the SSL link.</remarks>
            <param name="trace"> Flag to indicate whether tracing should be
            enabled for all connection created via this connection factory.
            <list type="bullet">
            <item>When true, tracing is enabled.</item>
            <item>When false, (the default) tracing is disabled.</item>
            </list>
            </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetSSLAuthOnly(System.Boolean)">
            <summary> Enable or disable encryption/decryption of the message data over 
            the SSL connection  </summary>
            <remarks ref="true()">
            For the client and server to require an SSL connection only to perform 
            authentication, the ssl_auth_only parameter needs to be set on the server 
            and AUTH_ONLY needs to be set by the client. Setting these flags on both 
            the server and client side indicates that the SSL connection is only used 
            to only perform authentication. Once authentication is complete, the client 
            switches to a regular TCP connection to communicate with the server.
            </remarks>
            <param name="authOnly"> Flag to indicate whether the connection
            should only authenticate. 
            <list type="bullet">
            <item>When true, only the authentication to connect is performed and data 
            sent over the connection is not encrypted or decrypted.</item>
            <item> When false (the default), authentication to is performed and data 
            sent over the connection is encrypted and decrypted.</item>
            </list>
            </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetTargetHostName(System.String)">
            <summary> Set the name of the target EMS server.</summary>
            <remarks>
            This is a required parameter for all .NET SSL connections.
            Because System.Net.Security.SslStream requires a targetHost, 
            this value is required and cannot be NULL.
            </remarks>
            <param name="targetHostName"> The name of the server as defined in the
            server's certificate. Usually the server's HostName is specified as the
            CN in the server's certificate.
            </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetCertificateStoreType(TIBCO.EMS.EMSSSLStoreType,System.Object)">
            <summary> Set the certificate store type and info. </summary>
            <param name="type">The type of certificate store. Can be either 
            EMSSSL_STORE_TYPE_SYSTEM or EMSSSL_STORE_TYPE_FILE.  See
            <see cref="T:TIBCO.EMS.EMSSSLStoreType">EMSSSLStoreType</see> for details. </param>
            <param name="storeInfo">If the store type is EMSSSL_STORE_TYPE_SYSTEM, 
            then storeInfo must be an EMSSSLSystemStoreInfo object. If the store 
            type is EMSSSL_STORE_TYPE_FILE, then storeInfo must be an 
            <see cref="T:TIBCO.EMS.EMSSSLFileStoreInfo">EMSSSLFileStoreInfo</see> 
            object.</param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.GetCertificateStore">
            <summary> Get the certificate store info object associated with this 
            connection factory.
            </summary>
            <remarks> can be null or of type EMSSSLFileStoreInfo or 
            EMSSSLSystemStoreInfo. 
            NOTE: SSL Connection factory objects that are
            looked up in JNDI have a certificate store info already created.
            This allows a user to get access to the certificate store object
            and set properties not present in the JNDI object. e.g. ssl password.
            </remarks>
            <example>
            <code>
              EMSSSLFileStoreInfo info = (EMSSSLFileStoreInfo)cf.GetCertificateStore();
              String _password        = "password";
              info.SetSSLPassword(_password.ToCharArray());
            </code>
            </example>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetHostNameVerifier(TIBCO.EMS.EMSSSLHostNameVerifier)">
            <summary> Set the custom host name verifier. Set to null to 
            remove custom host name verifier.
            </summary>
            <param name="verifier">Host name verifier. Set to null to remove custom 
            host name verifier. See <see cref="T:TIBCO.EMS.EMSSSLHostNameVerifier">EMSSSLHostNameVerifier</see> 
            for details.
            </param>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetClientTracer(System.IO.StreamWriter)">
            <summary> Set client tracer to given output stream. </summary>
            <remarks>Client tracing prints loaded certificates and information 
            about the SSL handshake errors and results.
            </remarks>
            <param name="tracer">The output stream to send the tracing information. 
            Specify null as parameter to disable client tracing. </param>
            
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetSSLProxy(System.String,System.Int32)">
            <summary>
            Set the connection factory's parameters for connecting through an SSL
            proxy.
            </summary>
            <remarks>
            An SSL proxy lets an EMS application create an SSL connection to an EMS
            server, even though a firewall separates the application from the server.
            The proxy usually runs within the firewall's DMZ. A connection factory
            contacts the SSL proxy, requesting an SSL connection to the server. The
            proxy authenticates the application program, and mediates the initial
            SSL negotiation between application and server. After the SSL connection
            is established, the application and server use it to communicate
            directly with one another.
            </remarks>
            <param name="host"> The connection factory establishes SSL communication
            through a web proxy at this host. Supply a simple hostname, a 
            fully qualified hostname with domain name, or an IP address 
            (dot notation). 
            </param>
            <param name="port"> The connection factory establishes SSL communication
            through a web proxy on this port. </param>
            <exception cref="T:TIBCO.EMS.EMSException"> if the proxy host is null or empty,
            the port is zero or the protocol of the connection factory's URL is
            not SSL.
            </exception>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.SetSSLProxyAuth(System.String,System.String)">
            <summary>
            Set a connection factory's username and password for connecting through
            an SSL proxy.
            </summary>
            <remarks>
            <para>When a connection factory establishes an EMS server connection through 
            an SSL proxy host, the proxy might first require authentication before
            facilitating a connection. When required, use this call to set that
            authentication data on the connection factory. 
            </para>
            <b>Note: </b>
            This proxy authentication data is distinct from the server authentication data 
            and from the SSL private key encryption password.
            </remarks>
            <param name="username"> The connection factory authenticates itself 
            to the SSL proxy using this username. </param>
            <param name="password"> The connection factory authenticates itself 
            to the SSL proxy using this password. </param>
            <exception cref="T:TIBCO.EMS.EMSException"> if the protocol of the connection 
            factory's URL is not SSL.
            </exception>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.GetSSLProxyHost">
            <summary>
            Get the SSL proxy host from this connection factory.
            </summary>
            <returns>return the host</returns>
            <exception cref="T:TIBCO.EMS.EMSException"> if the protocol of the connection 
            factory's URL is not SSL.</exception>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.GetSSLProxyPort">
            <summary>
            Get the SSL proxy port from this connection factory.
            </summary>
            <returns> the port. </returns>
            <exception cref="T:TIBCO.EMS.EMSException"> if the protocol of the connection 
            factory's URL is not SSL.
            </exception>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.GetSSLProxyUser">
            <summary>
            Get the SSL proxy username from a connection factory.
            </summary>
            <returns> the username. </returns>
            <exception cref="T:TIBCO.EMS.EMSException"> if the protocol of the connection 
            factory's URL is not SSL.
            </exception>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.GetSSLProxyPassword">
            <summary>
            Get the SSL proxy password from a connection factory.
            </summary>
            <returns> the password. </returns>
            <exception cref="T:TIBCO.EMS.EMSException"> if the protocol of the connection 
            factory's URL is not SSL.
            </exception>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.CreateConnection">
            <summary>
            Returns and regular connection object, again this is for internal
            use only, can however be called from EMSDTCConnectionFactory
            </summary>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.CreateConnection(System.String,System.String)">
            <summary>
            Returns and regular connection object, again this is for internal
            use only, can however be called from EMSDTCConnectionFactory
            </summary>
        </member>
        <member name="M:TIBCO.EMS.XAConnectionFactory.Clone">
            <summary>
            </summary>
        </member>
        <member name="T:TIBCO.EMS.XAResource">
            <summary>  
            This class implements the XAResource interface for use with an XASession.
            
            </summary>
        </member>
        <member name="T:TIBCO.EMS.XASession">
            <summary>
            For Internal Use Only. Internally used for .NET 2.0 clients.
            </summary>
        </member>
    </members>
</doc>
